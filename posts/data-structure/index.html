<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title>考研807数据结构复习笔记 - 旧笔记 - ImportMengjie's Blog</title><meta name=Description content="考研807数据结构复习笔记"><meta property="og:title" content="考研807数据结构复习笔记 - 旧笔记">
<meta property="og:description" content="考研807数据结构复习笔记">
<meta property="og:type" content="article">
<meta property="og:url" content="https://importmengjie.github.io/posts/data-structure/"><meta property="og:image" content="https://importmengjie.github.io/logo.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-11-19T20:44:04+00:00">
<meta property="article:modified_time" content="2018-11-19T20:44:04+00:00"><meta property="og:site_name" content="ImportMengjie">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://importmengjie.github.io/logo.png">
<meta name=twitter:title content="考研807数据结构复习笔记 - 旧笔记">
<meta name=twitter:description content="考研807数据结构复习笔记">
<meta name=application-name content="ImportMengjie's Blog">
<meta name=apple-mobile-web-app-title content="ImportMengjie's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://importmengjie.github.io/posts/data-structure/><link rel=prev href=https://importmengjie.github.io/posts/python_study_notes/><link rel=next href=https://importmengjie.github.io/posts/operating-system/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'">
<noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'">
<noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"考研807数据结构复习笔记 - 旧笔记","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/importmengjie.github.io\/posts\/data-structure\/"},"genre":"posts","keywords":"基础知识, 考研, 算法与数据结构","wordcount":5663,"url":"https:\/\/importmengjie.github.io\/posts\/data-structure\/","datePublished":"2018-11-19T20:44:04+00:00","dateModified":"2018-11-19T20:44:04+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"mengjie"},"description":"考研807数据结构复习笔记"}</script></head>
<body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="ImportMengjie's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/avatar.jpg data-srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" data-sizes=auto alt=/images/avatar.jpg title=/images/avatar.jpg>ImportMengjie</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/> 首页 </a><a class=menu-item href=/posts/ title=posts> 文章 </a><a class=menu-item href=/tags/> 标签 </a><a class=menu-item href=/categories/> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search>
<i class="fas fa-search fa-fw" aria-hidden=true></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear>
<i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="ImportMengjie's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/avatar.jpg data-srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" data-sizes=auto alt=/images/avatar.jpg title=/images/avatar.jpg>ImportMengjie</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search>
<i class="fas fa-search fa-fw" aria-hidden=true></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear>
<i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span>
</div>
<a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
Cancel
</a>
</div><a class=menu-item href=/ title>首页</a><a class=menu-item href=/posts/ title=posts>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a></div>
</div>
</header><div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div><main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">考研807数据结构复习笔记 - 旧笔记</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>mengjie</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2018-11-19>2018-11-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5663 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;12 minutes&nbsp;
<span id=busuanzi_container_value_page_pv><i class="far fa-eye fa-fw"></i>
<span id=busuanzi_value_page_pv></span>&nbsp;views</span>
</div>
</div><div class="details toc" id=toc-static data-kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#一绪论>（一）绪论</a>
<ul>
<li><a href=#数据结构的基本概念数据的逻辑结构存储结构>数据结构的基本概念，数据的逻辑结构、存储结构；</a></li>
<li><a href=#算法的定义和应具有的特性算法设计的要求算法的时间复杂度分析和算法的空间复杂度分析>算法的定义和应具有的特性，算法设计的要求，算法的时间复杂度分析和算法的空间复杂度分析。</a></li>
</ul>
</li>
<li><a href=#二线性表>（二）线性表</a>
<ul>
<li><a href=#线性结构的特点线性表的定义线性表的基本操作>线性结构的特点、线性表的定义，线性表的基本操作；</a></li>
<li><a href=#线性表的顺序存储结构对其进行检索插入和删除等操作>线性表的顺序存储结构，对其进行检索、插入和删除等操作；</a></li>
<li><a href=#线性表的链式存储结构单链表双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作>线性表的链式存储结构，单链表、双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作。</a></li>
</ul>
</li>
<li><a href=#三栈和队列递归算法>（三）栈和队列，递归算法</a>
<ul>
<li><a href=#栈的定义结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法>栈的定义、结构特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法；</a></li>
<li><a href=#队列的结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法>队列的结构、特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法。</a></li>
<li><a href=#递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法>递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法；</a></li>
<li><a href=#用栈实现递归问题的非递归解法>用栈实现递归问题的非递归解法。</a></li>
</ul>
</li>
<li><a href=#四数组和串>（四）数组和串</a>
<ul>
<li><a href=#串的基本概念串的存储结构和相关的操作算法>串的基本概念、串的存储结构和相关的操作算法；</a></li>
<li><a href=#数组的存储结构在顺序存储的情况下数组元素与存储单元的对应关系>数组的存储结构，在顺序存储的情况下，数组元素与存储单元的对应关系；</a></li>
<li><a href=#稀疏矩阵的存储结构和特点以及基本操作>稀疏矩阵的存储结构和特点以及基本操作。</a></li>
<li><a href=#字符串匹配算法例如kmp算法>字符串匹配算法(例如KMP算法)。</a></li>
</ul>
</li>
<li><a href=#五树和森林>（五）树和森林</a>
<ul>
<li><a href=#树的结构和主要概念各种二叉树的结构及其特点>树的结构和主要概念，各种二叉树的结构及其特点；</a></li>
<li><a href=#二叉树的三种遍历方法的实现原理和性质能将二叉树的遍历方法应用于求解二叉树的叶子结点个数二叉树计数等问题遍历的非递归实现方法>二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法；</a></li>
<li><a href=#线索化二叉树的结构和基本操作>线索化二叉树的结构和基本操作；</a></li>
<li><a href=#森林的定义和存储结构森林的遍历等方法的实现>森林的定义和存储结构，森林的遍历等方法的实现；</a></li>
<li><a href=#基于霍夫曼树生成霍夫曼编码的方法>基于霍夫曼树生成霍夫曼编码的方法；</a></li>
<li><a href=#avl树的定义和特点以及avl树调整操作的实现原理>AVL树的定义和特点以及AVL树调整操作的实现原理；</a></li>
<li><a href=#最优二叉树的构造原理和相关算法>最优二叉树的构造原理和相关算法。</a></li>
</ul>
</li>
<li><a href=#六图>（六）图</a>
<ul>
<li><a href=#图的各种基本概念和各种存储方式>图的各种基本概念和各种存储方式；</a></li>
<li><a href=#图的两种搜索方法和图连的连通性>图的两种搜索方法和图连的连通性；</a></li>
<li><a href=#两种最小生成树的生成方法>两种最小生成树的生成方法；</a></li>
<li><a href=#各种求最短路径的方法>各种求最短路径的方法；</a></li>
<li><a href=#用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法>用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法。</a></li>
</ul>
</li>
<li><a href=#七排序>（七）排序</a>
<ul>
<li><a href=#插入排序法含折半插入排序法选择排序法冒泡排序法快速排序法堆积排序法归并排序基数排序等排序方法排序的原理规律和特点>插入排序法(含折半插入排序法)、选择排序法、冒泡排序法、快速排序法、堆积排序法、归并排序、基数排序等排序方法排序的原理、规律和特点；</a></li>
<li><a href=#各种排序算法的时空复杂度的简单分析>各种排序算法的时空复杂度的简单分析。</a></li>
</ul>
</li>
<li><a href=#八索引结构与散列>（八）索引结构与散列</a>
<ul>
<li><a href=#线性索引结构倒排表静态搜索树的结构和特点>线性索引结构、倒排表、静态搜索树的结构和特点；</a></li>
<li><a href=#b树的结构>B树的结构</a></li>
<li><a href=#散列的实现原理和各种操作的实现算法>散列的实现原理和各种操作的实现算法。</a></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><h2 id=一绪论>（一）绪论</h2>
<h3 id=数据结构的基本概念数据的逻辑结构存储结构>数据结构的基本概念，数据的逻辑结构、存储结构；</h3>
<h4 id=逻辑结构>逻辑结构:</h4>
<ol>
<li>线性结构</li>
<li>非线性结构
<ul>
<li>树</li>
<li>图</li>
<li>集合</li>
</ul>
</li>
</ol>
<h4 id=存储结构>存储结构</h4>
<ol>
<li>顺序存储</li>
<li>链接存储</li>
<li>索引存储
<ul>
<li>在存储的同时,还建立附加的索引表</li>
</ul>
</li>
<li>散列存储</li>
</ol>
<h3 id=算法的定义和应具有的特性算法设计的要求算法的时间复杂度分析和算法的空间复杂度分析>算法的定义和应具有的特性，算法设计的要求，算法的时间复杂度分析和算法的空间复杂度分析。</h3>
<h2 id=二线性表>（二）线性表</h2>
<h3 id=线性结构的特点线性表的定义线性表的基本操作>线性结构的特点、线性表的定义，线性表的基本操作；</h3>
<p><a href=./List/List.h rel>list定义</a></p>
<p>线性表的顺序存<strong>储</strong>结构是一种<em>随机存<strong>取</strong></em>的存储结构,线性表的链式存储结构是一种<em>顺序存<strong>取</strong></em>的存储结构.</p>
<h3 id=线性表的顺序存储结构对其进行检索插入和删除等操作>线性表的顺序存储结构，对其进行检索、插入和删除等操作；</h3>
<h3 id=线性表的链式存储结构单链表双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作>线性表的链式存储结构，单链表、双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作。</h3>
<h2 id=三栈和队列递归算法>（三）栈和队列，递归算法</h2>
<h3 id=栈的定义结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法>栈的定义、结构特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法；</h3>
<h3 id=队列的结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法>队列的结构、特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法。</h3>
<p><a href=./List/CircularQueue.h rel>循环队列实现</a></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 初始化
</span><span class=c1></span><span class=n>Q</span><span class=p>.</span><span class=n>rear</span><span class=o>=</span><span class=n>Q</span><span class=p>.</span><span class=n>front</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>

<span class=c1>// 判断空
</span><span class=c1></span><span class=n>Q</span><span class=p>.</span><span class=n>rear</span><span class=o>==</span><span class=n>Q</span><span class=p>.</span><span class=n>front</span><span class=p>;</span>

<span class=c1>// 判断队满
</span><span class=c1></span><span class=p>(</span><span class=n>Q</span><span class=p>.</span><span class=n>rear</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>MAXSIZE</span><span class=o>==</span><span class=n>Q</span><span class=p>.</span><span class=n>front</span><span class=p>;</span>

<span class=c1>// 队列长度
</span><span class=c1></span><span class=p>(</span><span class=n>Q</span><span class=p>.</span><span class=n>rear</span><span class=o>+</span><span class=n>MAXSIZE</span><span class=o>-</span><span class=n>Q</span><span class=p>.</span><span class=n>front</span><span class=p>)</span><span class=o>%</span><span class=n>MAXSIZE</span><span class=p>;</span>
</code></pre></div><h3 id=递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法>递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法；</h3>
<h3 id=用栈实现递归问题的非递归解法>用栈实现递归问题的非递归解法。</h3>
<h2 id=四数组和串>（四）数组和串</h2>
<h3 id=串的基本概念串的存储结构和相关的操作算法>串的基本概念、串的存储结构和相关的操作算法；</h3>
<h3 id=数组的存储结构在顺序存储的情况下数组元素与存储单元的对应关系>数组的存储结构，在顺序存储的情况下，数组元素与存储单元的对应关系；</h3>
<h3 id=稀疏矩阵的存储结构和特点以及基本操作>稀疏矩阵的存储结构和特点以及基本操作。</h3>
<pre><code>对于矩阵中实际存储的元素&lt;&lt;矩阵大小时,可以只存取三元组(行标,列标,值)的list.
</code></pre>
<h3 id=字符串匹配算法例如kmp算法>字符串匹配算法(例如KMP算法)。</h3>
<h2 id=五树和森林>（五）树和森林</h2>
<h3 id=树的结构和主要概念各种二叉树的结构及其特点>树的结构和主要概念，各种二叉树的结构及其特点；</h3>
<h4 id=树的基本术语>树的基本术语</h4>
<ol>
<li>
<p>度</p>
<p>树中一个节点的子节点个数称为该<strong>节点的度</strong>,树中最大度数称为<strong>树的度</strong></p>
</li>
<li>
<p>深度</p>
<p>从根节点开始自顶向下逐层累加</p>
</li>
<li>
<p>高度</p>
<p>从叶节点开始自底向上逐层累加</p>
</li>
<li>
<p>树的高度(深度)</p>
<p>树中节点最大的层数</p>
</li>
</ol>
<h4 id=二叉树的特点>二叉树的特点</h4>
<p>N<sub>0</sub>表示叶子节点数,N<sub>2</sub>表示度为2的节点则N<sub>0</sub>=N<sub>2</sub>+1</p>
<p>故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N<sub>0</sub>+N<sub>1</sub>=N<sub>0</sub>+N<sub>1</sub>+N<sub>2</sub>+1</p>
<h4 id=二叉树的数组表示方法>二叉树的数组表示方法</h4>
<p>If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \leq i \leq n$, we have</p>
<ol>
<li>parent(i) is at int(i/2) if $i \neq 1$. If i = 1, i is at the root and has no parent.</li>
<li>LeftChild(i) is at 2i if $2i \leq n$. If $2i \geq n$, then i has no left child.</li>
<li>RightChild(i) is at 2i+1 if $2i+1 \leq n$. If $2i+1 \geq n$, then i has no right child.</li>
</ol>
<h5 id=二叉树与度为2的树的区别>二叉树与度为2的树的区别</h5>
<ol>
<li>度为2的树至少含有三个节点才可以,二叉树则可为空</li>
<li>度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同</li>
</ol>
<h4 id=各种二叉树>各种二叉树</h4>
<ol>
<li>
<p>满二叉树</p>
<p>叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2</p>
</li>
<li>
<p>完全二叉树</p>
<p>每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素.</p>
</li>
<li>
<p>平衡二叉树</p>
<p>树上任意节点的左子树和右子树的深度之差不超过1</p>
</li>
</ol>
<h3 id=二叉树的三种遍历方法的实现原理和性质能将二叉树的遍历方法应用于求解二叉树的叶子结点个数二叉树计数等问题遍历的非递归实现方法>二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法；</h3>
<h4 id=遍历方法>遍历方法</h4>
<ol>
<li>
<p>先序遍历(PreOrder)</p>
<p>顺序:根节点,先序遍历左子树,先序遍历右子树</p>
<p>实现: <a href=./Tree/TreeNode.h#L51 rel>递归实现</a></p>
<p>非递归实现</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>PreOrder2</span><span class=p>(</span><span class=n>BiTree</span> <span class=n>t</span><span class=p>){</span>
    <span class=n>InitStack</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
    <span class=n>BiTree</span> <span class=n>p</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>||!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>)){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=p>){</span>
            <span class=n>visit</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
            <span class=n>Push</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>else</span><span class=p>{</span>
            <span class=n>Pop</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>中序遍历(InOrder)</p>
<p>顺序:中序遍历左子树,根节点,中序遍历右子树</p>
<p>实现: <a href=./Tree/TreeNode.h#L41 rel>递归实现</a></p>
<p>非递归实现</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>InOrder2</span><span class=p>(</span><span class=n>BiTree</span> <span class=n>t</span><span class=p>){</span>
    <span class=n>InitStack</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
    <span class=n>BiTree</span> <span class=n>p</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>||!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>)){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=p>){</span>
            <span class=n>Push</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>else</span><span class=p>{</span>
            <span class=n>Pop</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=n>visit</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
            <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>后序遍历(PostOrder)</p>
<p>顺序:后序遍历左子树,后序遍历右子树,根节点</p>
<p>实现: <a href=./Tree/TreeNode.h#L62 rel>递归实现</a></p>
<p>非递归实现:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>PostOrder</span><span class=p>(</span><span class=n>BiTree</span> <span class=n>T</span><span class=p>){</span>
    <span class=n>InitStack</span><span class=p>(</span><span class=n>S</span><span class=p>);</span>
    <span class=n>BiTree</span> <span class=n>p</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
    <span class=n>BiTree</span> <span class=n>r</span> <span class=o>=</span> <span class=nb>NULL</span><span class=o>:</span>
    <span class=k>while</span><span class=p>(</span><span class=n>p</span><span class=o>||!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>S</span><span class=p>)){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=p>){</span>
            <span class=n>push</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>else</span><span class=p>{</span>
            <span class=n>GetTop</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
            <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=o>&amp;&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=o>!=</span><span class=n>r</span><span class=p>){</span>
                <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=p>;</span>
                <span class=n>push</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
                <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>else</span><span class=p>{</span>
                <span class=n>pop</span><span class=p>(</span><span class=n>S</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
                <span class=n>visit</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
                <span class=n>r</span><span class=o>=</span><span class=n>p</span><span class=p>;</span>
                <span class=n>p</span><span class=o>=</span><span class=nb>NULL</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
</ol>
<p>根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而<strong>先序和后序则不能确定一颗二叉树</strong></p>
<h4 id=层次遍历>层次遍历</h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>LevelOrder</span><span class=p>(</span><span class=n>BiTree</span> <span class=n>T</span><span class=p>){</span>
    <span class=n>InitQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>
    <span class=n>BiTree</span> <span class=n>p</span><span class=p>;</span>
    <span class=n>EnQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>T</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>IsEmpty</span><span class=p>(</span><span class=n>Q</span><span class=p>)){</span>
        <span class=n>Dequeue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
        <span class=n>visit</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>){</span>
            <span class=n>EnQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>){</span>
            <span class=n>EnQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h4 id=计算树的深度>计算树的深度</h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>BitDepth</span><span class=p>(</span><span class=n>BiTree</span> <span class=n>T</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>T</span><span class=o>==</span><span class=nb>NULL</span><span class=p>)</span> 
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>else</span><span class=p>{</span>
        <span class=n>ldep</span> <span class=o>=</span> <span class=n>Btdepth</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>lchild</span><span class=p>);</span>
        <span class=n>rdep</span> <span class=o>=</span> <span class=n>Btdepth</span><span class=p>(</span><span class=n>T</span><span class=o>-&gt;</span><span class=n>rchild</span><span class=p>);</span>
        <span class=k>if</span><span class=p>(</span><span class=n>ldep</span><span class=o>&gt;</span><span class=n>rdep</span><span class=p>)</span>
            <span class=k>return</span> <span class=n>ldep</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
        <span class=k>else</span>
            <span class=k>return</span> <span class=n>rdep</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

<span class=p>}</span>
</code></pre></div><h3 id=线索化二叉树的结构和基本操作>线索化二叉树的结构和基本操作；</h3>
<p>格式:</p>
<table>
<thead>
<tr>
<th style=text-align:center>ltag</th>
<th style=text-align:center>lchild</th>
<th style=text-align:center>data</th>
<th style=text-align:center>rchild</th>
<th style=text-align:center>rtag</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>1:指向节点的前驱</td>
<td style=text-align:center></td>
<td style=text-align:center></td>
<td style=text-align:center></td>
<td style=text-align:center>1:指向节点的后继</td>
</tr>
</tbody>
</table>
<p>中序线索二叉树示例</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e4%b8%ad%e5%ba%8f%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e4%b8%ad%e5%ba%8f%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e4%b8%ad%e5%ba%8f%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e4%b8%ad%e5%ba%8f%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/中序线索二叉树.png title=线索二叉树></p>
<h3 id=森林的定义和存储结构森林的遍历等方法的实现>森林的定义和存储结构，森林的遍历等方法的实现；</h3>
<h4 id=森林存储结构>森林存储结构</h4>
<ol>
<li>
<p>双亲表示法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e5%8f%8c%e4%ba%b2%e8%a1%a8%e7%a4%ba%e6%b3%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e5%8f%8c%e4%ba%b2%e8%a1%a8%e7%a4%ba%e6%b3%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e5%8f%8c%e4%ba%b2%e8%a1%a8%e7%a4%ba%e6%b3%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e5%8f%8c%e4%ba%b2%e8%a1%a8%e7%a4%ba%e6%b3%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/森林双亲表示法.png title=双亲表示法></p>
</li>
<li>
<p>孩子表示法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e8%a1%a8%e7%a4%ba%e6%b3%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/孩子表示法.png title=孩子表示法></p>
</li>
<li>
<p>孩子兄弟表示法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%ad%a9%e5%ad%90%e5%85%84%e5%bc%9f%e8%a1%a8%e7%a4%ba%e6%b3%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/孩子兄弟表示法.png title=孩子兄弟表示法></p>
</li>
</ol>
<h4 id=森林二叉树>森林=>二叉树</h4>
<p>用孩子兄弟表示法将树=>二叉树(由于根节点没有兄弟所以没有右子树)=>将森林的多颗树连在一起</p>
<p>例:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91%e4%be%8b%e5%ad%90.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91%e4%be%8b%e5%ad%90.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91%e4%be%8b%e5%ad%90.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%a3%ae%e6%9e%97%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91%e4%be%8b%e5%ad%90.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/森林转二叉树例子.png title="森林=&amp;gt;二叉树"></p>
<h4 id=森林遍历方法>森林遍历方法</h4>
<p>树和森林遍历与二叉树遍历的对应关系</p>
<table>
<thead>
<tr>
<th style=text-align:center>树</th>
<th style=text-align:center>森林</th>
<th style=text-align:center>二叉树(将森林或树转换成的二叉树)</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>先根遍历</td>
<td style=text-align:center>先序遍历</td>
<td style=text-align:center>先序遍历</td>
</tr>
<tr>
<td style=text-align:center>后根遍历</td>
<td style=text-align:center>中序遍历</td>
<td style=text-align:center>中序遍历</td>
</tr>
</tbody>
</table>
<h3 id=基于霍夫曼树生成霍夫曼编码的方法>基于霍夫曼树生成霍夫曼编码的方法；</h3>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman1.bmp data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman1.bmp, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman1.bmp 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman1.bmp 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman1.bmp title=huffman>
<img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman2.bmp data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman2.bmp, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman2.bmp 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman2.bmp 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/huffman2.bmp title=huffman></p>
<p>13+9=22</p>
<h3 id=avl树的定义和特点以及avl树调整操作的实现原理>AVL树的定义和特点以及AVL树调整操作的实现原理；</h3>
<h4 id=avl树的定义>AVL树的定义</h4>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。</p>
<h4 id=调整操作>调整操作</h4>
<ol>
<li>
<p>LR型</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LR.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LR.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LR.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LR.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LR.png title=LR></p>
</li>
<li>
<p>LL型</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LL.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LL.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LL.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LL.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_LL.png title=LL></p>
</li>
<li>
<p>RR型</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RR.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RR.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RR.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RR.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RR.png title=RR></p>
</li>
<li>
<p>RL型</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RL.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RL.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RL.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RL.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/AVLtree_RL.png title=RL></p>
</li>
</ol>
<h3 id=最优二叉树的构造原理和相关算法>最优二叉树的构造原理和相关算法。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>treenode</span> <span class=o>*</span><span class=nf>huffmanTree</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>//n为叶子个数
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>        
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>//将每一个叶子节点建成一棵树，放入数组tree[]中
</span><span class=c1></span>        <span class=n>treenode</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>new</span> <span class=n>treenode</span><span class=p>;</span>
        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>   <span class=c1>//arr[]中放着叶子节点的权值
</span><span class=c1></span>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>lch</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>p</span><span class=o>-&gt;</span><span class=n>rch</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>tree</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>treenode</span> <span class=o>*</span><span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>//定义最优二叉树的根
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//每次取arr[]中未使用的最小两个值
</span><span class=c1></span>        <span class=n>sort</span><span class=p>(</span><span class=n>arr</span> <span class=o>+</span> <span class=n>i</span><span class=p>,</span> <span class=n>arr</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
        <span class=n>treenode</span> <span class=o>*</span><span class=n>ch1</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>*</span><span class=n>ch2</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>index</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span><span class=c1>//在数组tree[]中找到这两个值，建立新的节点
</span><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>tree</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>==</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
                <span class=n>ch1</span> <span class=o>=</span> <span class=n>tree</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
            <span class=k>if</span><span class=p>(</span><span class=n>tree</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>==</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span>
                <span class=n>ch2</span> <span class=o>=</span> <span class=n>tree</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
            <span class=k>if</span><span class=p>(</span><span class=n>ch1</span> <span class=o>&amp;&amp;</span> <span class=n>ch2</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>treenode</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>new</span> <span class=n>treenode</span><span class=p>;</span><span class=c1>//建立新的节点，存入数组tree[]中
</span><span class=c1></span>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>ch1</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>ch2</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
        <span class=n>p</span><span class=o>-&gt;</span><span class=n>lch</span> <span class=o>=</span> <span class=n>ch1</span><span class=p>;</span>
        <span class=n>p</span><span class=o>-&gt;</span><span class=n>rch</span> <span class=o>=</span> <span class=n>ch2</span><span class=p>;</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span><span class=c1>//更新根，直到建立完成
</span><span class=c1></span>        <span class=n>tree</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span><span class=c1>//并将这个节点的权值传入数组arr[]中
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>return</span> <span class=n>root</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h2 id=六图>（六）图</h2>
<h3 id=图的各种基本概念和各种存储方式>图的各种基本概念和各种存储方式；</h3>
<h4 id=图的基本概念>图的基本概念</h4>
<ol>
<li>
<p>有向图</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%9c%89%e5%90%91%e5%9b%be.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%9c%89%e5%90%91%e5%9b%be.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%9c%89%e5%90%91%e5%9b%be.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%9c%89%e5%90%91%e5%9b%be.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/有向图.png title=有向图></p>
<p>表示法:</p>
<p>V(G3)={0,1,2}</p>
<p>E(G3)={&lt;0,1>,&lt;1,0>,&lt;1,2>}</p>
<p>强连通: 节点v到w和w到v都有<strong>路径</strong></p>
<p>强连通分量: 极大强连通子图</p>
<p>入度,出度: 入度和=出度和=边数</p>
</li>
<li>
<p>无向图</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%97%a0%e5%90%91%e5%9b%be.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%97%a0%e5%90%91%e5%9b%be.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%97%a0%e5%90%91%e5%9b%be.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%97%a0%e5%90%91%e5%9b%be.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/无向图.png title=无向图></p>
<p>表示法</p>
<p>V(G1)={0,1,2,3}</p>
<p>E(G1)={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)}</p>
<p>连通: 从v到w的<strong>路径</strong>存在,则v和w是连通的.</p>
<p>连通图: 图G的任意两个顶点都是连通的.</p>
<p>连通分量: 极大连通子图; 连通图只有一个连通分量; 非连通图有多个连通分量</p>
<p>极大连通子图: 要求连通子图包含其所有的边</p>
<p>极小连通子图: 保持连通又使得边数最少(生成树)</p>
</li>
<li>
<p>完全图</p>
<p>任意两个顶点都存在边.</p>
<ul>
<li>n个顶点的有向图=>n(n-1)条边</li>
<li>n个顶点的无向图=>n(n-1)/2条边</li>
</ul>
</li>
<li>
<p>稀疏图|E|&lt;|V|*log|V|和稠密图</p>
</li>
</ol>
<h4 id=各种存储方式>各种存储方式</h4>
<ol>
<li>
<p>邻接矩阵法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e6%b3%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e6%b3%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e6%b3%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e6%b3%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/邻接矩阵法.png title=邻接矩阵法></p>
</li>
<li>
<p>邻接表法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%b3%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%b3%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%b3%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%82%bb%e6%8e%a5%e8%a1%a8%e6%b3%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/邻接表法.png title=邻接表法></p>
<p>定义:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=err>＃</span><span class=n>define</span>   <span class=n>MaxVerNum</span>  <span class=mi>100</span>          <span class=cm>/*最大顶点数为100*/</span>
<span class=c1>// 邻接表类型 ：
</span><span class=c1></span><span class=k>typedef</span>  <span class=k>struct</span>  <span class=n>ArcNode</span>
<span class=p>{</span> 
    <span class=kt>int</span>  <span class=n>adjvex</span><span class=p>;</span>              <span class=cm>/*邻接点域*/</span>
    <span class=n>InfoType</span>  <span class=o>*</span><span class=n>Info</span><span class=p>;</span>     <span class=cm>/*表示边上信息的域info*/</span>
    <span class=k>struct</span> <span class=n>ArcNode</span> <span class=o>*</span> <span class=n>next</span><span class=p>;</span>    <span class=cm>/*指向下一个邻接点的指针域*/</span>
<span class=p>}</span> <span class=n>ArcNode</span> <span class=p>;</span>    

<span class=c1>// 表头结点类型 ：
</span><span class=c1></span><span class=k>typedef</span>  <span class=k>struct</span>  <span class=n>Vnode</span>
<span class=p>{</span>
    <span class=n>VertexType</span>   <span class=n>vertex</span><span class=p>;</span>          <span class=cm>/*顶点域*/</span>
    <span class=n>ArcNode</span>  <span class=o>*</span> <span class=n>firstedge</span><span class=p>;</span>        <span class=cm>/*边表头指针*/</span>
<span class=p>}</span> <span class=n>Vnode</span><span class=p>,</span>  <span class=n>AdjList</span> <span class=p>[</span><span class=n>MaxVertexNum</span><span class=p>];</span>   

<span class=c1>// 图的类型 ： 
</span><span class=c1></span><span class=k>typedef</span>   <span class=k>struct</span>
<span class=p>{</span>
    <span class=n>AdjList</span>   <span class=n>vertices</span><span class=p>;</span>         <span class=cm>/*邻接表*/</span>
    <span class=kt>int</span>   <span class=n>vexnum</span><span class=p>,</span>  <span class=n>arcnum</span><span class=p>;</span>          <span class=cm>/*顶点数和边数*/</span>
<span class=p>}</span> <span class=n>ALGraph</span><span class=p>;</span>      <span class=cm>/*ALGraph是以邻接表方式存储的图类型*/</span>
</code></pre></div></li>
</ol>
<h3 id=图的两种搜索方法和图连的连通性>图的两种搜索方法和图连的连通性；</h3>
<h4 id=图的两种搜索方法>图的两种搜索方法</h4>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DFS_BFS_sample.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DFS_BFS_sample.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DFS_BFS_sample.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DFS_BFS_sample.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DFS_BFS_sample.png title=DFS_BFS_sample></p>
<p>两个基本函数</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>FirstAdjVex</span><span class=p>(</span><span class=n>ALGraph</span> <span class=n>G</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
<span class=p>{</span>  
    <span class=c1>// 返回G中第v个顶点的第1个邻接点的序号。如果v无邻接点，返回0。
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>G</span><span class=p>.</span><span class=n>vertices</span><span class=p>[</span><span class=n>v</span><span class=p>].</span><span class=n>firstarc</span><span class=p>)</span> 
        <span class=k>return</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=k>else</span> 
        <span class=k>return</span><span class=p>(</span><span class=n>G</span><span class=p>.</span><span class=n>vertices</span><span class=p>[</span><span class=n>v</span><span class=p>].</span><span class=n>firstarc</span><span class=o>-&gt;</span><span class=n>adjvex</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>NextAdjVex</span><span class=p>(</span><span class=n>ALGraph</span> <span class=n>G</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=kt>int</span> <span class=n>w</span><span class=p>)</span>
<span class=p>{</span>  
    <span class=c1>// 返回G中第v个顶点的相对于顶点w的下一个邻接点的序号。
</span><span class=c1></span>    <span class=c1>// 如果v无相对于顶点w的下一个邻接点，返回0。
</span><span class=c1></span>    <span class=n>ArcNode</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
    <span class=n>p</span><span class=o>=</span><span class=n>G</span><span class=p>.</span><span class=n>vetrices</span><span class=p>[</span><span class=n>v</span><span class=p>].</span><span class=n>firstarc</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span> <span class=n>p</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>adjvex</span><span class=o>!=</span><span class=n>w</span><span class=p>)</span>
        <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>nextarc</span><span class=p>;</span>
    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>adjvex</span><span class=o>==</span><span class=n>w</span> <span class=o>&amp;&amp;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>nextarc</span><span class=p>)</span>
        <span class=k>return</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>nextarc</span><span class=o>-&gt;</span><span class=n>adjvex</span><span class=p>);</span>
    <span class=k>else</span> 
        <span class=k>return</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><ol>
<li>
<p>DFS(深度优先)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>DFSTraverse</span><span class=p>(</span> <span class=n>Graph</span> <span class=n>G</span> <span class=p>)</span> 
<span class=p>{</span>
    <span class=kt>bool</span> <span class=n>visited</span><span class=p>[</span><span class=n>MAX</span><span class=p>]</span> <span class=p>;</span>  <span class=c1>//用于标识结点是否已被访问过     
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span> <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>&lt;=</span><span class=n>G</span><span class=p>.</span><span class=n>vexnum</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span> <span class=p>)</span> 
        <span class=n>visited</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>FALSE</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span> <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>&lt;=</span><span class=n>G</span><span class=p>.</span><span class=n>vexnum</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span> <span class=p>)</span>
        <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>visited</span><span class=p>[</span> <span class=n>k</span> <span class=p>]</span> <span class=p>)</span>
            <span class=n>DFS</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>DFS</span><span class=p>(</span> <span class=n>Graph</span> <span class=n>G</span><span class=p>,</span>  <span class=kt>int</span> <span class=n>v</span> <span class=p>)</span>
<span class=p>{</span>  
    <span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>TRUE</span><span class=p>;</span>  
    <span class=n>VISIT</span><span class=p>(</span> <span class=n>v</span> <span class=p>);</span>  <span class=c1>// 访问图G中第v个顶点
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>w</span><span class=o>=</span><span class=n>FirstAdjVex</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span> <span class=n>w</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>;</span> <span class=n>w</span><span class=o>=</span><span class=n>NextAdjVex</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span> 
        <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>visited</span><span class=p>[</span> <span class=n>w</span> <span class=p>]</span> <span class=p>)</span>
            <span class=n>DFS</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>w</span><span class=p>);</span>
<span class=p>}</span>

</code></pre></div></li>
<li>
<p>BFS(广度优先)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>BFSTraverse</span><span class=p>(</span> <span class=n>Graph</span> <span class=n>G</span> <span class=p>)</span> 
<span class=p>{</span> 
    <span class=kt>bool</span> <span class=n>visited</span><span class=p>[</span><span class=n>MAX</span><span class=p>]</span> <span class=p>;</span>  <span class=c1>//用于标识结点是否已被访问过     
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>v</span><span class=o>&lt;=</span><span class=n>G</span><span class=p>.</span><span class=n>vexnum</span><span class=p>;</span> <span class=o>++</span><span class=n>v</span><span class=p>)</span>  
        <span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>FALSE</span><span class=p>;</span>
    <span class=n>InitQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>);</span>
    <span class=k>for</span><span class=p>(</span><span class=n>v</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>v</span><span class=o>&lt;=</span><span class=n>G</span><span class=p>.</span><span class=n>vexnum</span><span class=p>;</span> <span class=o>++</span><span class=n>v</span><span class=p>)</span>
        <span class=k>if</span> <span class=p>(</span> <span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=p>)</span> 
        <span class=p>{</span>  
            <span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>=</span><span class=n>TRUE</span><span class=p>;</span>
            <span class=n>VISIT</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
            <span class=n>EnQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>EmptyQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>))</span>
            <span class=p>{</span> 
                <span class=n>DeQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span><span class=n>u</span><span class=p>);</span> 
                <span class=k>for</span><span class=p>(</span><span class=n>w</span><span class=o>=</span><span class=n>FirstAdjVex</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>u</span><span class=p>);</span> <span class=n>w</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>;</span> <span class=n>w</span><span class=o>=</span><span class=n>NextAdjVex</span><span class=p>(</span><span class=n>G</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
                    <span class=k>if</span><span class=p>(</span> <span class=o>!</span><span class=n>visited</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=p>)</span>  
                    <span class=p>{</span>  
                        <span class=n>visited</span><span class=p>[</span><span class=n>w</span><span class=p>]</span><span class=o>=</span><span class=n>TRUE</span><span class=p>;</span> 
                        <span class=n>VISIT</span><span class=p>(</span><span class=n>w</span><span class=p>);</span> 
                        <span class=n>EnQueue</span><span class=p>(</span><span class=n>Q</span><span class=p>,</span> <span class=n>w</span><span class=p>);</span> 
                    <span class=p>}</span>
            <span class=p>}</span> <span class=c1>// end while
</span><span class=c1></span>        <span class=p>}</span> <span class=c1>// end if
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></li>
</ol>
<h3 id=两种最小生成树的生成方法>两种最小生成树的生成方法；</h3>
<ol>
<li>
<p>Prim 算法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/prim.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/prim.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/prim.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/prim.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/prim.png title=Prim></p>
</li>
<li>
<p>Kruskal 算法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/kruskal.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/kruskal.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/kruskal.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/kruskal.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/kruskal.png title=Kruskal></p>
</li>
</ol>
<h3 id=各种求最短路径的方法>各种求最短路径的方法；</h3>
<ol>
<li>
<p>Dijkstra 算法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/dijkstra.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/dijkstra.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/dijkstra.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/dijkstra.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/dijkstra.png title=Dijkstra></p>
</li>
<li>
<p>Floyed 算法</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/floyd.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/floyd.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/floyd.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/floyd.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/floyd.png title=Floyed></p>
</li>
</ol>
<h3 id=用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法>用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法。</h3>
<ol>
<li>
<p>AOV-Network (Activity on Vertex)</p>
<p>顶点表示活动,边&lt;v<sub>1</sub>,v<sub>2</sub>>表示活动v1先于活动v2,必须是有向无环图.(依赖关系)</p>
<p>拓扑排序:</p>
<pre><code> 1. 从图中选择一个没有前驱的节点并输出
 2. 从图中删除该节点和以它为起点的有向边
 3. 重复步骤1,2
</code></pre>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/Topological_sort.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/Topological_sort.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/Topological_sort.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/Topological_sort.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/Topological_sort.png title=拓扑排序></p>
</li>
<li>
<p>AOE-Network (Activity on Edge)</p>
<p>顶点表示事件,有向边表示活动,边上的权重表示完成该活动的开销.(软件项目安排)</p>
<p>关键路径: 从起点到终点的所有路径中,具有最大的路径长度的路径</p>
<pre><code> 1. 求AOE中所有事件的最早发生时间ve():从前往后计算
 2. 求AOE中所有事件的最晚发生时间vl():从后往前计算
 3. 求AOE中所有活动的最早开始时间e():边的起点的顶点的最早发生时间
 4. 求AOE中所有活动的最晚开始时间l():边的终点的顶点的最晚发生时间-边的权重
 5. 求AOE中所有活动的差额d(),找出d()=0构成关键路径
</code></pre>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/critical_path.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/critical_path.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/critical_path.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/critical_path.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/critical_path.png title=critical_path></p>
</li>
</ol>
<h2 id=七排序>（七）排序</h2>
<h3 id=插入排序法含折半插入排序法选择排序法冒泡排序法快速排序法堆积排序法归并排序基数排序等排序方法排序的原理规律和特点>插入排序法(含折半插入排序法)、选择排序法、冒泡排序法、快速排序法、堆积排序法、归并排序、基数排序等排序方法排序的原理、规律和特点；</h3>
<ol>
<li>
<p>插入排序</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// 直接插入排序
</span><span class=c1></span><span class=kt>void</span> <span class=nf>InsertSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>length</span><span class=p>){</span>
    <span class=cm>/*
</span><span class=cm>    * 插入排序
</span><span class=cm>    * 从头开始保证走过的路有序,每加入一个元素就将其插入到正确的位置
</span><span class=cm>    */</span>
    <span class=kt>int</span> <span class=n>j</span><span class=p>,</span><span class=n>i</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>length</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
            <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&lt;</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>];</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span>
                <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
            <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// 折半插入排序
</span><span class=c1></span><span class=kt>void</span> <span class=nf>InsertSort</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>low</span><span class=p>,</span><span class=n>high</span><span class=p>,</span><span class=n>mid</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
        <span class=n>A</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>low</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
        <span class=n>high</span><span class=o>=</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
        <span class=k>while</span><span class=p>(</span><span class=n>low</span><span class=o>&lt;=</span><span class=n>high</span><span class=p>){</span>
            <span class=n>mid</span><span class=o>=</span><span class=p>(</span><span class=n>low</span><span class=o>+</span><span class=n>high</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span>
            <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>mid</span><span class=p>].</span><span class=n>key</span><span class=o>&gt;</span><span class=n>A</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>key</span><span class=p>)</span>
                <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// 查找左半子树
</span><span class=c1></span>            <span class=k>else</span>
                <span class=n>low</span><span class=o>=</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span> <span class=c1>// 查找右半子树
</span><span class=c1></span>        <span class=p>}</span>
        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&gt;=</span><span class=n>high</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=o>--</span><span class=n>j</span><span class=p>)</span>
            <span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
        <span class=n>A</span><span class=p>[</span><span class=n>high</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>A</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// 希尔排序
</span><span class=c1></span><span class=kt>void</span> <span class=nf>ShellSort</span><span class=p>(</span><span class=n>SqList</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>,</span><span class=kt>int</span> <span class=n>dlta</span><span class=p>[],</span><span class=kt>int</span> <span class=n>t</span><span class=p>)</span>
<span class=p>{</span> 
    <span class=c1>// 按增量序列dlta[0..t-1]对顺序表L作希尔排序。算法.5
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>k</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>k</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;</span><span class=n>t</span><span class=p>;</span><span class=o>++</span><span class=n>k</span><span class=p>){</span>
        <span class=n>ShellInsert</span><span class=p>(</span><span class=n>L</span><span class=p>,</span><span class=n>dlta</span><span class=p>[</span><span class=n>k</span><span class=p>]);</span> <span class=c1>// 一趟增量为dlta[k]的插入排序
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;第%d趟排序结果: &#34;</span><span class=p>,</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
        <span class=n>print</span><span class=p>(</span><span class=n>L</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=kt>void</span> <span class=nf>ShellInsert</span><span class=p>(</span><span class=n>SqList</span> <span class=o>&amp;</span><span class=n>L</span><span class=p>,</span><span class=kt>int</span> <span class=n>dk</span><span class=p>){</span> 
    <span class=c1>// 对顺序表L作一趟希尔插入排//序。本算法是和一趟直接插入排序相比，
</span><span class=c1></span>    <span class=c1>// 作了以下修改：
</span><span class=c1></span>    <span class=c1>// 1.前后记录位置的增量是dk，而不是1;
</span><span class=c1></span>    <span class=c1>// 2.r[0]只是暂存单元，不是哨兵。当j&lt;=0时，插入位置已找到。
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=n>dk</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>L</span><span class=p>.</span><span class=n>length</span><span class=p>;</span><span class=o>++</span><span class=n>i</span><span class=p>){</span>
        <span class=k>if</span> <span class=n>LT</span><span class=p>(</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span><span class=p>,</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=n>dk</span><span class=p>].</span><span class=n>key</span><span class=p>){</span> 
            <span class=c1>// 需将L.r[i]插入有序增量子表
</span><span class=c1></span>            <span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=c1>// 暂存在L.r[0]
</span><span class=c1></span>            <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=o>-</span><span class=n>dk</span><span class=p>;</span><span class=n>j</span><span class=o>&gt;</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>LT</span><span class=p>(</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>key</span><span class=p>,</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>key</span><span class=p>);</span><span class=n>j</span><span class=o>-=</span><span class=n>dk</span><span class=p>)</span>
                <span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=n>dk</span><span class=p>]</span><span class=o>=</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>j</span><span class=p>];</span> <span class=c1>// 记录后移，查找插入位置
</span><span class=c1></span>            <span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=n>dk</span><span class=p>]</span><span class=o>=</span><span class=n>L</span><span class=p>.</span><span class=n>r</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=c1>// 插入
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>选择排序</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>SelectSort</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
        <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
            <span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&lt;</span><span class=n>A</span><span class=p>[</span><span class=n>min</span><span class=p>])</span>
                <span class=n>min</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>min</span><span class=o>!=</span><span class=n>i</span><span class=p>)</span>
            <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>A</span><span class=p>[</span><span class=n>min</span><span class=p>]);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>冒泡排序</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>bubble_sort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> 
    <span class=c1>// 将a中整数序列重新排列成自小至大有序的整数序列(起泡排序)
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>t</span><span class=p>;</span>
    <span class=n>Status</span> <span class=n>change</span> <span class=o>=</span> <span class=n>TRUE</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&gt;</span><span class=mi>1</span><span class=o>&amp;&amp;</span><span class=n>change</span><span class=p>;</span><span class=o>--</span><span class=n>i</span><span class=p>){</span>
        <span class=n>change</span><span class=o>=</span><span class=n>FALSE</span><span class=p>;</span>
        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>i</span><span class=p>;</span><span class=o>++</span><span class=n>j</span><span class=p>)</span>
        <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>&gt;</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]){</span>
            <span class=n>t</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
            <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
            <span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=n>t</span><span class=p>;</span>
            <span class=n>change</span><span class=o>=</span><span class=n>TRUE</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>快速排序</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>low</span><span class=o>&lt;</span><span class=n>high</span><span class=p>){</span>
        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>partition</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span><span class=n>high</span><span class=p>);</span>
        <span class=n>QuickSort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
        <span class=n>QuickSort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>partition</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span><span class=kt>int</span> <span class=n>low</span><span class=p>,</span><span class=kt>int</span> <span class=n>high</span><span class=p>){</span>
    <span class=kt>int</span> <span class=n>pivot</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
    <span class=k>while</span><span class=p>(</span><span class=n>low</span><span class=o>&lt;</span><span class=n>high</span><span class=p>){</span>
        <span class=k>while</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>high</span><span class=p>]</span><span class=o>&gt;=</span><span class=n>pivot</span> <span class=o>&amp;&amp;</span> <span class=n>low</span><span class=o>&lt;</span><span class=n>high</span><span class=p>)</span>
            <span class=n>high</span><span class=o>--</span><span class=p>;</span>
        <span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>high</span><span class=p>];</span>
        <span class=k>while</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>pivot</span> <span class=o>&amp;&amp;</span> <span class=n>low</span><span class=o>&lt;</span><span class=n>high</span><span class=p>)</span>
            <span class=n>low</span><span class=o>++</span><span class=p>;</span>
        <span class=n>a</span><span class=p>[</span><span class=n>high</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=n>a</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>=</span> <span class=n>pivot</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>low</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>堆排序</p>
<p>算法步骤:</p>
<ol>
<li>
<p>构造初始堆</p>
<ol>
<li>假设给定无序序列结构如下</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort1.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort1.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort1.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort1.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort1.png title=heapsort1></p>
<ol start=2>
<li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort2.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort2.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort2.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort2.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort2.png title=heapsort2></p>
<ol start=3>
<li>找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort3.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort3.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort3.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort3.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort3.png title=heapsort3></p>
<ol start=4>
<li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort4.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort4.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort4.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort4.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort4.png title=heapsort4></p>
</li>
<li>
<p>调整堆</p>
<ol>
<li>将堆顶元素9和末尾元素4进行交换</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort5.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort5.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort5.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort5.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort5.png title=heapsort5></p>
<ol start=2>
<li>重新调整结构，使其继续满足堆定义</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort6.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort6.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort6.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort6.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort6.png title=heapsort6></p>
<ol start=3>
<li>再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort7.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort7.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort7.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort7.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort7.png title=heapsort7></p>
<ol start=4>
<li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li>
</ol>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort8.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort8.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort8.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort8.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/heapsort/heapsort8.png title=heapsort8></p>
</li>
</ol>
<blockquote>
<p><a href=https://www.cnblogs.com/chengxiao/p/6129630.html target=_blank rel="noopener noreffer">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
</blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>AdjustDown</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>){</span>
    <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>k</span><span class=o>*</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>len</span><span class=p>;</span> <span class=n>i</span><span class=o>*=</span><span class=mi>2</span><span class=p>){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;</span><span class=n>len</span><span class=o>&amp;&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
        <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&gt;=</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=k>else</span><span class=p>{</span>
            <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=n>k</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>HeapSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>length</span><span class=p>){</span>
    <span class=c1>// build max heap
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>length</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span>
        <span class=n>AdjustDown</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>length</span><span class=p>);</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>length</span><span class=p>;</span><span class=n>i</span><span class=o>&gt;</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>){</span>
        <span class=kt>int</span> <span class=n>t</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
        <span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>

        <span class=n>AdjustDown</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>归并排序</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[]){</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>low</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>high</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>l</span><span class=p>,</span><span class=n>h</span><span class=p>,</span><span class=n>k</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=o>=</span><span class=n>low</span><span class=p>,</span><span class=n>l</span><span class=o>=</span><span class=n>low</span><span class=p>,</span><span class=n>h</span><span class=o>=</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=n>l</span><span class=o>&lt;=</span><span class=n>mid</span><span class=o>&amp;&amp;</span><span class=n>h</span><span class=o>&lt;=</span><span class=n>high</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>){</span>
        <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>l</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>b</span><span class=p>[</span><span class=n>h</span><span class=p>])</span>
            <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>l</span><span class=o>++</span><span class=p>];</span>
        <span class=k>else</span>
            <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>h</span><span class=o>++</span><span class=p>];</span>
    <span class=p>}</span>
    <span class=k>while</span><span class=p>(</span><span class=n>l</span><span class=o>&lt;=</span><span class=n>mid</span><span class=p>)</span>
        <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span><span class=o>=</span><span class=n>b</span><span class=p>[</span><span class=n>l</span><span class=o>++</span><span class=p>];</span>
    <span class=k>while</span><span class=p>(</span><span class=n>h</span><span class=o>&lt;=</span><span class=n>high</span><span class=p>)</span>
        <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span><span class=o>=</span><span class=n>b</span><span class=p>[</span><span class=n>h</span><span class=o>++</span><span class=p>];</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[]){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>low</span><span class=o>&lt;</span><span class=n>high</span><span class=p>){</span>
        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span><span class=o>+</span><span class=n>high</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
        <span class=n>MergeSort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>
        <span class=n>MergeSort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
        <span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span> <span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>MergeSort</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>len</span><span class=p>){</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>len</span><span class=p>];</span>
    <span class=n>MergeSort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
    <span class=n>delete</span> <span class=p>[]</span><span class=n>b</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li>
<li>
<p>基数排序</p>
<p>将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>时间复杂度:O(d(n+r))</p>
<p>其中d:d趟分配与收集;一趟分配:O(n);一趟收集:O(r)</p>
</li>
</ol>
<h3 id=各种排序算法的时空复杂度的简单分析>各种排序算法的时空复杂度的简单分析。</h3>
<table>
<thead>
<tr>
<th style=text-align:center>排序名称</th>
<th style=text-align:center>类别</th>
<th style=text-align:center>稳定性</th>
<th style=text-align:center>时间复杂度</th>
<th style=text-align:center>空间复杂度</th>
<th style=text-align:center>最少比较次数</th>
<th style=text-align:center>最多比较次数</th>
<th style=text-align:center>最少移动次数</th>
<th style=text-align:center>最多移动次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>插入排序</td>
<td style=text-align:center>插入排序</td>
<td style=text-align:center>稳定</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(1)</td>
<td style=text-align:center>n-1</td>
<td style=text-align:center>(n+2)(n-1)/2</td>
<td style=text-align:center>0</td>
<td style=text-align:center>(n+4)(n-1)/2</td>
</tr>
<tr>
<td style=text-align:center>希尔排序</td>
<td style=text-align:center>插入排序</td>
<td style=text-align:center>不稳定</td>
<td style=text-align:center>O(n<sup>1.5</sup>)</td>
<td style=text-align:center>o(1)</td>
<td style=text-align:center>/</td>
<td style=text-align:center>/</td>
<td style=text-align:center>/</td>
<td style=text-align:center>/</td>
</tr>
<tr>
<td style=text-align:center>冒泡排序</td>
<td style=text-align:center>交换排序</td>
<td style=text-align:center>稳定</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>o(1)</td>
<td style=text-align:center>n-1</td>
<td style=text-align:center>n(n-1)/2</td>
<td style=text-align:center>0</td>
<td style=text-align:center>n(n-1)/2</td>
</tr>
<tr>
<td style=text-align:center>快速排序</td>
<td style=text-align:center>交换排序</td>
<td style=text-align:center>不稳定</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>o(log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>n(n-1)/2</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>/</td>
</tr>
<tr>
<td style=text-align:center>选择排序</td>
<td style=text-align:center>选择排序</td>
<td style=text-align:center><strong>不稳定</strong></td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(1)</td>
<td style=text-align:center>n-1</td>
<td style=text-align:center>n(n-1)/2</td>
<td style=text-align:center>0</td>
<td style=text-align:center>3(n-1)</td>
</tr>
<tr>
<td style=text-align:center>堆排序</td>
<td style=text-align:center>选择排序</td>
<td style=text-align:center>不稳定</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(1)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>/</td>
<td style=text-align:center>/</td>
</tr>
<tr>
<td style=text-align:center>归并排序</td>
<td style=text-align:center>归并排序</td>
<td style=text-align:center>稳定</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>/</td>
<td style=text-align:center>/</td>
</tr>
<tr>
<td style=text-align:center>基数排序</td>
<td style=text-align:center>基数排序</td>
<td style=text-align:center>稳定</td>
<td style=text-align:center>O(d(n+rd))</td>
<td style=text-align:center>O(rd)</td>
<td style=text-align:center>0</td>
<td style=text-align:center>0</td>
<td style=text-align:center>0</td>
<td style=text-align:center>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style=text-align:center>排序名称</th>
<th style=text-align:center>平均情况</th>
<th style=text-align:center>最好情况</th>
<th style=text-align:center>最坏情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>直接插入排序</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(n)</td>
<td style=text-align:center>o(n<sup>2</sup>)</td>
</tr>
<tr>
<td style=text-align:center>希尔排序</td>
<td style=text-align:center>O(n<sup>1.5</sup>)</td>
<td style=text-align:center></td>
<td></td>
</tr>
<tr>
<td style=text-align:center>冒泡排序</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(n)</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td style=text-align:center>快速排序</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td style=text-align:center>简单选择排序</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
<td style=text-align:center>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td style=text-align:center>堆排序</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
</tr>
<tr>
<td style=text-align:center>归并排序</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
<td style=text-align:center>O(n*log<sub>2</sub>n)</td>
</tr>
<tr>
<td style=text-align:center>基数排序</td>
<td style=text-align:center>O(d(n+rd))</td>
<td style=text-align:center>O(d(n+rd))</td>
<td style=text-align:center>O(d(n+rd))</td>
</tr>
</tbody>
</table>
<h2 id=八索引结构与散列>（八）索引结构与散列</h2>
<h3 id=线性索引结构倒排表静态搜索树的结构和特点>线性索引结构、倒排表、静态搜索树的结构和特点；</h3>
<ol>
<li>
<p>线性索引结构</p>
<ol>
<li>
<p>稠密索引</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e7%a8%a0%e5%af%86%e7%b4%a2%e5%bc%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e7%a8%a0%e5%af%86%e7%b4%a2%e5%bc%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e7%a8%a0%e5%af%86%e7%b4%a2%e5%bc%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e7%a8%a0%e5%af%86%e7%b4%a2%e5%bc%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/稠密索引.png title=稠密></p>
</li>
<li>
<p>分块索引</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%88%86%e5%9d%97%e7%b4%a2%e5%bc%95.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%88%86%e5%9d%97%e7%b4%a2%e5%bc%95.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%88%86%e5%9d%97%e7%b4%a2%e5%bc%95.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%88%86%e5%9d%97%e7%b4%a2%e5%bc%95.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/分块索引.png title=分块></p>
</li>
<li>
<p>倒排索引</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%80%92%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%80%92%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%80%92%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e5%80%92%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/倒排索引.jpeg title=倒排索引></p>
</li>
<li>
<p>正排索引</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%ad%a3%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%ad%a3%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%ad%a3%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e6%ad%a3%e6%8e%92%e7%b4%a2%e5%bc%95.jpeg 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/正排索引.jpeg title=正排索引></p>
</li>
</ol>
</li>
<li>
<p>静态搜索树</p>
<p>查找表中各关键字被查找的概率是不同的</p>
<p>含有 9 个关键字的查找表及其相应权值如下表所示：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step1.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step1.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step1.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step1.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/静态搜索树_step1.png title=step1></p>
<ol>
<li>
<p>求出查找表中所有的 △P 的值，找出整棵查找表的根结点：</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step2.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step2.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step2.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step2.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/静态搜索树_step2.png title=step2></p>
<p>例如，关键字 F 的 △P 的计算方式为：从 G 到 I 的权值和 - 从 A 到 E 的权值和 = 4+3+5-1-1-2-5-3 = 0。</p>
</li>
<li>
<p>通过上图左侧表格得知，根结点为 F，以 F 为分界线，左侧子表为 F 结点的左子树，右侧子表为 F 结点的右子树（如上图右侧所示），继续查找左右子树的根结点:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step3.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step3.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step3.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step3.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/静态搜索树_step3.png title=step3></p>
</li>
<li>
<p>通过重新分别计算左右两查找子表的 △P 的值，得知左子树的根结点为 D，右子树的根结点为 H （如上图右侧所示），以两结点为分界线，继续判断两根结点的左右子树:</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step4.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step4.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step4.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/%e9%9d%99%e6%80%81%e6%90%9c%e7%b4%a2%e6%a0%91_step4.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/静态搜索树_step4.png title=step4></p>
</li>
</ol>
<p>注意：在建立次优查找树的过程中，由于只根据的各关键字的 P 的值进行构建，没有考虑单个关键字的相应权值的大小，有时会出现根结点的权值比孩子结点的权值还小，此时就需要适当调整两者的位置。</p>
<blockquote>
<p><a href=http://www.cnblogs.com/ciyeer/p/9067098.html target=_blank rel="noopener noreffer">http://www.cnblogs.com/ciyeer/p/9067098.html</a></p>
</blockquote>
</li>
</ol>
<h3 id=b树的结构>B树的结构</h3>
<p>m阶: 1&lt;子节点数量&lt;=M ,M>=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）；</p>
<ol>
<li>
<p>插入 (m=5, 每个节点含有[2,4]个value)</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert1.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert1.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert1.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert1.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert1.png title=插入></p>
<p>插入6</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert2.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert2.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert2.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert2.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_insert2.png title=插入></p>
</li>
<li>
<p>删除</p>
<ol>
<li>
<p>case 1</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_1.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_1.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_1.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_1.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_1.png title="case 1"></p>
<p>删除6</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_2.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_2.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_2.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_2.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case1_2.png title="case 1"></p>
</li>
<li>
<p>case 2</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_1.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_1.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_1.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_1.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_1.png title="case 2"></p>
<p>删除3</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_2.png data-srcset="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_2.png, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_2.png 1.5x, https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_2.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/BTree_delete_case2_2.png title="case 2"></p>
</li>
</ol>
</li>
</ol>
<h3 id=散列的实现原理和各种操作的实现算法>散列的实现原理和各种操作的实现算法。</h3>
<ol>
<li>
<p>Hash 函数</p>
<ol>
<li>
<p>直接地址法</p>
<p>H(key)=a*key+b</p>
<p>适合于关键字分布基本连续</p>
</li>
<li>
<p>除留余数法</p>
<p>H(key)=key%p</p>
<p>假定散列表长为m,取一个不大于m但接近或等于m的质数P</p>
</li>
<li>
<p>数字分析法</p>
<p>适用于已知关键字数字集合</p>
</li>
<li>
<p>平方取中法</p>
<p>取关键字的平方值的中间几位作为散列地址</p>
</li>
<li>
<p>折叠法</p>
<p>将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址</p>
</li>
</ol>
</li>
<li>
<p>冲突处理</p>
<ol>
<li>
<p>开放地址法</p>
<p>递推式: H<sub>i</sub>=(H(key) + d<sub>i</sub>) % m</p>
<p>d<sub>i</sub>是增量</p>
<p>删除时不能随便物理删除表中已有的元素,若删除将会截断其他具有相同的散列地址的元素的查找地址,所以要进行逻辑删除,打一个标记,定期维护,将删除标记的元素物理删除.</p>
<ol>
<li>
<p>线性探索法</p>
<p>往下一个一个找</p>
</li>
<li>
<p>平方探索法</p>
<p>当d<sub>i</sub> = 1^2,-1^2,2^2,-2^2,&mldr;,k^2,-k^2,其中$k \leq m/2$, m必须为可以表示成4k+3的质数</p>
<p>可以避免出现堆积的问题,但是不能探测到所有单元</p>
</li>
<li>
<p>再散列法</p>
<p>d<sub>i</sub>=Hash<sub>2</sub>(key)</p>
</li>
<li>
<p>伪随机法</p>
<p>d<sub>i</sub>=伪随机序列</p>
</li>
</ol>
</li>
<li>
<p>拉链法</p>
<p>往后拉链表</p>
</li>
</ol>
</li>
<li>
<p>装填因子</p>
<p>a = 表中记录数n/散列表长度m</p>
</li>
</ol>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2018-11-19</span>
</div></div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://importmengjie.github.io/posts/data-structure/ data-title="考研807数据结构复习笔记 - 旧笔记" data-hashtags=基础知识,考研,算法与数据结构><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://importmengjie.github.io/posts/data-structure/ data-hashtag=基础知识><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://importmengjie.github.io/posts/data-structure/ data-title="考研807数据结构复习笔记 - 旧笔记"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://importmengjie.github.io/posts/data-structure/ data-title="考研807数据结构复习笔记 - 旧笔记"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://importmengjie.github.io/posts/data-structure/ data-title="考研807数据结构复习笔记 - 旧笔记"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>基础知识</a>,&nbsp;<a href=/tags/%E8%80%83%E7%A0%94/>考研</a>,&nbsp;<a href=/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>算法与数据结构</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/python_study_notes/ class=prev rel=prev title="Python学习笔记 - 旧笔记"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Python学习笔记 - 旧笔记</a>
<a href=/posts/operating-system/ class=next rel=next title="考研807操作系统复习笔记 - 旧笔记">考研807操作系统复习笔记 - 旧笔记<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div>
</div>
<div id=comments><div id=giscus class=comment></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://giscus.app>Giscus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.91.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a>
</div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>mengjie</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<section>
<span id=busuanzi_container_value_site_pv><i class="far fa-eye fa-fw"></i>
<span id=busuanzi_value_site_pv></span>
</span>
&nbsp;|&nbsp;
<span id=busuanzi_container_value_site_uv><i class="fa fa-user"></i>
<span id=busuanzi_value_site_uv></span>
</span>
</section>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw" aria-hidden=true></i>
</a>
</div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{category:"Announcements",categoryId:"DIC_kwDOBojUS84CZfEa",darkTheme:"dark",emitMetadata:"0",inputPosition:"bottom",lang:"en",lazyLoading:!1,lightTheme:"light",mapping:"pathname",reactionsEnabled:"1",repo:"ImportMengjie/importmengjie.github.io",repoId:"MDEwOlJlcG9zaXRvcnkxMDk2MzA1Mzk="}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:50}}</script><script type=text/javascript src=/js/theme.min.485ce22971162ae594e2f22468d97519fb9c08a7112e3a012e8684cfe098b474.js integrity="sha256-SFziKXEWKuWU4vIkaNl1GfucCKcRLjoBLoaEz+CYtHQ="></script></body>
</html>