[{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":"本文是在阅读《Linux/UNIX系统编程手册》1结合《Linux多线程服务端编程：使用muduo C++网络库》2、《现代C++语言核心特性解析》3等书，对线程有一次系统的学习和记录。包括系统提供的线程相关Pthread API以及它们在C++中相关封装的介绍。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:0:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程概念创建线程比创建进程通常要快10倍甚至更多，因为调用fork()创建子进程时所需复制诸多属性，而线程间是共享的，不需要复制，特别是无需采用写时复制内存页，也无需复制页表。具体来讲线程共享有如下内容(并不不全面): 进程ID、父进程ID、进程组ID、会话ID、控制终端。具体作用参考进程相关文章中的介绍。 打开的文件描述符。 信号的处置函数设置。具体参考信号文章中的介绍。 文件系统相关信息: 文件权限掩码、当前工作目录和根目录。 CPU时间消耗(由times()返回)、资源消耗(由getrusage()返回)、nice值(通过setpriority()和nice()设置)。 各线程有独有的一些属性，如下列出其中一部分。 Pthread线程ID、Linux线程ID。在下文章节中介绍。 信号掩码(signal mask)，用于阻塞某些信号传递。参考信号相关的文章。 备选信号栈(sigaltstack())。 errno变量和一些用户设置的线程特有数据(thread_local)。 CPU亲和力(affinity)、实时调度策略(real-time scheduling policy)和优先级。 同一个进程中的所有线程共享虚拟内存空间和一些资源如打开文件等。每个线程有自己的栈空间，通常是线程库通过mmap()向操作系统申请，多线程的内存空间布局如下图。 同时执行4个线程的进程内存空间布局 tip 既然线程共享虚拟内存空间，当然利用合适的指针各个线程都可以访问对方栈中的数据，不过栈上的数据生命周期一般比较短暂，通常不会这样使用。 对于多线程的堆空间为了减少分配和释放时的数据竞争也可能不是同一个mmap分配块，参考记一次数据竞争导致内存损坏的coredump - 问题诊断文章中所写的堆内存管理部分。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程概念"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthreads API20世纪80年代末、90年代初，存在着数种不同的线程接口。1995年POSIX.1c对POSIX线程API进行了标准化，该标准后来为SUSv3所接纳。 线程数据类型(Pthreads data type)Pthreads API定义了一干数据类型，但标准并未规定如何实现这些数据类型，所以程序应避免对此类数据类型的变量结构或内容产生任依赖。例如不能使用比较操作符(==)去比较这些类型的变量，对于线程ID的类型pthread_t应该使用函数pthread_equal()来比较两个线程ID是否相同。如下表列出了其中的一部分。 数据类型 描述 pthread_t 线程 ID pthread_mutex_t 互斥对象(Mutex) pthread_mutexattr_t 互斥属性对象 pthread_cond_t 条件变量(condition variable) pthread_condattr_t 条件变量的属性对象 pthread_key_t 线程特有数据的键(Key) pthread_once_t 一次性初始化控制上下文(control context) pthread_attr_t 线程的属性对象 Pthreads函数返回值系统调用的返回值一般是: 返回0表示成功，返回-1表示失败，并设置errno来标识错误原因。Pthread API却以返回0表示成功，返回正值表示失败，并且该正值和传统UNIX系统调用置于errno中的值含义相同。 应该来说Pthreads返回错误的方式相比于系统调用来说更加的简洁，另外在多线程中errno被设置成线程特有数据来保证多线程环境中的正确性。 tip 最初的 POSIX.1 标准沿袭 K\u0026R 的 C 语言用法，允许程序将 errno 声明为 extern int errno。 SUSv3 却不允许这一做法(这一变化实际发生于 1995 年的 POSIX.1c 标准之中)。如今，需要声明 errno 的程序必须包含\u003cerrno.h\u003e，以启用对 errno 的线程级实现。 多线程程序编译参数在Linux平台上，编译多线程程序需要链接libpthread.so。一般不推荐直接使用编译参数-lpthread进行链接，而是推荐使用编译器参数-pthread。因为-pthread有如下的效果: 定义_REENTRANT宏: 有些标准库在定义该宏会使用线程安全的版本，并且还可能影响编译器优化选项，使其生成更适合多线程环境的程序。 链接libpthread库。 故编译多线程程序应当使用-pthread编译参数而不是-lpthread。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#pthreads-api"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthreads API20世纪80年代末、90年代初，存在着数种不同的线程接口。1995年POSIX.1c对POSIX线程API进行了标准化，该标准后来为SUSv3所接纳。 线程数据类型(Pthreads data type)Pthreads API定义了一干数据类型，但标准并未规定如何实现这些数据类型，所以程序应避免对此类数据类型的变量结构或内容产生任依赖。例如不能使用比较操作符(==)去比较这些类型的变量，对于线程ID的类型pthread_t应该使用函数pthread_equal()来比较两个线程ID是否相同。如下表列出了其中的一部分。 数据类型 描述 pthread_t 线程 ID pthread_mutex_t 互斥对象(Mutex) pthread_mutexattr_t 互斥属性对象 pthread_cond_t 条件变量(condition variable) pthread_condattr_t 条件变量的属性对象 pthread_key_t 线程特有数据的键(Key) pthread_once_t 一次性初始化控制上下文(control context) pthread_attr_t 线程的属性对象 Pthreads函数返回值系统调用的返回值一般是: 返回0表示成功，返回-1表示失败，并设置errno来标识错误原因。Pthread API却以返回0表示成功，返回正值表示失败，并且该正值和传统UNIX系统调用置于errno中的值含义相同。 应该来说Pthreads返回错误的方式相比于系统调用来说更加的简洁，另外在多线程中errno被设置成线程特有数据来保证多线程环境中的正确性。 tip 最初的 POSIX.1 标准沿袭 K\u0026R 的 C 语言用法，允许程序将 errno 声明为 extern int errno。 SUSv3 却不允许这一做法(这一变化实际发生于 1995 年的 POSIX.1c 标准之中)。如今，需要声明 errno 的程序必须包含，以启用对 errno 的线程级实现。 多线程程序编译参数在Linux平台上，编译多线程程序需要链接libpthread.so。一般不推荐直接使用编译参数-lpthread进行链接，而是推荐使用编译器参数-pthread。因为-pthread有如下的效果: 定义_REENTRANT宏: 有些标准库在定义该宏会使用线程安全的版本，并且还可能影响编译器优化选项，使其生成更适合多线程环境的程序。 链接libpthread库。 故编译多线程程序应当使用-pthread编译参数而不是-lpthread。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程数据类型pthreads-data-type"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthreads API20世纪80年代末、90年代初，存在着数种不同的线程接口。1995年POSIX.1c对POSIX线程API进行了标准化，该标准后来为SUSv3所接纳。 线程数据类型(Pthreads data type)Pthreads API定义了一干数据类型，但标准并未规定如何实现这些数据类型，所以程序应避免对此类数据类型的变量结构或内容产生任依赖。例如不能使用比较操作符(==)去比较这些类型的变量，对于线程ID的类型pthread_t应该使用函数pthread_equal()来比较两个线程ID是否相同。如下表列出了其中的一部分。 数据类型 描述 pthread_t 线程 ID pthread_mutex_t 互斥对象(Mutex) pthread_mutexattr_t 互斥属性对象 pthread_cond_t 条件变量(condition variable) pthread_condattr_t 条件变量的属性对象 pthread_key_t 线程特有数据的键(Key) pthread_once_t 一次性初始化控制上下文(control context) pthread_attr_t 线程的属性对象 Pthreads函数返回值系统调用的返回值一般是: 返回0表示成功，返回-1表示失败，并设置errno来标识错误原因。Pthread API却以返回0表示成功，返回正值表示失败，并且该正值和传统UNIX系统调用置于errno中的值含义相同。 应该来说Pthreads返回错误的方式相比于系统调用来说更加的简洁，另外在多线程中errno被设置成线程特有数据来保证多线程环境中的正确性。 tip 最初的 POSIX.1 标准沿袭 K\u0026R 的 C 语言用法，允许程序将 errno 声明为 extern int errno。 SUSv3 却不允许这一做法(这一变化实际发生于 1995 年的 POSIX.1c 标准之中)。如今，需要声明 errno 的程序必须包含，以启用对 errno 的线程级实现。 多线程程序编译参数在Linux平台上，编译多线程程序需要链接libpthread.so。一般不推荐直接使用编译参数-lpthread进行链接，而是推荐使用编译器参数-pthread。因为-pthread有如下的效果: 定义_REENTRANT宏: 有些标准库在定义该宏会使用线程安全的版本，并且还可能影响编译器优化选项，使其生成更适合多线程环境的程序。 链接libpthread库。 故编译多线程程序应当使用-pthread编译参数而不是-lpthread。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#pthreads函数返回值"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthreads API20世纪80年代末、90年代初，存在着数种不同的线程接口。1995年POSIX.1c对POSIX线程API进行了标准化，该标准后来为SUSv3所接纳。 线程数据类型(Pthreads data type)Pthreads API定义了一干数据类型，但标准并未规定如何实现这些数据类型，所以程序应避免对此类数据类型的变量结构或内容产生任依赖。例如不能使用比较操作符(==)去比较这些类型的变量，对于线程ID的类型pthread_t应该使用函数pthread_equal()来比较两个线程ID是否相同。如下表列出了其中的一部分。 数据类型 描述 pthread_t 线程 ID pthread_mutex_t 互斥对象(Mutex) pthread_mutexattr_t 互斥属性对象 pthread_cond_t 条件变量(condition variable) pthread_condattr_t 条件变量的属性对象 pthread_key_t 线程特有数据的键(Key) pthread_once_t 一次性初始化控制上下文(control context) pthread_attr_t 线程的属性对象 Pthreads函数返回值系统调用的返回值一般是: 返回0表示成功，返回-1表示失败，并设置errno来标识错误原因。Pthread API却以返回0表示成功，返回正值表示失败，并且该正值和传统UNIX系统调用置于errno中的值含义相同。 应该来说Pthreads返回错误的方式相比于系统调用来说更加的简洁，另外在多线程中errno被设置成线程特有数据来保证多线程环境中的正确性。 tip 最初的 POSIX.1 标准沿袭 K\u0026R 的 C 语言用法，允许程序将 errno 声明为 extern int errno。 SUSv3 却不允许这一做法(这一变化实际发生于 1995 年的 POSIX.1c 标准之中)。如今，需要声明 errno 的程序必须包含，以启用对 errno 的线程级实现。 多线程程序编译参数在Linux平台上，编译多线程程序需要链接libpthread.so。一般不推荐直接使用编译参数-lpthread进行链接，而是推荐使用编译器参数-pthread。因为-pthread有如下的效果: 定义_REENTRANT宏: 有些标准库在定义该宏会使用线程安全的版本，并且还可能影响编译器优化选项，使其生成更适合多线程环境的程序。 链接libpthread库。 故编译多线程程序应当使用-pthread编译参数而不是-lpthread。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#多线程程序编译参数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程创建启动程序时产生的进程只有主线程，其它线程需要使用pthread()创建。如下定义: c++ #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg); 新线程通过调用带有参数arg的函数start，即start(arg)而开始执行。参数arg类型为void*，可以为指向任意对象的指针。而start()的返回值也是void*类型，后续可以通过pthread_join()函数获取到线程的返回值。 在C++的封装的std::thread类并未提供arg参数接口，新线程执行的函数是无参数的。由于线程之前虚拟内存是共享的，所以此处的参数arg只是提供了一种方便，并不是必不可少的。 参数thread指向pthread_t类型的指针，返回创建的Pthread线程ID。标准明确指出，新线程可能在还未给thread赋值就开始执行，因此新线程一定不可直接使用调用线程的thread参数来获取自己的Pthread线程ID，而应该使用pthread_self()获取自己的线程ID。 参数attr指向pthread_attr_t类型的指针，为新线程设置一些属性，可以设置为NULL表示默认属性。可以设置线程的属性如下: 线程栈的大小和初始地址。 线程的调度策略和优先级。 线程是以detach状态还是可join状态启动。 下面的例子展示了如何创建以detach状态启动的线程属性。 c pthread_attr_t attr; pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED); pthread_attr_destroy(\u0026attr); 在《Linux多线程服务端编程》2书中提到线程的创建需要注意：不能在进入main()函数前创建线程。原因是C++保证全局对象在进入main()之前完成构造，但是并不保证构造顺序，如果在main函数前创建线程可能访问到未初始化的全局对象，所以应该在进入main()函数后再创建线程，故像std::thread就不可作为全局对象存在，因为其对象一旦创建就会启动线程。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程创建"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 终止线程以下方式会终止进程，进程被终止后其所创建的所有线程都会被终止，不管线程是否是detach状态。 任意线程调用exit()。 主线程在main()函数中执行return语句。 进程收到行为是终止程序的信号。 以下方式会终止线程,而不会影响进程中的其它线程继续执行。 线程start函数执行return语句。 线程调用pthread_exit()。即使由主线程调用，其它线程也会继续执行。 调用pthread_cancel()取消线程。后续章节将介绍。 调用pthread_exit()就如同在线程start函数中执行return，不同之处在于可在线程锁调用的任意函数中调用pthread_exit()而return只能在start函数调用才有效果。其函数声明如下: c #include \u003cpthread.h\u003e void pthread_exit(void *retval); 参数retval指定了线程的返回值，需要注意参数retval指向的数据不能再线程栈中，因为线程终止后，线程栈已经被释放。其返回值可以由另一个线程通过pthread_join()获取。 在C++封装的std::thread类中同样也没有提供线程返回值，同线程参数一样线程返回值并不是必须的，完全可以通过共享的内存空间传递返回值。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#终止线程"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthread线程ID和Linux线程ID在Linux下有线程有如下两种ID。其一为Pthread线程ID，由Pthreads库在用户空间维护。其二为Linux线程ID，由操作系统在内核空间维护。 Pthread线程IDPthread类型为pthread_t，由创建线程时pthread_create()返回给调用者或由pthread_self()来获取调用线程的Pthread线程ID。 c #include \u003cpthread.h\u003e pthread_t pthread_self(); Pthread线程ID有如下的特点: Pthread线程ID是Pthreads库在用户空间维护的线程ID。故其只在进程内有意义，无法与操作系统调度建立关联。例如在/proc文件系统中找不到pthread_t对应的task。 标准未规定pthread_t具体的底层类型，也就是无法在日志中可移植的打印Pthread线程ID，更不能使用其作为关联容器的key。 实际在Linux上的实现其为指向结构体的指针，指向一块动态分配的内存。而内存是反复使用的，也就是Pthreads只保证同一进程内、同一时刻的各个线程ID不同，不能保证同一进程先后多个线程具有不同的线程ID。 Linux线程IDLinux线程ID类型为pid_t，可以由如下系统调用获取当前的Linux线程ID。 c #include \u003cunistd.h\u003e pid_t gettid(void); Linux线程ID有如下的特点。 Linux的线程ID是操作系统在内核空间维护的线程ID。其作为操作系统内核调度的标识,可以在/proc/tid或/proc/pid/task/tid中找到对应的线程信息。 其类型为pid_t，通常为整数，方便在日志中打印。 它与进程ID、进程组ID、会话ID互相不会重复且全局唯一。并且Linux分配新的线程ID、进程组ID等采用递增轮回的方法，所以短时间内启动的多个线程会具有不同的ID。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#pthread线程id和linux线程id"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthread线程ID和Linux线程ID在Linux下有线程有如下两种ID。其一为Pthread线程ID，由Pthreads库在用户空间维护。其二为Linux线程ID，由操作系统在内核空间维护。 Pthread线程IDPthread类型为pthread_t，由创建线程时pthread_create()返回给调用者或由pthread_self()来获取调用线程的Pthread线程ID。 c #include pthread_t pthread_self(); Pthread线程ID有如下的特点: Pthread线程ID是Pthreads库在用户空间维护的线程ID。故其只在进程内有意义，无法与操作系统调度建立关联。例如在/proc文件系统中找不到pthread_t对应的task。 标准未规定pthread_t具体的底层类型，也就是无法在日志中可移植的打印Pthread线程ID，更不能使用其作为关联容器的key。 实际在Linux上的实现其为指向结构体的指针，指向一块动态分配的内存。而内存是反复使用的，也就是Pthreads只保证同一进程内、同一时刻的各个线程ID不同，不能保证同一进程先后多个线程具有不同的线程ID。 Linux线程IDLinux线程ID类型为pid_t，可以由如下系统调用获取当前的Linux线程ID。 c #include pid_t gettid(void); Linux线程ID有如下的特点。 Linux的线程ID是操作系统在内核空间维护的线程ID。其作为操作系统内核调度的标识,可以在/proc/tid或/proc/pid/task/tid中找到对应的线程信息。 其类型为pid_t，通常为整数，方便在日志中打印。 它与进程ID、进程组ID、会话ID互相不会重复且全局唯一。并且Linux分配新的线程ID、进程组ID等采用递增轮回的方法，所以短时间内启动的多个线程会具有不同的ID。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#pthread线程id"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" Pthread线程ID和Linux线程ID在Linux下有线程有如下两种ID。其一为Pthread线程ID，由Pthreads库在用户空间维护。其二为Linux线程ID，由操作系统在内核空间维护。 Pthread线程IDPthread类型为pthread_t，由创建线程时pthread_create()返回给调用者或由pthread_self()来获取调用线程的Pthread线程ID。 c #include pthread_t pthread_self(); Pthread线程ID有如下的特点: Pthread线程ID是Pthreads库在用户空间维护的线程ID。故其只在进程内有意义，无法与操作系统调度建立关联。例如在/proc文件系统中找不到pthread_t对应的task。 标准未规定pthread_t具体的底层类型，也就是无法在日志中可移植的打印Pthread线程ID，更不能使用其作为关联容器的key。 实际在Linux上的实现其为指向结构体的指针，指向一块动态分配的内存。而内存是反复使用的，也就是Pthreads只保证同一进程内、同一时刻的各个线程ID不同，不能保证同一进程先后多个线程具有不同的线程ID。 Linux线程IDLinux线程ID类型为pid_t，可以由如下系统调用获取当前的Linux线程ID。 c #include pid_t gettid(void); Linux线程ID有如下的特点。 Linux的线程ID是操作系统在内核空间维护的线程ID。其作为操作系统内核调度的标识,可以在/proc/tid或/proc/pid/task/tid中找到对应的线程信息。 其类型为pid_t，通常为整数，方便在日志中打印。 它与进程ID、进程组ID、会话ID互相不会重复且全局唯一。并且Linux分配新的线程ID、进程组ID等采用递增轮回的方法，所以短时间内启动的多个线程会具有不同的ID。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#linux线程id"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程join和detach线程的join和detach操作类似于进程的wait()子进程和忽略子进程终止信号SIGCHLD。 线程joinPthreads函数pthread_join()阻塞等待Pthread线程ID为thread的线程终止。其函数声明如下: c #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); 若参数retval为非空指针，将会保存线程终止时返回的指针。 其在使用需要注意如下几点: 如果join一个已经被join过的线程ID，将会导致未定义行为。例如，相同的线程ID在join后恰好被另一个线程重用，再度join就是对新线程的join。 如果线程未被detach则结束后必须使用join获取返回值释放资源，否则就会产生僵尸线程。其概念和僵尸进程一样，会浪费系统资源。在C++中std::thread如果在析构时未调用过join函数则会调用std::terminate()直接结束程序。 pthread_join()的功能和针对进程的wait()调用类似，但是有一些区别。 线程之间的关系是对等的，可以互相调用join。而wait()只有父进程才可以对子进程调用。 无法join任意线程，而wait()可以等待任意子进程终止。 join线程无法采用非阻塞的方式，而wait()可以设置WHOHANG标志采用非阻塞的方式。 线程detach有些情况下不关心线程的返回值，希望线程终止时自动清理。在这种情况下可以调用pthread_detach()将线程标记为分离(detach)的状态。 c #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); 其在使用时需要注意如下几点: 线程可以自行设置自己的分离状态，执行pthread_detach(pthread_self());。 一旦线程处于分离状态，就不能使用join来获取其状态，也无法恢复为可连接状态。 进程终止时，其所有线程都会被终止，不管线程是否在分离状态。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:5","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程join和detach"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程join和detach线程的join和detach操作类似于进程的wait()子进程和忽略子进程终止信号SIGCHLD。 线程joinPthreads函数pthread_join()阻塞等待Pthread线程ID为thread的线程终止。其函数声明如下: c #include int pthread_join(pthread_t thread, void **retval); 若参数retval为非空指针，将会保存线程终止时返回的指针。 其在使用需要注意如下几点: 如果join一个已经被join过的线程ID，将会导致未定义行为。例如，相同的线程ID在join后恰好被另一个线程重用，再度join就是对新线程的join。 如果线程未被detach则结束后必须使用join获取返回值释放资源，否则就会产生僵尸线程。其概念和僵尸进程一样，会浪费系统资源。在C++中std::thread如果在析构时未调用过join函数则会调用std::terminate()直接结束程序。 pthread_join()的功能和针对进程的wait()调用类似，但是有一些区别。 线程之间的关系是对等的，可以互相调用join。而wait()只有父进程才可以对子进程调用。 无法join任意线程，而wait()可以等待任意子进程终止。 join线程无法采用非阻塞的方式，而wait()可以设置WHOHANG标志采用非阻塞的方式。 线程detach有些情况下不关心线程的返回值，希望线程终止时自动清理。在这种情况下可以调用pthread_detach()将线程标记为分离(detach)的状态。 c #include int pthread_detach(pthread_t thread); 其在使用时需要注意如下几点: 线程可以自行设置自己的分离状态，执行pthread_detach(pthread_self());。 一旦线程处于分离状态，就不能使用join来获取其状态，也无法恢复为可连接状态。 进程终止时，其所有线程都会被终止，不管线程是否在分离状态。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:5","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程join"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程join和detach线程的join和detach操作类似于进程的wait()子进程和忽略子进程终止信号SIGCHLD。 线程joinPthreads函数pthread_join()阻塞等待Pthread线程ID为thread的线程终止。其函数声明如下: c #include int pthread_join(pthread_t thread, void **retval); 若参数retval为非空指针，将会保存线程终止时返回的指针。 其在使用需要注意如下几点: 如果join一个已经被join过的线程ID，将会导致未定义行为。例如，相同的线程ID在join后恰好被另一个线程重用，再度join就是对新线程的join。 如果线程未被detach则结束后必须使用join获取返回值释放资源，否则就会产生僵尸线程。其概念和僵尸进程一样，会浪费系统资源。在C++中std::thread如果在析构时未调用过join函数则会调用std::terminate()直接结束程序。 pthread_join()的功能和针对进程的wait()调用类似，但是有一些区别。 线程之间的关系是对等的，可以互相调用join。而wait()只有父进程才可以对子进程调用。 无法join任意线程，而wait()可以等待任意子进程终止。 join线程无法采用非阻塞的方式，而wait()可以设置WHOHANG标志采用非阻塞的方式。 线程detach有些情况下不关心线程的返回值，希望线程终止时自动清理。在这种情况下可以调用pthread_detach()将线程标记为分离(detach)的状态。 c #include int pthread_detach(pthread_t thread); 其在使用时需要注意如下几点: 线程可以自行设置自己的分离状态，执行pthread_detach(pthread_self());。 一旦线程处于分离状态，就不能使用join来获取其状态，也无法恢复为可连接状态。 进程终止时，其所有线程都会被终止，不管线程是否在分离状态。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:1:5","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程detach"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程同步线程的优势在于同一进程下的所有线程共享虚拟内存空间，可以很方便的共享信息。不过，方便是有代价的需要使用同步手段避免竞态条件(race condition)。只要有一个线程修改多线程共享的变量，对该变量的读写都需要加锁。术语临界区(critical section)指访问某一个共享资源的代码片段，并且该代码的执行应为原子操作。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程同步"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 互斥量(mutex)互斥量(mutex)是最简单的同步手段，简单说保护临界区任何时刻至多一个线程在mutex划分的临界区执行。 互斥量初始化动态初始化和释放互斥量需要调用如下函数。 c #include \u003cpthread.h\u003e int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); 参数mutex为初始化操作的目标互斥量变量的指针，可以是栈上自动变量或分配与堆上的变量。 参数attr是指向pthread_mutexattr_t类型的指针，用于定义互斥量的属性，其有如下几种type。 PTHREAD_MUTEX_NORMAL: 如果线程试图对本线程已加锁的互斥量加锁，就会发生死锁。不具有死锁自检功能。 PTHREAD_MUTEX_ERRORCHECK: 对互斥量的所有操作都会执行错误检查。会影响性能一般作为调试手段。 PTHREAD_MUTEX_RECURSIVE: 即递归锁，内部有锁计数器，同一个线程可以多次加锁使得锁计数器递增，解锁使得锁计数器递减直到为0时释放该锁。 PTHREAD_MUTEX_DEFAULT: 默认属性，attr为NULL时默认创建的类型。标准并定义具体的类型，保留最大的灵活性。在Linux，其行为和PTHREAD_MUTEX_NORMAL一样。 属性的使用例子如下。 c pthread_mutex_t mutex; pthread_mutexattr_t attr; pthread_mutexattr_init(\u0026attr); // 设置递归锁属性 pthread_mutexattr_settype(\u0026attr, PTHREAD_MUTEX_RECURSIVE); // 使用带有递归属性的属性对象初始化互斥锁 pthread_mutex_init(\u0026mutex, \u0026attr); pthread_mutexattr_destroy(\u0026attr); 属性还支持其它一些设置，例如设置互斥量的作用域为进程间pthread_mutexattr_setpshared(\u0026attr, PTHREAD_PROCESS_SHARED)，可以通过共享内存共享互斥锁进程间使用。还有一些设置优先级等的设置项，可以参考这篇文章。 同时，互斥量还支持静态初始化，使用方法如下。 c pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 其不可使用pthread_mutex_destroy销毁。Linux还提供了非标准的静态初始值，如递归锁(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)，不过为了可移植性不应使用这些初始值。 tip 标准规定，互斥量本身不可被复制。在C++中std::mutex不可复制并且也不支持移动语义。不可以移动的原因我认为是移动语义是一个对象把所有权转给另一个对象，而失去所有权的对象本身还可以继续使用，所以必须能表示失去所有权的std::mutex，那么每次调用std::mutex相关函数时就需要判断对象是否拥有所有权，这比较麻烦所以干脆不支持移动语义即可。 由于std::mutex不可移动和复制，含有std::mutex的对象也不能放入容器中，如果需要的话只能放入std::mutex的指针。 加锁解锁互斥量初始化后，互斥量处于未锁定状态。函数pthread_mutex_lock可以锁定某个互斥量，函数pthread_mutex_unlock可以解锁某个互斥量。 c #include \u003cpthread.h\u003e int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 需要注意: 函数pthread_mutex_unlock解锁之前已遭调用线程锁定的互斥量。不可对未处于锁定或被其他线程锁定的互斥量解锁。 另外Pthreads库还提供如下两个加锁函数。 pthread_mutex_trylock(): 在锁被其它线程持有时会马上返回EBUSY错误，而不是一直阻塞。 pthread_mutex_timedlock(): 可以指定一个超时的绝对时间abstime，在到达指定时间还未获取锁会返回ETIMEOUT错误。注意这里采用绝对时间，假如系统时间跳变会有影响。 在大多数经过良好设计的应用程序中，线程对互斥量的持有时间应尽可能短， 以避免妨碍其他线程的并发执行。 互斥量的实现采用了机器语言级的原子操作(在内存中执行，对所有线程可见)，只有发生锁的争用时才会执行系统调用。 Linux上，互斥量的实现采用了futex(源自“快速用户空间互斥量”[fast user space mutex]的首字母缩写)，而对锁争用的处理则使用了futex()系统调用。本书无意描述futex，其设计意图也并非供用户空间(user space)应用程序直接使用。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#互斥量mutex"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 互斥量(mutex)互斥量(mutex)是最简单的同步手段，简单说保护临界区任何时刻至多一个线程在mutex划分的临界区执行。 互斥量初始化动态初始化和释放互斥量需要调用如下函数。 c #include int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); 参数mutex为初始化操作的目标互斥量变量的指针，可以是栈上自动变量或分配与堆上的变量。 参数attr是指向pthread_mutexattr_t类型的指针，用于定义互斥量的属性，其有如下几种type。 PTHREAD_MUTEX_NORMAL: 如果线程试图对本线程已加锁的互斥量加锁，就会发生死锁。不具有死锁自检功能。 PTHREAD_MUTEX_ERRORCHECK: 对互斥量的所有操作都会执行错误检查。会影响性能一般作为调试手段。 PTHREAD_MUTEX_RECURSIVE: 即递归锁，内部有锁计数器，同一个线程可以多次加锁使得锁计数器递增，解锁使得锁计数器递减直到为0时释放该锁。 PTHREAD_MUTEX_DEFAULT: 默认属性，attr为NULL时默认创建的类型。标准并定义具体的类型，保留最大的灵活性。在Linux，其行为和PTHREAD_MUTEX_NORMAL一样。 属性的使用例子如下。 c pthread_mutex_t mutex; pthread_mutexattr_t attr; pthread_mutexattr_init(\u0026attr); // 设置递归锁属性 pthread_mutexattr_settype(\u0026attr, PTHREAD_MUTEX_RECURSIVE); // 使用带有递归属性的属性对象初始化互斥锁 pthread_mutex_init(\u0026mutex, \u0026attr); pthread_mutexattr_destroy(\u0026attr); 属性还支持其它一些设置，例如设置互斥量的作用域为进程间pthread_mutexattr_setpshared(\u0026attr, PTHREAD_PROCESS_SHARED)，可以通过共享内存共享互斥锁进程间使用。还有一些设置优先级等的设置项，可以参考这篇文章。 同时，互斥量还支持静态初始化，使用方法如下。 c pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 其不可使用pthread_mutex_destroy销毁。Linux还提供了非标准的静态初始值，如递归锁(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)，不过为了可移植性不应使用这些初始值。 tip 标准规定，互斥量本身不可被复制。在C++中std::mutex不可复制并且也不支持移动语义。不可以移动的原因我认为是移动语义是一个对象把所有权转给另一个对象，而失去所有权的对象本身还可以继续使用，所以必须能表示失去所有权的std::mutex，那么每次调用std::mutex相关函数时就需要判断对象是否拥有所有权，这比较麻烦所以干脆不支持移动语义即可。 由于std::mutex不可移动和复制，含有std::mutex的对象也不能放入容器中，如果需要的话只能放入std::mutex的指针。 加锁解锁互斥量初始化后，互斥量处于未锁定状态。函数pthread_mutex_lock可以锁定某个互斥量，函数pthread_mutex_unlock可以解锁某个互斥量。 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 需要注意: 函数pthread_mutex_unlock解锁之前已遭调用线程锁定的互斥量。不可对未处于锁定或被其他线程锁定的互斥量解锁。 另外Pthreads库还提供如下两个加锁函数。 pthread_mutex_trylock(): 在锁被其它线程持有时会马上返回EBUSY错误，而不是一直阻塞。 pthread_mutex_timedlock(): 可以指定一个超时的绝对时间abstime，在到达指定时间还未获取锁会返回ETIMEOUT错误。注意这里采用绝对时间，假如系统时间跳变会有影响。 在大多数经过良好设计的应用程序中，线程对互斥量的持有时间应尽可能短， 以避免妨碍其他线程的并发执行。 互斥量的实现采用了机器语言级的原子操作(在内存中执行，对所有线程可见)，只有发生锁的争用时才会执行系统调用。 Linux上，互斥量的实现采用了futex(源自“快速用户空间互斥量”[fast user space mutex]的首字母缩写)，而对锁争用的处理则使用了futex()系统调用。本书无意描述futex，其设计意图也并非供用户空间(user space)应用程序直接使用。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#互斥量初始化"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 互斥量(mutex)互斥量(mutex)是最简单的同步手段，简单说保护临界区任何时刻至多一个线程在mutex划分的临界区执行。 互斥量初始化动态初始化和释放互斥量需要调用如下函数。 c #include int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); 参数mutex为初始化操作的目标互斥量变量的指针，可以是栈上自动变量或分配与堆上的变量。 参数attr是指向pthread_mutexattr_t类型的指针，用于定义互斥量的属性，其有如下几种type。 PTHREAD_MUTEX_NORMAL: 如果线程试图对本线程已加锁的互斥量加锁，就会发生死锁。不具有死锁自检功能。 PTHREAD_MUTEX_ERRORCHECK: 对互斥量的所有操作都会执行错误检查。会影响性能一般作为调试手段。 PTHREAD_MUTEX_RECURSIVE: 即递归锁，内部有锁计数器，同一个线程可以多次加锁使得锁计数器递增，解锁使得锁计数器递减直到为0时释放该锁。 PTHREAD_MUTEX_DEFAULT: 默认属性，attr为NULL时默认创建的类型。标准并定义具体的类型，保留最大的灵活性。在Linux，其行为和PTHREAD_MUTEX_NORMAL一样。 属性的使用例子如下。 c pthread_mutex_t mutex; pthread_mutexattr_t attr; pthread_mutexattr_init(\u0026attr); // 设置递归锁属性 pthread_mutexattr_settype(\u0026attr, PTHREAD_MUTEX_RECURSIVE); // 使用带有递归属性的属性对象初始化互斥锁 pthread_mutex_init(\u0026mutex, \u0026attr); pthread_mutexattr_destroy(\u0026attr); 属性还支持其它一些设置，例如设置互斥量的作用域为进程间pthread_mutexattr_setpshared(\u0026attr, PTHREAD_PROCESS_SHARED)，可以通过共享内存共享互斥锁进程间使用。还有一些设置优先级等的设置项，可以参考这篇文章。 同时，互斥量还支持静态初始化，使用方法如下。 c pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 其不可使用pthread_mutex_destroy销毁。Linux还提供了非标准的静态初始值，如递归锁(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)，不过为了可移植性不应使用这些初始值。 tip 标准规定，互斥量本身不可被复制。在C++中std::mutex不可复制并且也不支持移动语义。不可以移动的原因我认为是移动语义是一个对象把所有权转给另一个对象，而失去所有权的对象本身还可以继续使用，所以必须能表示失去所有权的std::mutex，那么每次调用std::mutex相关函数时就需要判断对象是否拥有所有权，这比较麻烦所以干脆不支持移动语义即可。 由于std::mutex不可移动和复制，含有std::mutex的对象也不能放入容器中，如果需要的话只能放入std::mutex的指针。 加锁解锁互斥量初始化后，互斥量处于未锁定状态。函数pthread_mutex_lock可以锁定某个互斥量，函数pthread_mutex_unlock可以解锁某个互斥量。 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 需要注意: 函数pthread_mutex_unlock解锁之前已遭调用线程锁定的互斥量。不可对未处于锁定或被其他线程锁定的互斥量解锁。 另外Pthreads库还提供如下两个加锁函数。 pthread_mutex_trylock(): 在锁被其它线程持有时会马上返回EBUSY错误，而不是一直阻塞。 pthread_mutex_timedlock(): 可以指定一个超时的绝对时间abstime，在到达指定时间还未获取锁会返回ETIMEOUT错误。注意这里采用绝对时间，假如系统时间跳变会有影响。 在大多数经过良好设计的应用程序中，线程对互斥量的持有时间应尽可能短， 以避免妨碍其他线程的并发执行。 互斥量的实现采用了机器语言级的原子操作(在内存中执行，对所有线程可见)，只有发生锁的争用时才会执行系统调用。 Linux上，互斥量的实现采用了futex(源自“快速用户空间互斥量”[fast user space mutex]的首字母缩写)，而对锁争用的处理则使用了futex()系统调用。本书无意描述futex，其设计意图也并非供用户空间(user space)应用程序直接使用。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#加锁解锁互斥量"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 条件变量(condition variable)条件变量允许一个线程休眠去等待直至另一个线程通知去执行某些操作。其作用是当共享变量的状态改变发出通知其它线程，共享变量的状态需要使用互斥量保护，所以条件变量必须结合互斥量使用。 条件变量初始化类似互斥量，条件变量也分为动态初始化和静态初始化。其中动态初始化和释放的函数声明如下。 c #include \u003cpthread.h\u003e int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr); int pthread_cond_destroy(pthread_cond_t *cond); 其中，参数cond为初始化的cond变量指针。参数attr为条件变量的属性，目前只支持是否设置进程共享pthread_condattr_setpshared()。 同样也支持静态初始化，如下例子。 c pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 条件变量操作函数pthread_cond_wait()将阻塞线程等待收到cond条件变量的通知，函数pthread_cond_signal()和pthread_cond_broadcast()针对参数cond所指定的条件变量发送唤醒通知。 c #include \u003cpthread.h\u003e int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); 函数pthread_cond_wait()会进行如下几个操作。 释放传入的mutex和进入线程休眠等待。两个操作是原子的。 当别的线程对cond条件变量唤醒通知，该线程就被唤醒获取mutex锁，拿到锁后函数返回。 也就是说函数调用前和返回后都会持有mutex锁。对于pthread_cond_wait()函数需要注意如下。 必须配合mutex一起使用，共享变量的状态要用mutex保护。并且在其调用期间必须指定同一个互斥量，多线程对同一条件变量调用wait()时若使用多个互斥量则会导致未定义的行为。 在mutex已经上锁的情况下才能调用wait函数。并且上锁后需要先检查条件是否满足，不满足才能调用wait函数。 共享变量的状态判断和wait()函数必须放入while循环中。因为wait()返回后不能对共享变量的状态做任何假设，原因如下: 共享变量的状态在wait()返回时可能已经被其它线程修改。 可能会发生虚假唤醒的情况。在一些多处理器系统上，为了确保高效的实现，即使没有其他线程对该条件变量发送信号，等待此条件变量的线程仍然有可能醒来。标准对此明确认可。 tip 函数pthread_cond_timedwait()支持传入参数abstime来指定线程等待条件变量通知时休眠时间的上限，如果超时则返回ETIMEOUT错误。该时间默认为系统绝对时间，也就是会被系统时间跳变所影响。 可以使用pthread_condattr_setclock(\u0026attr, CLOCK_MONOTONIC);创建条件变量时修改绝对时间为相对的递增时间，可以避免系统时间跳变的影响。 不过对于像C++提供的条件变量封装std::condition_variable的wait函数同时支持绝对时间和相对时间的时间参数，但Pthreads库的条件变量只能在创建时指定时间类型。所以在glibc 2.30中又增加了pthread_cond_clockwait函数，可以在调用时指定等待的时间类型，从而解决这个问题。后续的C++的std::condition_variable实现应该要使用该函数。 函数pthread_cond_signal()和pthread_cond_broadcast()区别在于pthread_cond_signal()只保证至少一个wait()的线程被唤醒，而pthread_cond_broadcast()则会唤醒所有遭阻塞的线程。使用pthread_cond_broadcast()应总能产生正确结果，因为所有wait()线程都要能处理多余和虚假的唤醒。而pthread_cond_signal()更为高效。 对于signal()和broadcast()两个函数，需要注意一下。 调用前应该在锁的保护下修改共享变量的状态。 signal()和broadcast()两个函数本身是线程安全的，不需要在锁的保护下调用。故先解锁互斥量再通知条件变量效率会更高，减少临界区的大小，并且其它线程被唤醒时，互斥量已经解锁，可以直接加锁而不是再次休眠等待互斥量。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#条件变量condition-variable"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 条件变量(condition variable)条件变量允许一个线程休眠去等待直至另一个线程通知去执行某些操作。其作用是当共享变量的状态改变发出通知其它线程，共享变量的状态需要使用互斥量保护，所以条件变量必须结合互斥量使用。 条件变量初始化类似互斥量，条件变量也分为动态初始化和静态初始化。其中动态初始化和释放的函数声明如下。 c #include int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr); int pthread_cond_destroy(pthread_cond_t *cond); 其中，参数cond为初始化的cond变量指针。参数attr为条件变量的属性，目前只支持是否设置进程共享pthread_condattr_setpshared()。 同样也支持静态初始化，如下例子。 c pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 条件变量操作函数pthread_cond_wait()将阻塞线程等待收到cond条件变量的通知，函数pthread_cond_signal()和pthread_cond_broadcast()针对参数cond所指定的条件变量发送唤醒通知。 c #include int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); 函数pthread_cond_wait()会进行如下几个操作。 释放传入的mutex和进入线程休眠等待。两个操作是原子的。 当别的线程对cond条件变量唤醒通知，该线程就被唤醒获取mutex锁，拿到锁后函数返回。 也就是说函数调用前和返回后都会持有mutex锁。对于pthread_cond_wait()函数需要注意如下。 必须配合mutex一起使用，共享变量的状态要用mutex保护。并且在其调用期间必须指定同一个互斥量，多线程对同一条件变量调用wait()时若使用多个互斥量则会导致未定义的行为。 在mutex已经上锁的情况下才能调用wait函数。并且上锁后需要先检查条件是否满足，不满足才能调用wait函数。 共享变量的状态判断和wait()函数必须放入while循环中。因为wait()返回后不能对共享变量的状态做任何假设，原因如下: 共享变量的状态在wait()返回时可能已经被其它线程修改。 可能会发生虚假唤醒的情况。在一些多处理器系统上，为了确保高效的实现，即使没有其他线程对该条件变量发送信号，等待此条件变量的线程仍然有可能醒来。标准对此明确认可。 tip 函数pthread_cond_timedwait()支持传入参数abstime来指定线程等待条件变量通知时休眠时间的上限，如果超时则返回ETIMEOUT错误。该时间默认为系统绝对时间，也就是会被系统时间跳变所影响。 可以使用pthread_condattr_setclock(\u0026attr, CLOCK_MONOTONIC);创建条件变量时修改绝对时间为相对的递增时间，可以避免系统时间跳变的影响。 不过对于像C++提供的条件变量封装std::condition_variable的wait函数同时支持绝对时间和相对时间的时间参数，但Pthreads库的条件变量只能在创建时指定时间类型。所以在glibc 2.30中又增加了pthread_cond_clockwait函数，可以在调用时指定等待的时间类型，从而解决这个问题。后续的C++的std::condition_variable实现应该要使用该函数。 函数pthread_cond_signal()和pthread_cond_broadcast()区别在于pthread_cond_signal()只保证至少一个wait()的线程被唤醒，而pthread_cond_broadcast()则会唤醒所有遭阻塞的线程。使用pthread_cond_broadcast()应总能产生正确结果，因为所有wait()线程都要能处理多余和虚假的唤醒。而pthread_cond_signal()更为高效。 对于signal()和broadcast()两个函数，需要注意一下。 调用前应该在锁的保护下修改共享变量的状态。 signal()和broadcast()两个函数本身是线程安全的，不需要在锁的保护下调用。故先解锁互斥量再通知条件变量效率会更高，减少临界区的大小，并且其它线程被唤醒时，互斥量已经解锁，可以直接加锁而不是再次休眠等待互斥量。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#条件变量初始化"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 条件变量(condition variable)条件变量允许一个线程休眠去等待直至另一个线程通知去执行某些操作。其作用是当共享变量的状态改变发出通知其它线程，共享变量的状态需要使用互斥量保护，所以条件变量必须结合互斥量使用。 条件变量初始化类似互斥量，条件变量也分为动态初始化和静态初始化。其中动态初始化和释放的函数声明如下。 c #include int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr); int pthread_cond_destroy(pthread_cond_t *cond); 其中，参数cond为初始化的cond变量指针。参数attr为条件变量的属性，目前只支持是否设置进程共享pthread_condattr_setpshared()。 同样也支持静态初始化，如下例子。 c pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 条件变量操作函数pthread_cond_wait()将阻塞线程等待收到cond条件变量的通知，函数pthread_cond_signal()和pthread_cond_broadcast()针对参数cond所指定的条件变量发送唤醒通知。 c #include int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); 函数pthread_cond_wait()会进行如下几个操作。 释放传入的mutex和进入线程休眠等待。两个操作是原子的。 当别的线程对cond条件变量唤醒通知，该线程就被唤醒获取mutex锁，拿到锁后函数返回。 也就是说函数调用前和返回后都会持有mutex锁。对于pthread_cond_wait()函数需要注意如下。 必须配合mutex一起使用，共享变量的状态要用mutex保护。并且在其调用期间必须指定同一个互斥量，多线程对同一条件变量调用wait()时若使用多个互斥量则会导致未定义的行为。 在mutex已经上锁的情况下才能调用wait函数。并且上锁后需要先检查条件是否满足，不满足才能调用wait函数。 共享变量的状态判断和wait()函数必须放入while循环中。因为wait()返回后不能对共享变量的状态做任何假设，原因如下: 共享变量的状态在wait()返回时可能已经被其它线程修改。 可能会发生虚假唤醒的情况。在一些多处理器系统上，为了确保高效的实现，即使没有其他线程对该条件变量发送信号，等待此条件变量的线程仍然有可能醒来。标准对此明确认可。 tip 函数pthread_cond_timedwait()支持传入参数abstime来指定线程等待条件变量通知时休眠时间的上限，如果超时则返回ETIMEOUT错误。该时间默认为系统绝对时间，也就是会被系统时间跳变所影响。 可以使用pthread_condattr_setclock(\u0026attr, CLOCK_MONOTONIC);创建条件变量时修改绝对时间为相对的递增时间，可以避免系统时间跳变的影响。 不过对于像C++提供的条件变量封装std::condition_variable的wait函数同时支持绝对时间和相对时间的时间参数，但Pthreads库的条件变量只能在创建时指定时间类型。所以在glibc 2.30中又增加了pthread_cond_clockwait函数，可以在调用时指定等待的时间类型，从而解决这个问题。后续的C++的std::condition_variable实现应该要使用该函数。 函数pthread_cond_signal()和pthread_cond_broadcast()区别在于pthread_cond_signal()只保证至少一个wait()的线程被唤醒，而pthread_cond_broadcast()则会唤醒所有遭阻塞的线程。使用pthread_cond_broadcast()应总能产生正确结果，因为所有wait()线程都要能处理多余和虚假的唤醒。而pthread_cond_signal()更为高效。 对于signal()和broadcast()两个函数，需要注意一下。 调用前应该在锁的保护下修改共享变量的状态。 signal()和broadcast()两个函数本身是线程安全的，不需要在锁的保护下调用。故先解锁互斥量再通知条件变量效率会更高，减少临界区的大小，并且其它线程被唤醒时，互斥量已经解锁，可以直接加锁而不是再次休眠等待互斥量。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#条件变量操作"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 一次初始化多线程程序有时需要初始化动作只能发生一次。可以使用pthread_once()实现一次性初始化。 c #include \u003cpthread.h\u003e int pthread_once(pthread_once_t *once_control, void (*init)(void)); 参数once_control是pthread_once_t类型的指针，指向初始化为PTHREAD_ONCE_INIT静态变量。对init函数的首次调用将修改once_control所指向的内容，以便后续调用不会再执行init。 Pthreads的早期版本不能对互斥量进行静态初始化，只能使用pthread_mutex_init()([Butenbof，1996])，这也是函数pthread_once()存在的主要原因。随着静态分配互斥量功能的问世，库函数可以使用一个经静态分配的互斥量和一个静态布尔型(Boolean)变量来实现一次性初始化。虽然如此，出于方便的考虑，函数pthread_once()得以保留。 在C++中对其封装为std::call_once()。不过C++中可以使用局部静态变量，其可以保证在控制流第一次遇到静态数据的声明语句时，变量初始化一次。并且在C++11标准中规定，初始化只会在某一线程上单独发生，在初始化完成之前，其他线程不会越过静态数据的声明而继续运行。故局部静态变量是懒加载(初始化)且是线程安全。所以一次初始化其实用处不多。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#一次初始化"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程局部存储线程局部存储指的是对象内存在线程开始时分配，线程结束时回收且每个线程都有自己的实例。GCC添加了关键字__thread编译器扩展来表明变量是线程局部存储。而C++11在标准中增加了thread_local对该特性支持。thread_local可以修饰任意类型的变量。可以类似如下使用。 c++ struct X { thread_local static int i; }; thread_local X a; int main() { thread_local X b; } 多线程操作thread_local修饰的变量可以不用加锁，因为每个线程操作的都是自己线程的一份拷贝。 实际上，在Linux中线程局部存储是使用Pthreads的API实现。可以调佣pthread_key_create与pthread_key_delete创建和删除一个类型为pthread_key_t的键，利用这个键每个线程可以使用pthread_setspecific函数设置线程特有的内存数据，随后可以通过pthread_getspecific函数获取之前调用线程设置的内存数据。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:2:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程局部存储"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 线程取消线程取消提供了向指定线程发送一个取消请求功能，线程不是立即结束，而是在执行到被标记为取消点(cancellation point)的系统函数时线程才会结束。该功能确实是比较“鸡肋”，一个好的程序设计不应该使用。这里只进行简单介绍。 线程正常退出的方式只有一种，即自然死亡。任何从外部强行终止线程的做法和想法都是错的。佐证有：Java的Thread class把stop()、suspend()、destroy()等函数都废弃(deprecated)了，Boost.Threads根本就不提供thread::cancel()成员函数。因为强行终止线程的话（无论是自杀还是他杀），它没有机会清理资源。也没有机会释放已经持有的锁，其他线程如果再想对同一个mutex加锁，那么就会立刻死锁。因此我认为不用去研究cancellation point这种“鸡肋”概念。 函数ptthread_cancle()可以指定thread发送取消请求。线程可以通过pthread_setcancelstate()设置线程是否支持取消和pthread_setcanceltype()设置取消的类型，支持如下两种类型。 PTHREAD_CANCEL_DEFERED: 线程执行到取消点才会结束。可以用pthread_testcancel()主动设置一个取消点。 在C++中，cancellation point的实现与C语言有所不同，线程不是执行到此函数就立刻终止，而是该函数会抛出异常。这样可以有机会执行stack unwind，析构栈上对象（特别是释放持有的锁）。 PTHREAD_CANCEL_ASYNCHRONOUS: 异步取消，线程在任何点都可能被取消。有可能在线程持有某些资源时，例如锁，就被取消执行，此时就非常危险。所以支持异步取消的线程不能持有任何资源。 通过pthread_cleanup_push()可以设置在线程被取消时执行一些清理函数。 在C++20中新增了std::jthread也支持“线程取消”，其采用std::stop_token flag方式，在线程中主动获取是否被取消的flag，从而主动结束线程。相比于pthread_cancle()这种方法是合作式的而不是强制式。所以说不应该在程序中使用ptthread_cancle()方式从外部结束线程，而应当在线程内部主动结束。 ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:3:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#线程取消"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 参考 《Linux/UNIX系统编程手册》 ↩︎ 《Linux多线程服务端编程：使用muduo C++网络库》 ↩︎ ↩︎ 《现代C++语言核心特性解析》 ↩︎ ","date":"2024-09-05","objectID":"/posts/the_linux_programming_interface_thread/:4:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"线程概念、线程同步、线程取消 - 《Linux/UNIX系统编程手册》读书笔记【3】","uri":"/posts/the_linux_programming_interface_thread/#参考"},{"categories":["这都不知道","C++基础"],"content":"最近一段时间在工作中或看书遇到的一些关于C++有意思的知识记录成本文。包括i++和++i的左右值问题、无符号和有符号比较、C++正则库中 regex_match 的坑、shared_ptr 的妙用: copy-on-other-reading、协变返回类型、switch case 语句 break 的使用、将new对象初始化指针放在独立语句、std::stack为何提供pop和top两个函数而不是合二为一。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:0:0","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#"},{"categories":["这都不知道","C++基础"],"content":" 这都不知道","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:0","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#这都不知道"},{"categories":["这都不知道","C++基础"],"content":" i++和++i的左右值问题i++和++i很常用，之前的理解仅限++i前置++会先自增后进行运算；而i++后置++则会在参与运算完后才会自增。 上述理解并不透彻，在《现代C++语言核心特征解析》一书右值引用一章中，解释到二者有左右值的区别，i++是右值，因为后置++操作中编译器会先生成一份i值的临时拷贝，然后对i自增，返回临时拷贝。++i则是左值，直接对i进行递增后返回自身。如果对它们进行取地址操作，可以发现++i的取地址编译通过，而i++不可以。 c++ int i = 0; int *p = \u0026i++; // 编译失败 int *q = \u0026++i; // 编译成功 故i++在返回前就已经完成对i的自增并且返回的值是个自增前的临时拷贝。利用这一个特性可在STL中进行元素删除时防止关联容器迭代器失效。 在《C++标准库》第7.8节中举例： c++ std::map\u003cstd::string, float\u003e coll; // ... for (auto pos = coll.begin(); pos != coll.end();) { if (pos-\u003esencode == value) { coll.erase(pos++); } else { ++pos; } } 上述coll.erase(pos++)时pos++会将pos指向下一个元素，返回原值的拷贝，因此当erase()调用时，pos已经不再指向被即将移除的元素，所以就不存在迭代器失效的问题。当然在C++11之后，关联容器的erase()会返回迭代器指向其后续元素，上述方法有更简单的替代版本： c++ for (auto pos = coll.begin(); pos != coll.end();) { if (pos-\u003esencode == value) { pos = coll.erase(pos); } else { ++pos; } } 对于像vector等容器其erase()方法在C++11之前也是返回下个元素的迭代器，因为移除元素可能会导致后续所有元素迭代器失效。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:1","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#i和i的左右值问题"},{"categories":["这都不知道","C++基础"],"content":" 无符号和有符号比较当有符号和无符号进行比较时，需要特别注意编译器会隐式转换有符号数为无符号数，当有符号数为负值时转换成无符号数则是一个非常大的无符号数。即 c++ int i = -1; uint ui = 1; std::cout \u003c\u003c (i \u003c ui) \u003c\u003c std::endl; // 0 上述代码中i \u003c ui是false。所以当遇到无符号和有符号比较时，需要特别注意先对有符号数进行负值的判断。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:2","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#无符号和有符号比较"},{"categories":["这都不知道","C++基础"],"content":" C++正则库中regex_match的坑在工作的项目中使用std::regex_match正则匹配文件名，并且获取 match_results 来获取匹配结果中的值。最近一次使用 Valgrind 的 memcheck 工具检测程序内存问题发现这里报了 use after free 问题。经过 google 发现这里使用上的一个大坑。实际当时使用 std::regex_match 时我就看了一遍《C++标准库》1对应章节，很可惜其并没有明确指出这个问题，导致此次的踩坑。 在cppreference的regex_match一章中的缺陷报告指出了这个问题。考虑如下代码: c++ const regex r(R\"(meow(\\d+)\\.txt)\"); smatch m; if (regex_match(dir_iter-\u003epath().filename().string(), m, r)) { DoSomethingWith(m[1]); } 上述问题就在于dir_iter-\u003epath().filename().string()返回的是临时的string右值变量，而保存匹配结果的match_results(smatch)设计上为了节省内存是引用传入的string变量，这种情况下就会引用了已经释放的string。 std::regex_match函数的第一个入参类型为const std::string可以绑定右值，所以上述代码可以编译通过。而在后续的C++标准中通过显示删除右值引用参数来让上述代码编译报错，从而避免这类问题。关于右值引用，可以看这篇文章。 所以，对于regex_match或regex_search传入的被匹配字符串数据的生命周期要长于匹配结果match_results，否则就会使用到已经被释放的内存。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:3","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#c正则库中regex_match的坑"},{"categories":["这都不知道","C++基础"],"content":" shared_ptr的妙用: copy-on-write多次阅读《Linux多线程服务端编程：使用muduo C++网络库》2，每次都能被书中提到的用shared_ptr实现copy-on-write的用法所惊艳到。一部分原因是该方法确实惊艳，另一部分原因也是本人记性较差，所以这次记录下来供日后翻阅。 在实际工作中我曾经写出类似如下代码: 对于拷贝复杂度比较高的多线程共享数据data，读数据getData函数加锁返回一份拷贝来保证线程安全，写数据时加锁修改数据。这里通过使用移动语义减少了拷贝，也最大限度减少了临界区的大小。 c++ class Data { private: std::mutex mutex_; std::vector\u003cint\u003e data_; public: std::vector\u003cint\u003e getData() { std::lock_guard\u003cstd::mutex\u003e guard(mutex_); return data_; } void addDataItem(int v) { std::lock_guard\u003cstd::mutex\u003e guard(mutex_); data_.push_back(v); } void setData(std::vector\u003cint\u003e\u0026\u0026 data) { // 右值直接move std::lock_guard\u003cstd::mutex\u003e guard(mutex_); data_ = std::move(data); } void setData(const std::vector\u003cint\u003e\u0026 data) { // 左值先copy后move auto tmp = data; // copy放在临界区外 setData(std::move(tmp)); } }; 上述代码主要问题在于每次读时会拷贝数据，在拷贝消耗大或者读多写少时可能就会成为性能瓶颈。通过这本书2的启发，上述代码可以改写为: c++ class Data { private: std::mutex mutex_; std::shared_ptr\u003cstd::vector\u003cint\u003e\u003e data_; public: Data() : data_(new std::vector\u003cint\u003e()) {} std::shared_ptr\u003cconst std::vector\u003cint\u003e\u003e getData() { // 注意这里返回的是拥有const类型的shared_ptr std::lock_guard\u003cstd::mutex\u003e guard(mutex_); // 返回shared_ptr的拷贝，引用计数器+1 return data_; } void addDataItem(int v) { std::lock_guard\u003cstd::mutex\u003e guard(mutex_); // 在有读时才copy if (!data_.unique()) data_.reset(new std::vector\u003cint\u003e(*data_)); data_-\u003epush_back(v); assert(data_.unique()); } void setData(std::vector\u003cint\u003e\u0026\u0026 data) { // 右值直接move std::lock_guard\u003cstd::mutex\u003e guard(mutex_); if (!data_.unique()) data_.reset(new std::vector\u003cint\u003e(std::move(data))); // 外界有data_的拷贝，需要reset else *data_ = std::move(data); assert(data_.unique()); } void setData(const std::vector\u003cint\u003e\u0026 data) { // 左值先copy后move auto tmp = data; // copy放在临界区外 setData(std::move(tmp)); } }; 上述代码有几个关键点需要注意: 在读数据(getData)时返回shared_ptr的一份拷贝使其引用计数器+1，而并没有真正的拷贝数据，避免了读时会拷贝数据。当然调用方对于其返回的shared_ptr在使用后应马上释放，在一般场景下调用方不应该一直持有获取的数据。注意这里返回的是shared_ptr持有的是const std::vector\u003cint\u003e只读数据类型，使用编译器限制防止意外修改数据。 在写数据(addDataItem)时做到了在需要拷贝时才拷贝，即当shared_ptr引用计数器大于1时(data_.unique不成立)数据正在被其它地方读，此时拷贝数据并且reset shared_ptr到新拷贝的数据上，此时相当于写时复制(copy-on-write)。而当shared_ptr的引用计数器等于1时(data_.unique成立)数据并未被其它地方读，此时可以直接原地操作不必拷贝。 对于直接替换数据的setData难免需要复制，在这个case下优势并不明显。 所以，准确说这不是copy-on-write而是copy-on-other-reading，符合C++哲学: “You don’t pay for what you don’t use”。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:4","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#shared_ptr的妙用-copy-on-write"},{"categories":["这都不知道","C++基础"],"content":" 协变返回类型偶然从微信公众号看到的C++特性————协变返回类型(Covariant Return Types)。 简单来讲就是: 允许子类重写虚函数返回值为基类指针或引用协变成子类的指针或引用。如下例子。 c++ class Base { public: virtual Base* clone() const { std::cout \u003c\u003c \"Base::clone()\" \u003c\u003c std::endl; return new Base(*this); } }; class Derived : public Base { public: // 子类协变返回类型为子类的指针 virtual Derived* clone() const override { std::cout \u003c\u003c \"Derived::clone()\" \u003c\u003c std::endl; return new Derived(*this); } }; ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:5","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#协变返回类型"},{"categories":["这都不知道","C++基础"],"content":" switch case语句break的使用写switch case语句时确实很容易漏写break，在职业生涯中也多次踩坑被自己蠢哭。这次可能是同步代码导致的一处break被“意外删除”，导致代码未按照预期执行。 所以这次给我们的项目加上了-Wimplicit-fallthrough编译参数，对未加 break 的 case 报编译警告。如果逻辑上就是需要不加break，可以使用编译器属性[[fallthrough]]消除编译器警告，例如: c++ int v = 1; switch (v) { case 1: { std::cout \u003c\u003c \"fallthrough, 1\"; [[fallthrough]]; } case 2: { std::cout \u003c\u003c \"2\"; break; } default: { std::cout \u003c\u003c \"default\"; } } ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:6","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#switch-case语句break的使用"},{"categories":["这都不知道","C++基础"],"content":" 将new对象初始化指针放在独立语句在微信文章中读到，记录下来。 对于如下的函数调用方式: c++ processWidget(std::shared_ptr(new Widget()), priority()); 可能会导致内存泄漏，编译器在产生对processWidget调用的命令前会生成如下命令，解析参数。 执行new Widget() 调用std::shared_ptr构造函数 调用priority()函数 而上述顺序编译器只保证1会先于2执行，因为2需要用到步骤1的结果。假设编译器生成的顺序为1、3、2，则在执行步骤3调用priority函数抛出异常，会导致步骤1申请的new Widget()未析构释放内存，发生内存泄漏。 解决方法就是一个单独的语句创建智能指针或是使用std::make_shared()构造shared_ptr和new对象在一个函数中执行。 c++ std::shared_ptr\u003cWidget\u003e pw(new widget); processWidget(pw, priority()); // or processWidget(std::make_shared\u003cWidget\u003e(), priority()); ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:7","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#将new对象初始化指针放在独立语句"},{"categories":["这都不知道","C++基础"],"content":" std::stack为何提供pop和top两个函数而不是合二为一在《C++并发编程实战（第2版）》3中读到，记录下来。 std::stack提供的pop函数就是单纯将一个值出栈并不返回出栈的值。所以想要”返回栈顶元素的值，并从栈上将其移除“的效果，需要首先判空，然后调用top获取栈顶元素的值，最后调用pop弹出栈顶数据。之前认为，采用这样的设计而不是pop既返回栈顶值也移除栈顶元素是为了更加灵活，在只需要移除栈顶元素而不获取栈顶元素时，不增加额外的拷贝。 其实还有更无法拒绝的原因: 当pop函数直接返回被出栈的值，有可能在已经将栈上元素移除后，返回复制元素时抛出异常，此时弹出元素已经从栈上移除，但复制不成功，导致数据丢失。 ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:1:8","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#stdstack为何提供pop和top两个函数而不是合二为一"},{"categories":["这都不知道","C++基础"],"content":" 参考 《C++标准库》 ↩︎ 《Linux多线程服务端编程：使用muduo C++网络库》 ↩︎ ↩︎ 《C++并发编程实战（第2版）》 ↩︎ ","date":"2024-08-31","objectID":"/posts/dont-even-know-that_cpp/:2:0","series":null,"tags":["C++"],"title":"一些我竟然不知道的C++相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_cpp/#参考"},{"categories":[],"content":" 友情链接 PCloud This is PCloud~💤 ISLAND golang\\neovim配置 Strike Freedom 潘少的博客、个人主页、技术分享：编程、动漫、读书、历史、随笔。 PRIN BLOG 各种技术文章 ImportMengjie 一个车端C++软件开发程序猿 ","date":"2024-08-25","objectID":"/links/:1:0","series":null,"tags":[],"title":"Links","uri":"/links/#友情链接"},{"categories":[],"content":" 交换友链欢迎交换友链哦👏🏻。 我的信息: 名称 ImportMengjie 地址 https://importmengjie.github.io/ 头像 https://importmengjie.github.io/images/avatar.jpg 简介 一个车端C++软件开发程序猿 可以在下边评论哦，请提供信息格式: text name=\"名称\" url=\"博客地址\" avatar=\"头像地址\" bio=\"简介\" ","date":"2024-08-25","objectID":"/links/:2:0","series":null,"tags":[],"title":"Links","uri":"/links/#交换友链"},{"categories":[],"content":" 简介👏🏻哈喽，是我 一个车端C++软件开发程序猿。 自封为: shell/vim/git达人、LOL大乱斗小王子、CF北二狙神。 ","date":"2024-08-25","objectID":"/about/:1:0","series":null,"tags":[],"title":"About","uri":"/about/#简介"},{"categories":[],"content":" 诗与歌","date":"2024-08-25","objectID":"/about/:2:0","series":null,"tags":[],"title":"About","uri":"/about/#诗与歌"},{"categories":[],"content":" 我的名字叫黄果树北岛 大哥 水仙斗活佛 寸铁 左小祖咒 others 回答卑鄙是卑鄙者的通行证， 高尚是高尚者的墓志铭， 看吧，在那镀金的天空中， 飘满了死者弯曲的倒影。 冰川纪过去了， 为什么到处都是冰凌？ 好望角发现了， 为什么死海里千帆相竞？ 我来到这个世界上， 只带着纸、绳索和身影， 为了在审判之前， 宣读那些被判决的声音。 告诉你吧，世界 我——不——相——信！ 纵使你脚下有一千名挑战者， 那就把我算作第一千零一名。 我不相信天是蓝的， 我不相信雷的回声， 我不相信梦是假的， 我不相信死无报应。 如果海洋注定要决堤， 就让所有的苦水都注入我心中， 如果陆地注定要上升， 就让人类重新选择生存的峰顶。 新的转机和闪闪星斗， 正在缀满没有遮拦的天空。 那是五千年的象形文字， 那是未来人们凝视的眼睛。 宣告也许最后的时刻到了 我没有留下遗嘱 只留下笔，给我的母亲 我并不是英雄 在没有英雄的年代里 我只想做一个人 宁静的地平线 分开了生者和死者的行列 我只能选择天空 决不跪在地上 以显出刽子手们的高大 好阻挡自由的风 从星星的弹孔里 将流出血红的黎明 大哥，今夜我在积水潭 湖水尽头我两手空空 今夜我不关心政治 也不关心你 大哥你今回的北邮， 觉悟了生命的充实， 领略了友情的真挚， 社会阵场上的勇将， 在轰烈的炮火中间， 别忘却身心的和睦， 奋勇呀然后休息呀， 完成你伟大的人生。 真理是众人合唱的旗子 自由是自以为是的棋子 当每个人都急于发声时 我们把双唇缝上线 知识是达人自答的卷子 道德是逼人自逼的链子 当所有人都是乌托邦的人质 请你挖掉我的眼 理想是装满欲望的筐子 信仰是飘在风中的幌子 当每个人都学会双手合十 我们用中指指着天 从世纪坛到社稷坛的港口 从建国门到复兴门的潮头 在国贸桥，撒一网金鲫，濡沫娇滴滴 在立水桥，炸一池梦游的蓝鳍 把中国鳟钓出锁真龙的井 把四合鼋甩上盘古爷的天灵 把杏花天钓临芳草地，就是知春里 把纽约砸进柳京，就是北平 最年华的豆蔻，长着最尖锐的湿疣 最白的领和袖，藏着最黑的脊梁和手 放眼神州，胖得像骨质增生的骷髅 你就是它最红的那个动脉瘘 锤子之王!镊子皇后! 用人民币砸人民的头! 哈欠之王!饱嗝儿皇后! 人民最爱吃人民的肉! 祝你好运我的朋友， 在错乱中交上好运， 向昨天的泪水挥手， 新的泪水就在前头， 但很多故事讲到最后 都不如开头， 曾经最难割舍的 最后你都不要求， 我们基本不怕黑暗， 只怕黑暗出演光明， 旅途愉快 铁石心肠的我和雨和你， 旅途愉快 铁石心肠的共鸣与无语。 那辆红卡车把一个人压成两截 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 不会跟你们说太紧张是个坏人 也不会跟你们说好时光是个好人 我的孩子正在玩儿 请不要影响他 跟你直说了吧 解释这个事儿的人才是坏人 不要再来烦我了 我是一颗黄果树，知道不？！ 我只想躺在这里睡个好觉 那辆红卡车把一个人轰轰烈烈 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 我的家不在那个松花江上 风可进，雨可进，皇上不可进 从来就没有救世主 可他是我们的大救星 我咽下一枚铁做的月亮 他们管它叫做螺丝 我咽下这工业的废水，失业的订单 那些低于机台的青春早早夭亡 我咽下奔波，咽下流离失所 咽下人行天桥，咽下长满水锈的生活 我再也咽不下了 所有我曾经咽下的现在都从喉咙汹涌而出 在祖国的领土上谱成一首 耻辱的诗 ","date":"2024-08-25","objectID":"/about/:2:1","series":null,"tags":[],"title":"About","uri":"/about/#我的名字叫黄果树"},{"categories":[],"content":" 我的名字叫黄果树北岛 大哥 水仙斗活佛 寸铁 左小祖咒 others 回答卑鄙是卑鄙者的通行证， 高尚是高尚者的墓志铭， 看吧，在那镀金的天空中， 飘满了死者弯曲的倒影。 冰川纪过去了， 为什么到处都是冰凌？ 好望角发现了， 为什么死海里千帆相竞？ 我来到这个世界上， 只带着纸、绳索和身影， 为了在审判之前， 宣读那些被判决的声音。 告诉你吧，世界 我——不——相——信！ 纵使你脚下有一千名挑战者， 那就把我算作第一千零一名。 我不相信天是蓝的， 我不相信雷的回声， 我不相信梦是假的， 我不相信死无报应。 如果海洋注定要决堤， 就让所有的苦水都注入我心中， 如果陆地注定要上升， 就让人类重新选择生存的峰顶。 新的转机和闪闪星斗， 正在缀满没有遮拦的天空。 那是五千年的象形文字， 那是未来人们凝视的眼睛。 宣告也许最后的时刻到了 我没有留下遗嘱 只留下笔，给我的母亲 我并不是英雄 在没有英雄的年代里 我只想做一个人 宁静的地平线 分开了生者和死者的行列 我只能选择天空 决不跪在地上 以显出刽子手们的高大 好阻挡自由的风 从星星的弹孔里 将流出血红的黎明 大哥，今夜我在积水潭 湖水尽头我两手空空 今夜我不关心政治 也不关心你 大哥你今回的北邮， 觉悟了生命的充实， 领略了友情的真挚， 社会阵场上的勇将， 在轰烈的炮火中间， 别忘却身心的和睦， 奋勇呀然后休息呀， 完成你伟大的人生。 真理是众人合唱的旗子 自由是自以为是的棋子 当每个人都急于发声时 我们把双唇缝上线 知识是达人自答的卷子 道德是逼人自逼的链子 当所有人都是乌托邦的人质 请你挖掉我的眼 理想是装满欲望的筐子 信仰是飘在风中的幌子 当每个人都学会双手合十 我们用中指指着天 从世纪坛到社稷坛的港口 从建国门到复兴门的潮头 在国贸桥，撒一网金鲫，濡沫娇滴滴 在立水桥，炸一池梦游的蓝鳍 把中国鳟钓出锁真龙的井 把四合鼋甩上盘古爷的天灵 把杏花天钓临芳草地，就是知春里 把纽约砸进柳京，就是北平 最年华的豆蔻，长着最尖锐的湿疣 最白的领和袖，藏着最黑的脊梁和手 放眼神州，胖得像骨质增生的骷髅 你就是它最红的那个动脉瘘 锤子之王!镊子皇后! 用人民币砸人民的头! 哈欠之王!饱嗝儿皇后! 人民最爱吃人民的肉! 祝你好运我的朋友， 在错乱中交上好运， 向昨天的泪水挥手， 新的泪水就在前头， 但很多故事讲到最后 都不如开头， 曾经最难割舍的 最后你都不要求， 我们基本不怕黑暗， 只怕黑暗出演光明， 旅途愉快 铁石心肠的我和雨和你， 旅途愉快 铁石心肠的共鸣与无语。 那辆红卡车把一个人压成两截 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 不会跟你们说太紧张是个坏人 也不会跟你们说好时光是个好人 我的孩子正在玩儿 请不要影响他 跟你直说了吧 解释这个事儿的人才是坏人 不要再来烦我了 我是一颗黄果树，知道不？！ 我只想躺在这里睡个好觉 那辆红卡车把一个人轰轰烈烈 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 我的家不在那个松花江上 风可进，雨可进，皇上不可进 从来就没有救世主 可他是我们的大救星 我咽下一枚铁做的月亮 他们管它叫做螺丝 我咽下这工业的废水，失业的订单 那些低于机台的青春早早夭亡 我咽下奔波，咽下流离失所 咽下人行天桥，咽下长满水锈的生活 我再也咽不下了 所有我曾经咽下的现在都从喉咙汹涌而出 在祖国的领土上谱成一首 耻辱的诗 ","date":"2024-08-25","objectID":"/about/:2:1","series":null,"tags":[],"title":"About","uri":"/about/#回答"},{"categories":[],"content":" 我的名字叫黄果树北岛 大哥 水仙斗活佛 寸铁 左小祖咒 others 回答卑鄙是卑鄙者的通行证， 高尚是高尚者的墓志铭， 看吧，在那镀金的天空中， 飘满了死者弯曲的倒影。 冰川纪过去了， 为什么到处都是冰凌？ 好望角发现了， 为什么死海里千帆相竞？ 我来到这个世界上， 只带着纸、绳索和身影， 为了在审判之前， 宣读那些被判决的声音。 告诉你吧，世界 我——不——相——信！ 纵使你脚下有一千名挑战者， 那就把我算作第一千零一名。 我不相信天是蓝的， 我不相信雷的回声， 我不相信梦是假的， 我不相信死无报应。 如果海洋注定要决堤， 就让所有的苦水都注入我心中， 如果陆地注定要上升， 就让人类重新选择生存的峰顶。 新的转机和闪闪星斗， 正在缀满没有遮拦的天空。 那是五千年的象形文字， 那是未来人们凝视的眼睛。 宣告也许最后的时刻到了 我没有留下遗嘱 只留下笔，给我的母亲 我并不是英雄 在没有英雄的年代里 我只想做一个人 宁静的地平线 分开了生者和死者的行列 我只能选择天空 决不跪在地上 以显出刽子手们的高大 好阻挡自由的风 从星星的弹孔里 将流出血红的黎明 大哥，今夜我在积水潭 湖水尽头我两手空空 今夜我不关心政治 也不关心你 大哥你今回的北邮， 觉悟了生命的充实， 领略了友情的真挚， 社会阵场上的勇将， 在轰烈的炮火中间， 别忘却身心的和睦， 奋勇呀然后休息呀， 完成你伟大的人生。 真理是众人合唱的旗子 自由是自以为是的棋子 当每个人都急于发声时 我们把双唇缝上线 知识是达人自答的卷子 道德是逼人自逼的链子 当所有人都是乌托邦的人质 请你挖掉我的眼 理想是装满欲望的筐子 信仰是飘在风中的幌子 当每个人都学会双手合十 我们用中指指着天 从世纪坛到社稷坛的港口 从建国门到复兴门的潮头 在国贸桥，撒一网金鲫，濡沫娇滴滴 在立水桥，炸一池梦游的蓝鳍 把中国鳟钓出锁真龙的井 把四合鼋甩上盘古爷的天灵 把杏花天钓临芳草地，就是知春里 把纽约砸进柳京，就是北平 最年华的豆蔻，长着最尖锐的湿疣 最白的领和袖，藏着最黑的脊梁和手 放眼神州，胖得像骨质增生的骷髅 你就是它最红的那个动脉瘘 锤子之王!镊子皇后! 用人民币砸人民的头! 哈欠之王!饱嗝儿皇后! 人民最爱吃人民的肉! 祝你好运我的朋友， 在错乱中交上好运， 向昨天的泪水挥手， 新的泪水就在前头， 但很多故事讲到最后 都不如开头， 曾经最难割舍的 最后你都不要求， 我们基本不怕黑暗， 只怕黑暗出演光明， 旅途愉快 铁石心肠的我和雨和你， 旅途愉快 铁石心肠的共鸣与无语。 那辆红卡车把一个人压成两截 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 不会跟你们说太紧张是个坏人 也不会跟你们说好时光是个好人 我的孩子正在玩儿 请不要影响他 跟你直说了吧 解释这个事儿的人才是坏人 不要再来烦我了 我是一颗黄果树，知道不？！ 我只想躺在这里睡个好觉 那辆红卡车把一个人轰轰烈烈 很多人看见了 只能装作没看见 可是沉默对我来说是邪恶的帮凶 虽然我曾经逃亡 今天还想逃亡 我的家不在那个松花江上 风可进，雨可进，皇上不可进 从来就没有救世主 可他是我们的大救星 我咽下一枚铁做的月亮 他们管它叫做螺丝 我咽下这工业的废水，失业的订单 那些低于机台的青春早早夭亡 我咽下奔波，咽下流离失所 咽下人行天桥，咽下长满水锈的生活 我再也咽不下了 所有我曾经咽下的现在都从喉咙汹涌而出 在祖国的领土上谱成一首 耻辱的诗 ","date":"2024-08-25","objectID":"/about/:2:1","series":null,"tags":[],"title":"About","uri":"/about/#宣告"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#北师大的乌鸦"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#-脚印"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#-黑洞"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#-雨夜-"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#-发霉"},{"categories":[],"content":" 北师大的乌鸦①. 脚印👣 ②. 黑洞 ③. 雨夜 ☔️ ④. 发霉 ⑤. 腐烂 ①. 脚印👣年轻的灵魂在异乡 保卫着长白山 诚实的乌鸦在沙漠 挖出一条条水渠 用生命筑成土堆 沸腾的钢水刚烧开 卫星就送入了太空 意志使人们成为永动机 所以乌鸦叼走农民的口粮 饥饿的农民就变胖三圈 人们将手中的本子指向天空 太阳温暖着拳头 于是他们慵懒的击碎他人的头骨 为了宣誓拳头是太阳的拳头 当亲密的战友不再亲密 太阳也就落山了 可是星空没有出现 人们走入这夜色 用白骨砌成女神 衰老的身体囚禁在水泥当中 为了上交七十年租金 将青春交给乌鸦 过去的昨天雁过无痕 明天的未来灿烂光辉 ②. 黑洞黑夜穿透了眼睛 在我的身体里不停反射 于是我变成了黑洞 吸收着想逃逸的光 ③. 雨夜 ☔因为写诗而失眠 不是因为夜的漫长 雨淅淅沥沥敲击铁板 失眠是为了写诗 华丽的语言 巧妙的比喻 工整的对仗 好排放出无处排放的情绪 获取一波女生的目光 其实窗子里只有一个狗屁不是的人 写着狗屁不通的诗 以为自嘲能把你逗乐的样子 像个伞兵 ④. 发霉不知从何时起 我的床、椅子、桌子充满了霉味 低头看我的身体 早已斑驳成霉块 原来在这阴暗的房间里 霉菌从我的身体爬向每个地方 ⑤. 腐烂我的每一寸皮肤都变成了黑色 时不时反射着阳光 一挥手 嗡嗡的黑色寻找下一个降落点 我的每一个洞口都有密麻的白色 它们扭动着腰身 歪着头 红色的嘴寻找下一个入口 我不想这个样子被分解 虽然那个我没有感觉 但此刻的我 感受到了皮肤表面和内部的蠕动 我希望那时的我 爆成一滩水 流进下水道 在这片土地中发芽 哈喽 ","date":"2024-08-25","objectID":"/about/:2:2","series":null,"tags":[],"title":"About","uri":"/about/#-腐烂"},{"categories":["C++基础"],"content":"阅读《嵌入式C语言自我修养 - 从芯片、编译器到操作系统》1这本书时学习到了很多C语言中的有用特性，让人不禁感慨C语言也在与时俱进。这些特性在C++中也完全可以使用，学了也不白学，在工作上有用武之地。另外对于宏定义这种功能可以生成代码增加键盘寿命，相较于C++模板晦涩难懂，宏更直观。这次也一并系统的学习宏并且记录成本文。不过需要注意的是有些特性并不是C++标准直接支持而是编译器扩展支持，所以用这些特性会丧失可移植性。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:0:0","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#"},{"categories":["C++基础"],"content":" C语言标准C语言的标准发展经历了如下4个阶段。 K\u0026R C: C语言的作者Dennis M.Ritchie和Brian W.Kernighan合作的《C程序设计语言》中所定义的标准。 ANSI C: 美国国家标准协会(American National Standards Institute，ANSI)在K\u0026R C基础上统一了各大编译器厂商的不同标准，一般也叫做C89/C90标准。 C99标准: ANSI在1999年基于C89标准扩充，包括支持变量可以声明在代码块的任何地方、支持//单行注释、栈上可变长数组等。(ps: 大学老师的教授让我在很久以来都认为栈上数组的长度只能在编译期确定)。目前，很少有C语言编译器能完整支持C99，主流的GCC和Clang能支持90%以上，而微软的Visual studio 2015中只能支持70%左右2。栈上可变长数组不可定义时初始化，需要定义后手动初始化。 C11标准: ANSI在2011年基于C99标准扩充，包括支持多线程、增加gets_s()等线程安全的标准库函数等。 编译器也对C语言标准进行了扩展，例如GCC(GNU C Compiler)和Clang编译器，后边会介绍这些有用的扩展。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:1:0","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#c语言标准"},{"categories":["C++基础"],"content":" 编译器扩展特性","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:0","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#编译器扩展特性"},{"categories":["C++基础"],"content":" 语句表达式语句表达式是GNU C对C语言标准作了扩展，类似于Scala中的代码块。如下例子，可以将0~100加和的结果赋值给sum。 c++ int sum = ({ int s = 0; for (size_t i = 0; i \u003c 100; ++i) s += i; s; }); 语句表达式允许在表达式中放入代码块，表达式最终的值等于最后一个表达式的值，格式如下: c++ ({ // 任意表达式; // 表达式最终的值等于最后一个表达式的值 }) 如上，语句表达式就是一种语法糖，可以避免声明函数的麻烦和调用函数的开销，并且在其内部定义的局部变量不会“污染外部”。在一些特定的场景中，可以使代码更加优雅。它的另一个更重要的功能就是可以让宏定义方便的返回值给调用者，将在下面介绍。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:1","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#语句表达式"},{"categories":["C++基础"],"content":" 指定初始化 结构体指定初始化在GNU C可以使用指定字段名来初始化结构体，如下例子。 c++ // 顺序初始化 student t1 = student{\"mengjie\", 28}; student t2 = {\"mengjie\", 28}; student t3{\"mengjie\", 28}; std::vector\u003cstudent\u003e v1{student{\"mengjie\", 28}, {\"mengjie\", 28}, }; // 指定初始化 student t4 = student{.name = \"mengjie\", .age = 28}; student t5 = {.name = \"mengjie\", .age = 28}; student t6{.name = \"mengjie\", .age = 28}; std::vector\u003cstudent\u003e v2{student{.name = \"mengjie\", .age = 28}, {.name = \"mengjie\", .age = 28}, }; 未指定的字段将会被默认初始化。 指定初始化相较于顺序初始化对字段的初始值可以有一个更直观的表述，而不依赖与其声明顺序。在结构体调整字段顺序、增加字段等操作时，使用指定初始化将不会被影响。当然在C++中只适用于不自定义构造函数的类或结构体才可以使用指定初始化。 数组指定初始化c99标准支持的数组指定初始化，如下例子。 c // 编译器会给a[6]~a[9]默认初始化为0 int a[10] = {0, 1, 2, 3, 4, 5}; // 编译器会给索引为10和30的赋值，其它值默认初始化为0 int b[100] = { [10] = 1, [30] = 2}; GNU C还支持范围数组指定初始化，如下例子。 c // 索引范围a[10]~a[30]21个元素初始化为1, a[10]和a[20]都是包含的; a[50]~a[60]初始化为2 int c[100] = { [10 ... 30] = 1, [50 ... 60] = 2}; 并且…范围扩展不仅可以用在数组初始化，还可以用在switch-case语句中，例如。 c int i = 20; switch(i) { case 0 ... 10: { std::cout \u003c\u003c \"0 ... 10\"; break; } case 11 ... 20: { std::cout \u003c\u003c \"11 ... 20\"; break; } } 其中case 11 ... 20:就可以匹配[11, 20]之间的数，包含11和20。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:2","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#指定初始化"},{"categories":["C++基础"],"content":" 指定初始化 结构体指定初始化在GNU C可以使用指定字段名来初始化结构体，如下例子。 c++ // 顺序初始化 student t1 = student{\"mengjie\", 28}; student t2 = {\"mengjie\", 28}; student t3{\"mengjie\", 28}; std::vector v1{student{\"mengjie\", 28}, {\"mengjie\", 28}, }; // 指定初始化 student t4 = student{.name = \"mengjie\", .age = 28}; student t5 = {.name = \"mengjie\", .age = 28}; student t6{.name = \"mengjie\", .age = 28}; std::vector v2{student{.name = \"mengjie\", .age = 28}, {.name = \"mengjie\", .age = 28}, }; 未指定的字段将会被默认初始化。 指定初始化相较于顺序初始化对字段的初始值可以有一个更直观的表述，而不依赖与其声明顺序。在结构体调整字段顺序、增加字段等操作时，使用指定初始化将不会被影响。当然在C++中只适用于不自定义构造函数的类或结构体才可以使用指定初始化。 数组指定初始化c99标准支持的数组指定初始化，如下例子。 c // 编译器会给a[6]~a[9]默认初始化为0 int a[10] = {0, 1, 2, 3, 4, 5}; // 编译器会给索引为10和30的赋值，其它值默认初始化为0 int b[100] = { [10] = 1, [30] = 2}; GNU C还支持范围数组指定初始化，如下例子。 c // 索引范围a[10]~a[30]21个元素初始化为1, a[10]和a[20]都是包含的; a[50]~a[60]初始化为2 int c[100] = { [10 ... 30] = 1, [50 ... 60] = 2}; 并且…范围扩展不仅可以用在数组初始化，还可以用在switch-case语句中，例如。 c int i = 20; switch(i) { case 0 ... 10: { std::cout \u003c\u003c \"0 ... 10\"; break; } case 11 ... 20: { std::cout \u003c\u003c \"11 ... 20\"; break; } } 其中case 11 ... 20:就可以匹配[11, 20]之间的数，包含11和20。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:2","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#结构体指定初始化"},{"categories":["C++基础"],"content":" 指定初始化 结构体指定初始化在GNU C可以使用指定字段名来初始化结构体，如下例子。 c++ // 顺序初始化 student t1 = student{\"mengjie\", 28}; student t2 = {\"mengjie\", 28}; student t3{\"mengjie\", 28}; std::vector v1{student{\"mengjie\", 28}, {\"mengjie\", 28}, }; // 指定初始化 student t4 = student{.name = \"mengjie\", .age = 28}; student t5 = {.name = \"mengjie\", .age = 28}; student t6{.name = \"mengjie\", .age = 28}; std::vector v2{student{.name = \"mengjie\", .age = 28}, {.name = \"mengjie\", .age = 28}, }; 未指定的字段将会被默认初始化。 指定初始化相较于顺序初始化对字段的初始值可以有一个更直观的表述，而不依赖与其声明顺序。在结构体调整字段顺序、增加字段等操作时，使用指定初始化将不会被影响。当然在C++中只适用于不自定义构造函数的类或结构体才可以使用指定初始化。 数组指定初始化c99标准支持的数组指定初始化，如下例子。 c // 编译器会给a[6]~a[9]默认初始化为0 int a[10] = {0, 1, 2, 3, 4, 5}; // 编译器会给索引为10和30的赋值，其它值默认初始化为0 int b[100] = { [10] = 1, [30] = 2}; GNU C还支持范围数组指定初始化，如下例子。 c // 索引范围a[10]~a[30]21个元素初始化为1, a[10]和a[20]都是包含的; a[50]~a[60]初始化为2 int c[100] = { [10 ... 30] = 1, [50 ... 60] = 2}; 并且…范围扩展不仅可以用在数组初始化，还可以用在switch-case语句中，例如。 c int i = 20; switch(i) { case 0 ... 10: { std::cout \u003c\u003c \"0 ... 10\"; break; } case 11 ... 20: { std::cout \u003c\u003c \"11 ... 20\"; break; } } 其中case 11 ... 20:就可以匹配[11, 20]之间的数，包含11和20。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:2","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#数组指定初始化"},{"categories":["C++基础"],"content":" 零长数组与灵活数组零长数组是GNU C标准的扩展，顾名思义可以定义长度为0的数组，它不占用内存存储空间。其一般作为结构体的最后一个成员，从而构成一个变长的结构体。如下例子: c struct buffer { int len; char a[0]; }; int main() { buffer* buf = (buffer*)malloc(sizeof(buffer) + 10); buf-\u003elen = 10; strcpy(buf-\u003ea, \"hello\"); } 当然也可以在结构体直接放入指针，但是指针类型本身会占用内存，而不定长数组不需要额外占用内存。其实完全可以用指针+偏移量buf+sizeof(buffer)访问到buffer中多分配的内存，所以零长数组本质上也算是一种语法糖。 在C99标准中引入了灵活数组，也是干类似的事情，语法如下: c struct flexible_array{ int len; char a[]; }; 但是其相比于零长数组来说有如下限制: 灵活数组是不完整类型，不可以使用sizeof操作符操作；零长数组可以使用sizeof，并且计算结果为0. 灵活数组作为结构体成员时，结构体必须至少拥有一个命名的非空成员对象；零长数组没有该限制。 含有灵活数组的结构体不能作为另一个结构体的成员或数组的某个元素；零长数组没有该限制。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:3","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#零长数组与灵活数组"},{"categories":["C++基础"],"content":" Clang编译器对C11标准的扩展Clang编译器是LLVM项目的一个子项目，作为C、C++和Objective-C编程语言的编译器前端。其采用BSD许可证，比GCC的GPL许可证更为宽松。 Google也是从NDK 9开始大力推广LLVM Clang编译工具链。而且在NDK 11中就有官方声明，GCC编译器只升级到4.9，后续将处于维护状态，然后NDK 13版本将直接被丢弃，而只使用LLVM Clang编译工具链。再看看ARM, ARM官方的编译工具链ARM Studio 6也开始基于Clang。而像AMD则是把Clang直接用于自己的OpenCL编译器上。到了2017年，微软也将Clang集成在Visual Studio开发环境中，作为可选的C语言编译器前端，而后端仍然采用MSVC的目标代码生成器以及运行时。2 Clang也对C标准做了自己的扩展，这里介绍下几个有意思的扩展。 函数重载: 众所周知C语言并不支持函数重载，在Clang中可以使用__attribute__((overloadable))标记函数为可重载的，并且需要在每个重载函数都需要加上，否则编译器会报错。 Lambda表达式: 在Clang中支持Blocks语法来定义一个闭包Lambda函数，语法类似下例。 c void (^refBlock)(int) = ^void(int i) { printf(\"a + i = %d\\n\", a + i); }; 在书2中所讲，该特性可以捕获局部变量的引用，从而延长局部变量的生命周期。比起C++11中的Lambda表达式更加满足标准的闭包。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:2:4","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#clang编译器对c11标准的扩展"},{"categories":["C++基础"],"content":" 宏定义宏定义(macro definition)是一种预处理指令，在编译器的预处理中进行文本的替换，从而修改即将编译的源代码。其和C++模版都是属于元编程(Metaprogramming)，即编写程序来生成或操作其他程序代码，甚至操作自身代码的编程技术。我觉得其功能相较于C++模版来说更加简单容易理解，在一些场景下非它不可。 宏的基本的形式如下，其中替换列表可以省略: c #define 标识符 替换列表 换行符 #define 标识符(参数1, 参数2) 替换列表 换行符 宏定义必须写在函数外，宏的作用范围为定义处到当前文件结束，不受函数作用域等影响，因为宏的预处理部分与C源代码部分采用完全不同的文法体系，而且预处理器是独立于编译器存在的。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:0","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#宏定义"},{"categories":["C++基础"],"content":" 基本使用无参数宏的基本使用如下: c #define PI 3.14 #define PATH \"/home/\" #define DOCUMENTS_PATH PATH \"Documents/\" #define LONG_STR \\ \"There is a long string you must deal with it \\ as two line of sentence \\n\" int main() { printf(\"PI = %f\\n\", PI); printf(\"/home/\" \"Documents/\\n\"); // 替换后的这种语法是可以的 printf(DOCUMENTS_PATH \"\\n\"); printf(LONG_STR); } 上边的例子需要注意的点: 宏名被双引号括起来时不做宏替换，例如\"PI = %f\\n\"中的PI不会被替换成3.14。 宏定义允许嵌套使用，例如DOCUMENTS_PATH就使用了前面定义的PATH宏。 字符串字面量是可以拼接的，两个拼接的字符串字面量中间可以有0个或多个空格。例如\"/home/\" \"Documents/\\n\"。 宏的替换列表如果过长的话可以使用\\换行。 有参数的宏的使用注意，参考1中的例子。实现一个简单的MAX宏用于取两个数的最大值，最简单的写法如下: c #define MAX(x, y) x \u003e y ? x : y int main() { std::cout \u003c\u003c (MAX(1 != 1, 1 != 2)) \u003c\u003c std::endl; // 预期为1，实际为0 std::cout \u003c\u003c (3 + MAX(1, 2)) \u003c\u003c std::endl; // 预期为5，实际为1 } 上述简单的写法，有展开后的运算优先级问题: MAX(1 != 1, 1 != 2)展开后为1 != 1\u003e1 != 2 ? 1 != 1 : 1 != 2，其中运算法\u003e的优先级大于!=，所以运算顺序不符合预期，导致意外的结果。 3 + MAX(1, 2)展开后为3 + 1 \u003e 2 ? 1 : 2，又因为运算符+的优先级大于运算\u003e，实际变为4 \u003e 2? 1: 2不符合预期。 所以需要将参数用括号包起来，从而保证符合预期的运算优先级，如下: c #define MAX1(x, y) ((x) \u003e (y) ? (x) : (y)) 不过，上述宏定义还存在一个问题，当使用自增运算符的变量作为参数时，如MAX1(i++, ++j)就会在展开的宏中多次执行自增运算符，变量的值就改为非预期的值，这也不太能接受。所以有了如下究极体。 c++ #define MAX2(x, y) \\ ({ \\ auto\u0026\u0026 _x = x; \\ auto\u0026\u0026 _y = y; \\ (void)(\u0026_x == \u0026_y); \\ _x \u003e _y ? _x : _y; \\ }) 上述究极体MAX宏定义有如下几个需要注意的地方。 使用万能引用引用变量，从而避免自增运算符被多次执行。参考右值、右值引用、万能引用与完美转发 - C++基础中的万能引用介绍。 原书中使用的是GNU扩展关键字typeof来获取数据类型，从而拷贝x,y参数，如下: c typeof(x) _x = x; typeof(y) _y = y; 这里会造成变量的拷贝，而用万能引用的方式则不会。typeof关键字类似C++中的decltype移除引用属性的操作。 (void)(\u0026_x == \u0026_y);用来在x和y类型不同时增加编译器警告。由于运算的结果没有用到加上(void)后就可以消除编译器运算结果未使用的警告。void表示不存在的值类型，如果表达式的计算结果为void则其值和表示的标识符都会被丢弃。 使用了上述的语句表达式，最后一句_x \u003e _y ? _x : _y;为表达式最终的值。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:1","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#基本使用"},{"categories":["C++基础"],"content":" 预处理操作符#的使用宏定义替换列表中#后边跟参数名可以将实参内容以字符串字面量形式表示。例如: c #define AREA(x, y) std::cout \u003c\u003c \"x: \" \u003c\u003c #x \u003c\u003c \", y: \" #y \u003c\u003c \", area: \" \u003c\u003c x * y \u003c\u003c std::endl; int main() { AREA(3, 4) // x: 3, y: 4, area: 12 } 其中，#x和#y就被替换成字符字面量，替换是在编译器替换，不会有运行期损耗。 另外当使用宏函数时没有传入参数，则替换的参数字面量为空，例如AREA(,4)或者AREA(3,)。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:2","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#预处理操作符的使用"},{"categories":["C++基础"],"content":" 预处理操作符##的使用宏定义替换列表中##可以将前后两个预处理符号拼接在一起，##是个二元的操作，#一元的操作。##的使用例子如下: c #define A(x) a##x int A() = 0; // int a = 0; int A(1) = 1; // int a1 = 1; std::cout \u003c\u003c a \u003c\u003c \", \" \u003c\u003c a1 \u003c\u003c std::endl; 如上例子，##可以拼接两个预处理符号，并且最终的结果并不是字符字面量。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:3","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#预处理操作符的使用-1"},{"categories":["C++基础"],"content":" 宏的替换顺序宏函数的替换顺序是先处理替换列表中出现的#与##操作符，然后对替换列表中所出现的宏进行展开替换；接着检查实参是否引用了宏，如果引用了则先对所有引用了宏的实参进行完全的宏替换；最后才将替换列表中出现的形参替换为宏扩展后的实参对应的预处理符号。 如下例子，宏先进行##的替换，然后再进行替换列表的宏展开替换B1和B2。 c #define B1 1 #define B2 2 #define B(x) B##x int main() { std::cout \u003c\u003c B(1) \u003c\u003c std::endl; // 相当于引用B1 std::cout \u003c\u003c B(2) \u003c\u003c std::endl; // 相当于引用B2 } 目前对这个替换顺序的理解不太深入，感觉上在写一些复杂的宏时必须得理解这个顺序，将来需要的时候再去深入理解。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:4","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#宏的替换顺序"},{"categories":["C++基础"],"content":" do{}while和{}在写程序时对于if、else语句，在只执行一行时，一般省略括号。但是如果执行的一行是宏的话，就要非常小心了。例如: c #define LOG_LEVEL 0 #define DEBUG_LOG \\ if (LOG_LEVEL \u003e= 1) printf(\"debug!\\n\"); int main() { if (true) DEBUG_LOG else printf(\"else\"); // 展开后的if/else为 if(true) if(false) printf(\"debug!\\n\"); else printf(\"else\"); } 这样的结果肯定是不符合预期的。所以在if/else只执行一行宏语句时，一定要加上{}，否则就等着踩坑吧。 而对于写宏定义时，应当通过do{...}while(0)或{}避免这种情况。 c #define LOG_LEVEL 0 #define DEBUG_LOG1 \\ { \\ if (LOG_LEVEL \u003e= 1) printf(\"debug!\\n\"); \\ } #define DEBUG_LOG2 \\ do { \\ if (LOG_LEVEL \u003e= 1) printf(\"debug!\\n\"); \\ } while (0) int main() { if (true) DEBUG_LOG1 // {}不能加;结束 else printf(\"else\"); if (true) DEBUG_LOG2; // do while需要加;结束 else printf(\"else\"); } 如上do{...}while(0)和{}的区别在于使用宏时需要加;和不能加;分号结束符。一般加;才更符合使用习惯，所以只推荐使用do{...}while(0)的形式。 ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:5","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#dowhile和"},{"categories":["C++基础"],"content":" 可变参数宏从C99标准起，C语言的宏支持不定个数的参数，与可变参数的函数类似，例如: c #define LOG(fmt, ...) printf(fmt, __VA_ARGS__) // C99标准 #define LOG2(fmt, ...) printf(fmt, ##__VA_ARGS__) #define LOG3(fmt, myargs...) printf(fmt, ##myargs) // GNU C扩展 int main() { LOG(\"hello %s\\n\", \"world\"); // LOG(\"hello\\n\"); // 不能编译 LOG2(\"hello %s\\n\", \"world\"); LOG2(\"hello\\n\"); LOG3(\"hello %s\\n\", \"world\"); } 上述例子有如下需要注意的点。 __VA_ARGS__会将参数列表展开并且以逗号间隔，如果没有参数则为空。 在C99标准需要使用标识符__VA_ARGS__来引用可变参数列表，GNU C扩展了可以自定义名字的方式LOG3(fmt, myargs...)。 printf(fmt, __VA_ARGS__)在调用参数列表为空时，展开为printf(fmt,)多了逗号不可编译。故LOG(\"hello\\n\");不可编译。 printf(fmt, ##__VA_ARGS__)扩展了##操作符的语义，使其可以做到在列表为空时将前面的逗号删除，不为空时则使用正常的__VA_ARGS__语义以逗号为间隔进行参数列表展开。此为GNU C的扩展。 在C++ 20标准增加了__VA_OPT__宏来在列表为空时消除逗号，使用方法类似__VA_OPT__(,) __VA_ARGS__，感觉不如##操作符简洁，具体可以参考《现代C++语言核心特性解析》332.3节。 利用可变参数宏，曾经实现过函数调用前打印函数名称和其参数列表，如下: c++ #define PRINT_CALL(func, args...) \\ ({ \\ std::cout \u003c\u003c \"func: \" \u003c\u003c #func \u003c\u003c \", args: \" \u003c\u003c #args \u003c\u003c std::endl; \\ func(args); \\ }) int main() { std::cout \u003c\u003c \"test1: \" \u003c\u003c PRINT_CALL(twoSum, {2, 7, 11, 15}, 22) \u003c\u003c std::endl; std::cout \u003c\u003c \"test2: \" \u003c\u003c PRINT_CALL(twoSum, {2, 7, 11, 15}, 13) \u003c\u003c std::endl; std::cout \u003c\u003c \"test3: \" \u003c\u003c PRINT_CALL(twoSum, {2, 7, 11, 15}, 1) \u003c\u003c std::endl; } ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:3:6","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#可变参数宏"},{"categories":["C++基础"],"content":" 参考 《嵌入式C语言自我修养 - 从芯片、编译器到操作系统》 ↩︎ ↩︎ 《C语言编程魔法书 - 基于C11标准》 ↩︎ ↩︎ ↩︎ 《现代C++语言核心特性解析》 ↩︎ ","date":"2024-08-24","objectID":"/posts/cpp_base_c_feat/:4:0","series":null,"tags":["C","C++","宏"],"title":"一些C++从C语言继承的好用特性 - C++基础","uri":"/posts/cpp_base_c_feat/#参考"},{"categories":["C++基础"],"content":"右值引用是C++11标准提出的非常重要概念，正确使用可以提升执行效率。此前已经系统看过很多遍，可惜看一遍忘一遍。此次系统学习记录下来，供日后回忆。主要参考《现代C++语言核心特性解析》1和《Effective Modern C++》2。 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:0:0","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#"},{"categories":["C++基础"],"content":" 左值和右值在C语言或者早期的C++可以从字面理解，在等式左边的值为左值，等式右边的值为右值。一个变量作为左值时，表示对变量地址的引用，即可以修改变量的值；一个变量作为右值时，表示变量的内容，即可以将变量的值赋给等号左边的左值。 而在现代C++11中，对左右值进行重新定义: 左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。可以通过是否能够用取地址符\u0026来区分左值和右值。所以C语言标准中所讲的左右值和C++11标准中所讲的概念并不完全一样。 在C++11中有一些情况下左右值的判断可能会反直觉。 在另一篇文章讨论的++i和i++的左右值问题: ++i则是左值，直接对i进行递增后返回自身。如果对它们进行取地址操作，可以发现++i的取地址编译通过，而i++不可以。 c++ int i = 0; int *p = \u0026i++; // 编译失败 int *q = \u0026++i; // 编译成功 通常字面量都是右值，但是字符字面量却是左值。编译器会将字符字面量放入程序的.rodata只读数据段中，程序加载时会放入内存空间中，并且和程序有一样的生命周期，故可以用\u0026取地址，字符字面量也算左值。 c++ auto p = \u0026\"hello world\"; 右值引用其本身是左值。右值引用可以被取地址，进一步说右值引用绑定右值会延长右值的生命周期。 使用类型转换将左值转换为该类型的右值引用，该左值将会被转换成右值。如下的例子，std::move和static_cast(Type\u0026\u0026)是一样的作用。会在后边的值类别详细介绍。 c++ int a = 1; std::cout \u003c\u003c \u0026a \u003c\u003c std::endl; std::cout \u003c\u003c \u0026static_cast(int\u0026\u0026)(a) \u003c\u003c std::endl; // 编译错误，右值不能取地址 std::cout \u003c\u003c \u0026std::move(a) \u003c\u003c std::endl; // 编译错误，右值不能取地址，std::move同上作用一样 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:1:0","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#左值和右值"},{"categories":["C++基础"],"content":" 值类别左值右值的分类在C++17标准中进行了清晰的定义，如下图，引入了多种值类别。这些类别概念比较偏学术，我们只需有个简单认识: 左值(lvalue)即上述我们所讨论的左值；右值(rvlaue)也是上述讨论的右值，但其又分为两种类别: 1. 纯右值(prvalue)即通常意义我们理解的右值，如字面量、临时变量等。2. 将亡值(xvalue)的新概念，下面详细讲述。 值类别 将亡值是右值的一种类型，产生将亡值有如下两种。 使用类型转换将值转换成该类型的右值引用，将产生将亡值(右值)。即上述第4点使用std::move和static_cast(Type\u0026\u0026)可以将左值转换成将亡值即右值。 在C++17标准中引入，又称为临时量实质化，每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生。例如，如下代码。 c++ struct X { int a; }; int main() { std::cout \u003c\u003c X().a \u003c\u003c std::endl; } 由于X()是一个纯右值，访问其成员变量a需要一个泛左值，所以这里发生临时量实质化，将X()转化成将亡值，然后再访问其成员变量a。标准定义的该方式产生的将亡值，感觉是为了标准定义的统一，对于实际开发并无影响。 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:1:1","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#值类别"},{"categories":["C++基础"],"content":" 左值引用和右值引用引用是C++中引入的新概念，C语言中没有。不同于指针，它在初始化时必须绑定一个对象，绑定后也无法绑定其它对象。C++中的引用语义是对象的别名，而java等语言的引用的语义更像是指针。 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:2:0","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#左值引用和右值引用"},{"categories":["C++基础"],"content":" 左值引用左值引用只能引用左值，而常量的左值引用不仅可以引用左值，也能引用右值，并且延长右值的生命周期，比如: c++ int \u0026x = 7; // 编译失败，左值引用不能引用右值 const int \u0026y = 11; // 编译成功，常量的左值引用可以引用右值，并且延长其生命周期 声明一个函数的入参时，拷贝开销大则应该声明为常量的左值引用，比如: c++ void handle(const std::string \u0026str); std::string s{\"hello\"}; handle(s); // 绑定左值 handle(\"world\"); // 绑定右值 而对于拷贝开销小于实现引用的开销，声明函数应该使用值拷贝而不是引用，此时使用引用会造成性能的下降而不是提高，比如: c++ void handle(int str); int a = 1; handle(a); // 复制左值 handle(2); // 复制右值 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:2:1","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#左值引用"},{"categories":["C++基础"],"content":" 右值引用右值引用只能引用右值，并且可以延长右值的生命周期。相比于常量的左值引用没有常量的限制。 c++ int val = 1; int \u0026\u0026i = 1; // 编译成功，字面量1是右值 int \u0026\u0026j = val; // 编译失败，右值引用不可引用左值 int \u0026\u0026k = std::move(val); // 编译成功，std::move(val)是左值 int \u0026\u0026l = i; // 编译失败，i为右值引用是左值 结合上边的值类别讨论和右值引用，会带来非常反直觉的地方，当使用右值引用变量调用函数时，并不会选择入参类型为右值引用的重载函数，因为右值引用本身为左值而右值引用只能绑定右值。如下代码示例。 c++ void func(int \u0026\u0026x) { std::cout \u003c\u003c \"int \u0026\u0026x: \" \u003c\u003c x \u003c\u003c std::endl; } void func(int \u0026x) { std::cout \u003c\u003c \"int \u0026x: \" \u003c\u003c x \u003c\u003c std::endl; } int main() { int val = 1; int \u0026left_ref = val; int \u0026\u0026right_ref = 2; func(left_ref); // int \u0026x: 1 func(right_ref); // int \u0026x: 2 func(std::move(left_ref)); // int \u0026\u0026x: 1 func(std::move(right_ref)); // int \u0026\u0026x: 2 func(3); // int \u0026\u0026x: 3 } ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:2:2","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#右值引用"},{"categories":["C++基础"],"content":" 万能引用与完美转发","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:3:0","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#万能引用与完美转发"},{"categories":["C++基础"],"content":" 万能引用左值引用只能绑定左值，右值引用只能绑定右值，常量左值引用可以绑定左值和右值，但其常量性有一定的限制。万能引用既可以绑定左值也可以绑定右值，也可绑定含有const和volatile属性的值。 万能引用只有以下两种形式: c++ // 1. param是个万能引用 template\u003ctypename T\u003e void f(T\u0026\u0026 param); // 2. var是个万能引用 auto\u0026\u0026 var = var1; 如下都不是万能引用: c++ template\u003ctypename T\u003e void f(std::vector\u003cT\u003e\u0026\u0026 param); // param不是万能引用 template\u003ctypename T\u003e void f(const T\u0026\u0026 param); // param不是万能引用 template\u003ctypename T\u003e class X { void f(T\u0026\u0026 param); // param不是万能引用, 类型推导在类实例化时确定，而不在函数调用处实例化 } 万能引用推导下面叙述如何万能引用如何推导达到既可以绑定左值也可以绑定右值。 首先需要了解引用折叠概念，简单来讲只要有左值引用参与，最后推导结果就是左值引用类型，否则被推导成右值引用类型。下面看下参数为万能引用的f函数，传入不同的int值类型的推导过程。 当左值传递给万能引用时，模版类型T被推导成该类型的左值引用。如下，则T被推导成int\u0026类型，根据引用折叠规则，最终的参数param类型为int\u0026类型。 c++ template\u003ctypename T\u003e void f(T\u0026\u0026 param); // T被推导为int\u0026 void f(int\u0026 \u0026\u0026 param); // 根据引用折叠被最终的函数签名为void f(int\u0026 param) 同上边的反直觉地方，这里传入右值引用也会被当做左值来处理，故如下几种情况都是左值传递，推导过程如上。 c++ int val = 1; int\u0026 left_ref = val; int\u0026\u0026 right_ref = 1; f(left_ref); // 最终param的类型为左值引用 f(right_ref);// 最终param的类型为左值引用 而当右值传递给万能引用时，模版类型T被推导成该类型的非引用类型。如下，则T被推导成int类型，最终的参数param的类型为int\u0026\u0026类型，即右值引用类型。 c++ template\u003ctypename T\u003e void f(T\u0026\u0026 param); // T被推导成int void f(int\u0026\u0026 param); ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:3:1","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#万能引用"},{"categories":["C++基础"],"content":" 万能引用左值引用只能绑定左值，右值引用只能绑定右值，常量左值引用可以绑定左值和右值，但其常量性有一定的限制。万能引用既可以绑定左值也可以绑定右值，也可绑定含有const和volatile属性的值。 万能引用只有以下两种形式: c++ // 1. param是个万能引用 template void f(T\u0026\u0026 param); // 2. var是个万能引用 auto\u0026\u0026 var = var1; 如下都不是万能引用: c++ template void f(std::vector\u0026\u0026 param); // param不是万能引用 template void f(const T\u0026\u0026 param); // param不是万能引用 template class X { void f(T\u0026\u0026 param); // param不是万能引用, 类型推导在类实例化时确定，而不在函数调用处实例化 } 万能引用推导下面叙述如何万能引用如何推导达到既可以绑定左值也可以绑定右值。 首先需要了解引用折叠概念，简单来讲只要有左值引用参与，最后推导结果就是左值引用类型，否则被推导成右值引用类型。下面看下参数为万能引用的f函数，传入不同的int值类型的推导过程。 当左值传递给万能引用时，模版类型T被推导成该类型的左值引用。如下，则T被推导成int\u0026类型，根据引用折叠规则，最终的参数param类型为int\u0026类型。 c++ template void f(T\u0026\u0026 param); // T被推导为int\u0026 void f(int\u0026 \u0026\u0026 param); // 根据引用折叠被最终的函数签名为void f(int\u0026 param) 同上边的反直觉地方，这里传入右值引用也会被当做左值来处理，故如下几种情况都是左值传递，推导过程如上。 c++ int val = 1; int\u0026 left_ref = val; int\u0026\u0026 right_ref = 1; f(left_ref); // 最终param的类型为左值引用 f(right_ref);// 最终param的类型为左值引用 而当右值传递给万能引用时，模版类型T被推导成该类型的非引用类型。如下，则T被推导成int类型，最终的参数param的类型为int\u0026\u0026类型，即右值引用类型。 c++ template void f(T\u0026\u0026 param); // T被推导成int void f(int\u0026\u0026 param); ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:3:1","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#万能引用推导"},{"categories":["C++基础"],"content":" 完美转发std::move是无条件将传入的值转换成右值(将亡值)，而std::forward则根据传入的参数类型决定是否转换成右值(将亡值)，具体来讲就是右值转换成右值(将亡值)，左值转换成左值。 std::forward也是一种转换，运行期不执行任何操作。如下，std::forward如同调用static_cast\u003cT\u0026\u0026\u003e转换。 c++ template\u003ctypename T\u003e void forward_func(T\u0026\u0026 v) { func(static_cast\u003cT\u0026\u0026\u003e(v)); // 和func(std::forward\u003cT\u003e(v)); 效果一样 } static_cast\u003cT\u0026\u0026\u003e当传入的参数为左值时，T被推导为左值引用，根据引用折叠最终为static_cast\u003cT\u0026\u003e；而当传入参数为右值时，T被推导成非引用的T类型，最终为static_cast\u003cT\u0026\u0026\u003e。 ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:3:2","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#完美转发"},{"categories":["C++基础"],"content":" 参考 《现代C++语言核心特性解析》 ↩︎ 《Effective Modern C++》 ↩︎ ","date":"2024-08-11","objectID":"/posts/cpp_base_right_value/:4:0","series":null,"tags":["C++","右值引用","完美转发"],"title":"右值、右值引用、万能引用与完美转发 - C++基础","uri":"/posts/cpp_base_right_value/#参考"},{"categories":["设计模式"],"content":"设计模式是我曾经想学但没学，后来不屑于学的技术。工作中遇到项目的重构不会设计模式就显得力不从心了，此次迟来的系统学习期望能带来实际工作中可以用到的启发。主要是阅读刘伟写的《设计模式的艺术:一本实例驱动的设计模式实践指南》1这本书。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:0:0","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#"},{"categories":["设计模式"],"content":" 设计模式概述设计模式(Design Pattern)是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可以重用代码，让代码更容易被他人理解并且提高代码的可靠性。 狭义的设计模式是指GoF在《Design Patterns：Elements of Reusable Object-Oriented Software》一书中所介绍的23种经典设计模式。这23种设计模式可以分为三种。 创建型模式: 主要用于描述如何创建对象。 结构性模式: 主要用于描述如何实现类或对象的组合。 行为型模式: 主要用于描述类或对象怎样交互以及分配职责。 此外，根据某个模式是用于处理类之间的关系还是处理对象之间的关系，还可以分为类模式和对象模式。对某个设计模式可以用以上两种分类方式区分，例如单例模式是对象创建型模式，模版方法模式是类行为模式。 设计模式 模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平。模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。 by: John Vlissides的著作Pattern Hatching Design Patterns Applied（《设计模式沉思录》） ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:1:0","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#设计模式概述"},{"categories":["设计模式"],"content":" UML类图","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:0","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#uml类图"},{"categories":["设计模式"],"content":" 类的UML图示如下图，定义名为Employee类，包含成员变量name、age、email，以及方法void modifyInfo();。 类的成员变量表示格式为: 可见性 名称: 类型[ = 默认值]。 可见性: 属性的可见性，包括公有(public)表示为+，私有(private)表示为-，保护(protected)表示为#。 名称: 表示成员变量名。 类型: 表示成员变量类型。 默认值: 成员变量初始值，可省略。 类的方法表示方式为: 可见性 名称([参数列表])[: 返回类型]。 可见性: 同成员变量定义。 名称: 方法名。 参数列表: 方法的参数，可省略。 返回类型: 方法的返回值类型，可省略。 接口的UML表示与class有些区别，在接口中通常没有成员变量，只有方法的声明没有方法的实现。如下图，接口右上方有特殊的标记。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:1","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#类的uml图示"},{"categories":["设计模式"],"content":" 类之间的关系 关联关系关联(Association)关系表示一类对象与另一类对象之间有关系。通常为一个类的对象作为另一个类的成员变量，UML类图中用实线连接两个类。 关联关系有如下几种形式。 双向关联: 双方都拥有对方类对象的成员变量。 单向关联: 单方面拥有另一个类对象的成员变量。 多重关联: 两个关联类在拥有对方的类成员数量上有对应关系。用如下图方式表示数量对应关系。 多重性表示方式 例如，一个界面Form可以拥有0..*个按钮Button，而一个Button只能和一个Form类关联。此处不是双向关联，因为Button并不拥有Form对象的成员变量。 聚合关系: 聚合(Aggregation)关系表示整体和部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。成员对象的生命周期不由整体对象管理，通过构造方法、Setter方法注入到整体对象中。 如下图，聚合关系用带空心菱形的实线表示。 组合关系: 组合(Composition)关系表示比聚合关系更强的整体与部分的关系，整体对象控制成员对象的生命周期。成员对象不能脱离整体对象而存在。通常在整体类的构造方法中直接实例化成员类。 如下图，组合关系用带实心菱形的实线表示。 依赖关系依赖(Dependency)关系表示一个事物使用另一个事物时使用的依赖关系。一般情况下依赖关系体现在某个类的方法中使用另一个类的对象。由三种方式来实现：1、将一个类的对象作为另一个类中的方法参数。2、类的方法中使用另一个类的对象作为局部变量。3、在类的方法中调用另一个类的静态方法。 如下图，在UML中使用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系泛化(Generalization)关系就是集成关系，描述父类和子类之间的关系。 如下图，在UML中使用空心三角形的直线表示。 接口与实现关系接口和类之间有实现(Realization)关系，类实现接口的所有生命方法。 如下图，在UML中使用空心三角形虚线的形式来表示实现关系。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#类之间的关系"},{"categories":["设计模式"],"content":" 类之间的关系 关联关系关联(Association)关系表示一类对象与另一类对象之间有关系。通常为一个类的对象作为另一个类的成员变量，UML类图中用实线连接两个类。 关联关系有如下几种形式。 双向关联: 双方都拥有对方类对象的成员变量。 单向关联: 单方面拥有另一个类对象的成员变量。 多重关联: 两个关联类在拥有对方的类成员数量上有对应关系。用如下图方式表示数量对应关系。 多重性表示方式 例如，一个界面Form可以拥有0..*个按钮Button，而一个Button只能和一个Form类关联。此处不是双向关联，因为Button并不拥有Form对象的成员变量。 聚合关系: 聚合(Aggregation)关系表示整体和部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。成员对象的生命周期不由整体对象管理，通过构造方法、Setter方法注入到整体对象中。 如下图，聚合关系用带空心菱形的实线表示。 组合关系: 组合(Composition)关系表示比聚合关系更强的整体与部分的关系，整体对象控制成员对象的生命周期。成员对象不能脱离整体对象而存在。通常在整体类的构造方法中直接实例化成员类。 如下图，组合关系用带实心菱形的实线表示。 依赖关系依赖(Dependency)关系表示一个事物使用另一个事物时使用的依赖关系。一般情况下依赖关系体现在某个类的方法中使用另一个类的对象。由三种方式来实现：1、将一个类的对象作为另一个类中的方法参数。2、类的方法中使用另一个类的对象作为局部变量。3、在类的方法中调用另一个类的静态方法。 如下图，在UML中使用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系泛化(Generalization)关系就是集成关系，描述父类和子类之间的关系。 如下图，在UML中使用空心三角形的直线表示。 接口与实现关系接口和类之间有实现(Realization)关系，类实现接口的所有生命方法。 如下图，在UML中使用空心三角形虚线的形式来表示实现关系。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#关联关系"},{"categories":["设计模式"],"content":" 类之间的关系 关联关系关联(Association)关系表示一类对象与另一类对象之间有关系。通常为一个类的对象作为另一个类的成员变量，UML类图中用实线连接两个类。 关联关系有如下几种形式。 双向关联: 双方都拥有对方类对象的成员变量。 单向关联: 单方面拥有另一个类对象的成员变量。 多重关联: 两个关联类在拥有对方的类成员数量上有对应关系。用如下图方式表示数量对应关系。 多重性表示方式 例如，一个界面Form可以拥有0..*个按钮Button，而一个Button只能和一个Form类关联。此处不是双向关联，因为Button并不拥有Form对象的成员变量。 聚合关系: 聚合(Aggregation)关系表示整体和部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。成员对象的生命周期不由整体对象管理，通过构造方法、Setter方法注入到整体对象中。 如下图，聚合关系用带空心菱形的实线表示。 组合关系: 组合(Composition)关系表示比聚合关系更强的整体与部分的关系，整体对象控制成员对象的生命周期。成员对象不能脱离整体对象而存在。通常在整体类的构造方法中直接实例化成员类。 如下图，组合关系用带实心菱形的实线表示。 依赖关系依赖(Dependency)关系表示一个事物使用另一个事物时使用的依赖关系。一般情况下依赖关系体现在某个类的方法中使用另一个类的对象。由三种方式来实现：1、将一个类的对象作为另一个类中的方法参数。2、类的方法中使用另一个类的对象作为局部变量。3、在类的方法中调用另一个类的静态方法。 如下图，在UML中使用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系泛化(Generalization)关系就是集成关系，描述父类和子类之间的关系。 如下图，在UML中使用空心三角形的直线表示。 接口与实现关系接口和类之间有实现(Realization)关系，类实现接口的所有生命方法。 如下图，在UML中使用空心三角形虚线的形式来表示实现关系。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#依赖关系"},{"categories":["设计模式"],"content":" 类之间的关系 关联关系关联(Association)关系表示一类对象与另一类对象之间有关系。通常为一个类的对象作为另一个类的成员变量，UML类图中用实线连接两个类。 关联关系有如下几种形式。 双向关联: 双方都拥有对方类对象的成员变量。 单向关联: 单方面拥有另一个类对象的成员变量。 多重关联: 两个关联类在拥有对方的类成员数量上有对应关系。用如下图方式表示数量对应关系。 多重性表示方式 例如，一个界面Form可以拥有0..*个按钮Button，而一个Button只能和一个Form类关联。此处不是双向关联，因为Button并不拥有Form对象的成员变量。 聚合关系: 聚合(Aggregation)关系表示整体和部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。成员对象的生命周期不由整体对象管理，通过构造方法、Setter方法注入到整体对象中。 如下图，聚合关系用带空心菱形的实线表示。 组合关系: 组合(Composition)关系表示比聚合关系更强的整体与部分的关系，整体对象控制成员对象的生命周期。成员对象不能脱离整体对象而存在。通常在整体类的构造方法中直接实例化成员类。 如下图，组合关系用带实心菱形的实线表示。 依赖关系依赖(Dependency)关系表示一个事物使用另一个事物时使用的依赖关系。一般情况下依赖关系体现在某个类的方法中使用另一个类的对象。由三种方式来实现：1、将一个类的对象作为另一个类中的方法参数。2、类的方法中使用另一个类的对象作为局部变量。3、在类的方法中调用另一个类的静态方法。 如下图，在UML中使用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系泛化(Generalization)关系就是集成关系，描述父类和子类之间的关系。 如下图，在UML中使用空心三角形的直线表示。 接口与实现关系接口和类之间有实现(Realization)关系，类实现接口的所有生命方法。 如下图，在UML中使用空心三角形虚线的形式来表示实现关系。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#泛化关系"},{"categories":["设计模式"],"content":" 类之间的关系 关联关系关联(Association)关系表示一类对象与另一类对象之间有关系。通常为一个类的对象作为另一个类的成员变量，UML类图中用实线连接两个类。 关联关系有如下几种形式。 双向关联: 双方都拥有对方类对象的成员变量。 单向关联: 单方面拥有另一个类对象的成员变量。 多重关联: 两个关联类在拥有对方的类成员数量上有对应关系。用如下图方式表示数量对应关系。 多重性表示方式 例如，一个界面Form可以拥有0..*个按钮Button，而一个Button只能和一个Form类关联。此处不是双向关联，因为Button并不拥有Form对象的成员变量。 聚合关系: 聚合(Aggregation)关系表示整体和部分的关系，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。成员对象的生命周期不由整体对象管理，通过构造方法、Setter方法注入到整体对象中。 如下图，聚合关系用带空心菱形的实线表示。 组合关系: 组合(Composition)关系表示比聚合关系更强的整体与部分的关系，整体对象控制成员对象的生命周期。成员对象不能脱离整体对象而存在。通常在整体类的构造方法中直接实例化成员类。 如下图，组合关系用带实心菱形的实线表示。 依赖关系依赖(Dependency)关系表示一个事物使用另一个事物时使用的依赖关系。一般情况下依赖关系体现在某个类的方法中使用另一个类的对象。由三种方式来实现：1、将一个类的对象作为另一个类中的方法参数。2、类的方法中使用另一个类的对象作为局部变量。3、在类的方法中调用另一个类的静态方法。 如下图，在UML中使用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系泛化(Generalization)关系就是集成关系，描述父类和子类之间的关系。 如下图，在UML中使用空心三角形的直线表示。 接口与实现关系接口和类之间有实现(Realization)关系，类实现接口的所有生命方法。 如下图，在UML中使用空心三角形虚线的形式来表示实现关系。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:2:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#接口与实现关系"},{"categories":["设计模式"],"content":" 面向对象设计原则面向对象设计目标之一在于可维护性复用，一方面要实现源代码的复用，一方面又要易于扩展和修改。以下七种面向对象设计原则就是为了支持可维护性复用而诞生。 设计模式原则 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:0","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#面向对象设计原则"},{"categories":["设计模式"],"content":" 单一职责原则单一职责原则(Single Responsibility Principle, SRP): 一个类只负责一个功能领域的相应职责。这样一个类就只有一个引起它变化的原因。 一个类承担的职责越多，其被复用的可能性就越小，并且当一个职责变化时可能会影响到其他职责。因此最好将不同的变化原因封装在不同的类中。 单一职责原则是实现高内聚、低耦合的指导方针，是最简单也最难运用的原则。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:1","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#单一职责原则"},{"categories":["设计模式"],"content":" 开闭原则、里氏替换原则、依赖倒转原则开闭原则(Open-Closed Principle, OCP): 一个软件实体应该对扩展开放，对修改关闭。软件应在尽量不修改原有代码的情况下进行扩展。 里氏替换原则(Liskov Substitution Principle, LSP): 引用基类的地方可以透明地替换成其子类对象。 依赖倒转原则(Dependency Inversion Principle, DIP): 抽象不应该依赖于细节，细节应该依赖于抽象。要针对接口编程，而不是针对实现编程。 在大多数情况下，以上三种设计原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。依赖方依赖接口编程(依赖倒转原则)，通过替换接口的实现(需要里氏替换原则作为基础)，从而实现在基本不修改依赖方的代码替换具体的实现达到对扩展开放对修改关闭的开闭原则。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:2","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#开闭原则里氏替换原则依赖倒转原则"},{"categories":["设计模式"],"content":" 接口隔离原则接口隔离原则(Interface Segregation Principle, ISP): 使用多个专门的接口，而不使用单一的总接口。客户端不应该依赖那些它不需要的接口。 “接口”有两种含义: 一种是类对外提供的方法集合，类型要满足单一职责原则，其对外提供的方法(接口)也应该要隔离其他类型；一种是语言提供的抽象类或者接口特性，每个接口应该只包含某一种用户定制的方法即可，接口不应该承担太多职责否则继承该接口的类需要实现不需要的方法。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:3","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#接口隔离原则"},{"categories":["设计模式"],"content":" 合成复用原则合成复用原则(Composition Reuse Principle, CARP): 尽量使用对象组合，而不是继承来达到复用的目的。对象通过关联关系(包括组合关系和聚合关系)来使用另一个类的方法来达到复用的目的，而不是使用通过继承另一个类来使用其方法。 继承关系相比于关联关系会将基类的实现细节过多暴露给子类，所以其耦合程度高于关联关系。一般而言，如果两个类是“Has a”的关系应该使用组合或聚合；如果是“Is a”的关系，应该使用继承。像Go语言从语言层面不支持继承只支持组合也能成为流行的语言，说明继承也不是必须的，滥用继承反而会增加维护的难度以及系统的复杂度。 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:4","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#合成复用原则"},{"categories":["设计模式"],"content":" 迪米特法则迪米特法则(Law of Demeter, LoD): 一个软件实体应当尽可能减少与其它实体发生相互作用，从而降低系统的耦合度，类与类之间保持松散的耦合关系。 迪米特法则有几种定义形式: 不要和陌生人说话，只与直接朋友通信: 对于一个对象，其朋友有如下几类。对象不要和除以下朋友的陌生人直接通信。 当前对象本身(this) 以参数形式传入当前对象方法中的对象 当前对象的成员对象 当前对象所创建的对象 减少对象间的交互: 如果两个对象之间不必直接通信，则不应当发生任何直接的相互作用；如果其中一个对象需要调用另一个对象的方法，可以引入第三者转发这个调用，从而降低对象之间的耦合度。 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决 ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:3:5","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#迪米特法则"},{"categories":["设计模式"],"content":" 参考 《设计模式的艺术:一本实例驱动的设计模式实践指南》 ↩︎ ","date":"2024-08-07","objectID":"/posts/design_patterns_1/:4:0","series":null,"tags":["读书笔记","《设计模式的艺术》"],"title":"设计模式基础 - 《设计模式的艺术》读书笔记【1】","uri":"/posts/design_patterns_1/#参考"},{"categories":["v4l2学习"],"content":"v4l2(video for Linux two)是linux为视频设备提供的一套api接口规范，two表示版本为2。利用该接口应用程序可以从摄像头外设读取一系列图片进行处理。本文主要是实现使用该接口获取摄像头图片保存到本地，以此了解v4l2 api的基本使用方法。后续工作如果需要也要深入了解下各种摄像头、图像参数的意义，进阶的话还想学习内核侧v4l2驱动的编写。参考了网络上的一些博客1、2、3等。 ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:0:0","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#"},{"categories":["v4l2学习"],"content":" 调用基本流程使用v4l2从摄像头读取图片的基本流程为: 打开设备 检查和设置设备属性 设置图片帧格式 设置input/output方式 循环获取数据 关闭设备 v4l2相关的数据结构、枚举值等都定义在\u003clinux/videodev2.h\u003e中。有如下几个需要提前知道的地方。 ioctl()函数用于操作设备，声明如下。 c #include \u003csys/ioctl.h\u003e int ioctl(int fd, unsigned long op, ...); /* glibc, BSD */ 其中fd为打开设备的fd。参数op为操作类型，不同类型的设备可能不同，例如v4l2的api使用VIDIOC_*的宏来表示这些操作数。其后的参数是不定长的，根据不同的参数op应该接着传入不同的参数，用于设置或获取信息。 程序中定义了如下的几个宏，包括LOG_INFO和LOG_ERROR打印日志和errExit用于判断函数是否调用成功，如果失败就打印原因后退出。 c #define LOG(level) std::cout \u003c\u003c std::endl \u003c\u003c #level \u003c\u003c \" \" \u003c\u003c __FILE__ \u003c\u003c \":\" \u003c\u003c __LINE__ \u003c\u003c \" \" #define LOG_INFO LOG(INFO) #define LOG_ERROR LOG(ERROR) #define errExit(stmt) \\ { \\ if ((stmt) \u003c 0) { \\ LOG_ERROR \u003c\u003c #stmt \u003c\u003c \", errno: \" \u003c\u003c errno \u003c\u003c \", errstr: \" \u003c\u003c strerror(errno); \\ exit(1); \\ } \\ } ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:0","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#调用基本流程"},{"categories":["v4l2学习"],"content":" 打开设备一般情况下设备地址就是/dev/video0。对于同一个摄像头物理设备可能对应多个video设备地址，一般第一个可以用来采图，其余有其它作用，具体还未研究。像我的笔记本就有/dev/video0～/dev/video3四个设备，但只有打开第一个能出jpg格式的图片。可以使用如下命令对比这些设备的信息diff: shell vimdiff \u003c(v4l2-ctl -d /dev/video0 --all) \u003c(v4l2-ctl -d /dev/video1 --all) 在代码实现中，可以简单的以O_RDWR可读写的方式打开摄像头设备的地址。 c int vfd = -1; errExit(vfd = open(\"/dev/video0\", O_RDWR)); ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:1","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#打开设备"},{"categories":["v4l2学习"],"content":" 检查设备属性设备属性通过结构体v4l2_capability表示，使用op为VIDIOC_QUERYCAP的ioctrl可以获取设备属性信息。并且检查设备是否支持视频捕获功能。 c++ errExit(ioctl(vfd, VIDIOC_QUERYCAP, \u0026cap)); LOG_INFO \u003c\u003c \"driver: \" \u003c\u003c cap.driver \u003c\u003c \" , card: \" \u003c\u003c cap.card \u003c\u003c \" , bus: \" \u003c\u003c cap.bus_info \u003c\u003c \" , version: \" \u003c\u003c cap.version \u003c\u003c \" , cap: \" \u003c\u003c cap.capabilities; if (!(cap.capabilities \u0026 V4L2_CAP_VIDEO_CAPTURE)) { LOG_ERROR \u003c\u003c \"not capture device\"; return -1; } 其中结构体v4l2_capability的声明如下。 c /** * struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP * * @driver: name of the driver module (e.g. \"bttv\") * @card: name of the card (e.g. \"Hauppauge WinTV\") * @bus_info: name of the bus (e.g. \"PCI:\" + pci_name(pci_dev) ) * @version: KERNEL_VERSION * @capabilities: capabilities of the physical device as a whole * @device_caps: capabilities accessed via this particular device (node) * @reserved: reserved fields for future extensions */ struct v4l2_capability { __u8 driver[16]; __u8 card[32]; __u8 bus_info[32]; __u32 version; __u32 capabilities; __u32 device_caps; __u32 reserved[3]; }; 也可以通过结构体v4l2_fmtdesc和op为VIDIOC_ENUM_FMT循环获取支持的格式列表。 c++ v4l2_fmtdesc fmtdesc; fmtdesc.index = 0; fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while (ioctl(vfd, VIDIOC_ENUM_FMT, \u0026fmtdesc) != -1) { LOG_INFO \u003c\u003c \"index: \" \u003c\u003c fmtdesc.index \u003c\u003c \", desc: \" \u003c\u003c fmtdesc.description; ++fmtdesc.index; } ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:2","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#检查设备属性"},{"categories":["v4l2学习"],"content":" 设置图片帧格式通过结构体v4l2_format和op为VIDIOC_S_FMT设置帧格式。 c++ struct v4l2_format fmt {}; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; fmt.fmt.pix.width = WIDTH; fmt.fmt.pix.height = HEIGHT; fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG; fmt.fmt.pix.field = V4L2_FIELD_NONE; errExit(ioctl(vfd, VIDIOC_S_FMT, \u0026fmt)); ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:3","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#设置图片帧格式"},{"categories":["v4l2学习"],"content":" 设置input/output方式一般使用mmap传输方式映射内核空间的图片到用户空间，相较于直接read()减少内核空间到用户空间的一次数据拷贝。 首先通过VIDIOC_REQBUFS向v4l2申请内核空间缓存的数量。 c++ struct v4l2_requestbuffers req; req.count = BUFFER_COUNT; req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; req.memory = V4L2_MEMORY_MMAP; errExit(ioctl(vfd, VIDIOC_REQBUFS, \u0026req)); 然后通过VIDIOC_QUERYBUF获取循环每个缓存在内核buffer中的偏移量，从而使用mmap映射到用户内存空间，并且将用户空间的起始地址和长度保存起来，供后边从中拿取图片。 c++ struct v4l2_buffer buf {}; for (int n_buffer = 0; n_buffer \u003c req.count; ++n_buffer) { buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffer; errExit(ioctl(vfd, VIDIOC_QUERYBUF, \u0026buf)); LOG_INFO \u003c\u003c \"length: \" \u003c\u003c buf.length \u003c\u003c \", offset: \" \u003c\u003c buf.m.offset \u003c\u003c \", fd: \" \u003c\u003c buf.m.fd \u003c\u003c \", index: \" \u003c\u003c buf.index; buffers[n_buffer].length = buf.length; buffers[n_buffer].start = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, vfd, buf.m.offset); if (MAP_FAILED == buffers[n_buffer].start) { perror(\"mmap\"); continue; } errExit(ioctl(vfd, VIDIOC_QBUF, \u0026buf)); // 将buf放入驱动队列 } 特别注意要使用VIDIOC_QBUF将buf放入驱动的队列中，否则队列大小为空直接取数据是会被永远阻塞。 ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:4","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#设置inputoutput方式"},{"categories":["v4l2学习"],"content":" 循环获取数据首先使用VIDIOC_STREAMON开启数据流。之后通过VIDIOC_DQBUF从驱动队列中消费图片，找到buf缓冲index对应的mmap映射用户空间的地址来获取图片。最后调用VIDIOC_QBUF将消费后的图片放入队列中。通过这个循环可以源源不断的取图片形成视频。我这里仅仅保存了8张图片用于验证。 c struct v4l2_buffer capture_buf {}; capture_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; capture_buf.memory = V4L2_MEMORY_MMAP; int img_cnt = 0; for (int i = 0; img_cnt \u003c BUFFER_COUNT * 2; ++i) { errExit(ioctl(vfd, VIDIOC_DQBUF, \u0026capture_buf)); LOG_INFO \u003c\u003c \"idx: \" \u003c\u003c i \u003c\u003c \", bytesused: \" \u003c\u003c capture_buf.bytesused; if (0 != capture_buf.bytesused \u0026\u0026 0 == i % 10) { ++img_cnt; // 保存图片到本地 int imgfd = open((std::string(\"capture_\") + std::to_string(i) + \".jpg\").c_str(), O_WRONLY | O_CREAT, 0666); errExit(imgfd); errExit(write(imgfd, buffers[capture_buf.index].start, capture_buf.bytesused)); errExit(close(imgfd)); } if (0 != ioctl(vfd, VIDIOC_QBUF, \u0026capture_buf)) { perror(\"VIDIOC_QBUF\"); return 1; } } ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:5","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#循环获取数据"},{"categories":["v4l2学习"],"content":" 关闭设备最后通过VIDIOC_STREAMOFF关闭数据流，munmap取消之前的mmap映射的地址，close()关闭设备fd。 c++ errExit(ioctl(vfd, VIDIOC_STREAMOFF, \u0026buf.type)); for (int i = 0; i \u003c BUFFER_COUNT; ++i) { munmap(buffers[i].start, buffers[i].length); } close(vfd); ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:1:6","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#关闭设备"},{"categories":["v4l2学习"],"content":" 完整代码 c++ #include \u003cfcntl.h\u003e #include \u003clinux/videodev2.h\u003e #include \u003cmemory.h\u003e #include \u003cstdio.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/select.h\u003e #include \u003cunistd.h\u003e #include \u003ciostream\u003e #include \u003cstring\u003e #define BUFFER_COUNT 4 #define WIDTH 640 #define HEIGHT 480 #define LOG(level) std::cout \u003c\u003c std::endl \u003c\u003c #level \u003c\u003c \" \" \u003c\u003c __FILE__ \u003c\u003c \":\" \u003c\u003c __LINE__ \u003c\u003c \" \" #define LOG_INFO LOG(INFO) #define LOG_ERROR LOG(ERROR) #define errExit(stmt) \\ { \\ if ((stmt) \u003c 0) { \\ LOG_ERROR \u003c\u003c #stmt \u003c\u003c \", errno: \" \u003c\u003c errno \u003c\u003c \", errstr: \" \u003c\u003c strerror(errno); \\ exit(1); \\ } \\ } struct buffer { void *start; uint length; } buffers[BUFFER_COUNT]; int main() { int vfd = -1; errExit(vfd = open(\"/dev/video0\", O_RDWR)); v4l2_capability cap{0}; errExit(ioctl(vfd, VIDIOC_QUERYCAP, \u0026cap)); LOG_INFO \u003c\u003c \"driver: \" \u003c\u003c cap.driver \u003c\u003c \" , card: \" \u003c\u003c cap.card \u003c\u003c \" , bus: \" \u003c\u003c cap.bus_info \u003c\u003c \" , version: \" \u003c\u003c cap.version \u003c\u003c \" , cap: \" \u003c\u003c cap.capabilities; if (!(cap.capabilities \u0026 V4L2_CAP_VIDEO_CAPTURE)) { LOG_ERROR \u003c\u003c \"not capture device\"; return -1; } struct v4l2_fmtdesc fmtdesc; fmtdesc.index = 0; fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; while (ioctl(vfd, VIDIOC_ENUM_FMT, \u0026fmtdesc) != -1) { LOG_INFO \u003c\u003c \"index: \" \u003c\u003c fmtdesc.index \u003c\u003c \", desc: \" \u003c\u003c fmtdesc.description; ++fmtdesc.index; } struct v4l2_format fmt {}; fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; fmt.fmt.pix.width = WIDTH; fmt.fmt.pix.height = HEIGHT; fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG; fmt.fmt.pix.field = V4L2_FIELD_NONE; errExit(ioctl(vfd, VIDIOC_S_FMT, \u0026fmt)); struct v4l2_requestbuffers req; req.count = BUFFER_COUNT; req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; req.memory = V4L2_MEMORY_MMAP; errExit(ioctl(vfd, VIDIOC_REQBUFS, \u0026req)); struct v4l2_buffer buf {}; for (int n_buffer = 0; n_buffer \u003c req.count; ++n_buffer) { buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffer; errExit(ioctl(vfd, VIDIOC_QUERYBUF, \u0026buf)); LOG_INFO \u003c\u003c \"length: \" \u003c\u003c buf.length \u003c\u003c \", offset: \" \u003c\u003c buf.m.offset \u003c\u003c \", fd: \" \u003c\u003c buf.m.fd \u003c\u003c \", index: \" \u003c\u003c buf.index; buffers[n_buffer].length = buf.length; buffers[n_buffer].start = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, vfd, buf.m.offset); if (MAP_FAILED == buffers[n_buffer].start) { perror(\"mmap\"); continue; } errExit(ioctl(vfd, VIDIOC_QBUF, \u0026buf)); } errExit(ioctl(vfd, VIDIOC_STREAMON, \u0026buf.type)); // 等待fd可读。可以省略 fd_set fds; FD_ZERO(\u0026fds); FD_SET(vfd, \u0026fds); struct timeval tv {}; tv.tv_sec = 2; errExit(select(vfd + 1, \u0026fds, NULL, NULL, \u0026tv)); struct v4l2_buffer capture_buf {}; capture_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; capture_buf.memory = V4L2_MEMORY_MMAP; int img_cnt = 0; for (int i = 0; img_cnt \u003c BUFFER_COUNT * 2; ++i) { errExit(ioctl(vfd, VIDIOC_DQBUF, \u0026capture_buf)); LOG_INFO \u003c\u003c \"idx: \" \u003c\u003c i \u003c\u003c \", bytesused: \" \u003c\u003c capture_buf.bytesused; if (0 != capture_buf.bytesused \u0026\u0026 0 == i % 10) { ++img_cnt; int imgfd = open((std::string(\"capture_\") + std::to_string(i) + \".jpg\").c_str(), O_WRONLY | O_CREAT, 0666); errExit(imgfd); errExit(write(imgfd, buffers[capture_buf.index].start, capture_buf.bytesused)); errExit(close(imgfd)); } if (0 != ioctl(vfd, VIDIOC_QBUF, \u0026capture_buf)) { perror(\"VIDIOC_QBUF\"); return 1; } } errExit(ioctl(vfd, VIDIOC_STREAMOFF, \u0026buf.type)); for (int i = 0; i \u003c BUFFER_COUNT; ++i) { munmap(buffers[i].start, buffers[i].length); } close(vfd); } ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:2:0","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#完整代码"},{"categories":["v4l2学习"],"content":" 参考 v4l2的学习建议和流程解析 ↩︎ file: media/v4l/capture.c ↩︎ The Video4Linux2 API: an introduction ↩︎ ","date":"2024-07-16","objectID":"/posts/v4l2_learning_1/:3:0","series":null,"tags":["v4l2","系统编程"],"title":"v4l2 api基本使用流程 - V4l2学习笔记","uri":"/posts/v4l2_learning_1/#参考"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":"本文是在阅读《Linux/UNIX系统编程手册》1第20、21、22章做的笔记。信号在Linux中非常常用，学习信号可以对程序异常崩溃有一个更深入的理解，同时也学习到如何写信号处置函数。也能从信号的角度看到程序为何崩溃，对分析程序崩溃的问题有一定帮助。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:0:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号基本概念信号是事件发生时对进程的通知机制。针对每种信号定义了唯一的整数，从1开始顺序增加，\u003csignal.h\u003e以SIGxxxx的形式对信号整数进行宏定义。信号分为两大类，第一组为标准信号也就是我们通常使用的信号类型，Linux中编号范围为1～31。另一类信号为实时信号，实时信号相对于标准信号有队列管理、在传递顺序有所保证并且可以伴随数据传递，主要用于进程间通信。本文主要讨论标准信号。 信号因某些事件产生到进程处理期间，处于等待(pending)状态。信号在传递给进程时会打断进程的执行，视具体的信号执行如下默认操作之一: 忽略信号: 内核将信号丢弃，对进程不会产生任何影响。 终止进程: 进程会异常终止。 产生coredump并终止: 将进程的虚拟内存镜像存储为coredump文件，同时进程异常终止。 停止进程: 暂停进程的执行。 继续进程: 恢复暂停的进程执行。 除了以上特定信号的默认行为之外，程序也能改变某些信号到达时的默认行为。但并不是所有的信号都可以修改其默认行为。程序可以通过signal()或sigaction()设置某个信号的处置方式为如下之一: 捕获: 执行用户给定的处置函数。 忽略: 忽略信号。 采取默认的行为，撤销之前对该信号处置的修改。 为了确保一段代码不被某些信号所中断，程序可以添加某些信号到进程的信号掩码中，这样信号到达时会被阻塞。直到程序从信号掩码中删除，阻塞的信号才会被处理。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号基本概念"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号类型和默认行为Linux对标准信号的编号为1～31，有些信号名称由于为了与其他UNIX实现保持源码兼容有别名。下面对一些常用的信号做介绍。括号中是信号值，不同Linux版本可能不同。 SIGABRT(6): 但进程主动调用abort()函数时，系统向进程发送该信号。默认情况下会终止进程并且产生coredump文件。 SIGALRAM(14): 调用alram()或setitimer()设置的定时器到期，内核将产生该信号，默认行为是终止进程。 硬件异常产生的信号不可被忽略、阻塞或从信号处置函数中正常返回，否则会产生未定义的行为。以下是硬件异常产生的信号。 SIGBUS( 7): 总线错误，对内存地址的引用不合法。 SIGSEGV(11): 对内存地址的引用不合法。 SIGFPE( 8): 算术错误，比如除以0。 SIGILL( 4): 进程试图执行非法(格式不正确)的机器语言指令。 SIGCHLD(17): 内核向父进程发送该信号通知某一子进程终止\\停止\\恢复，详情参考sigchld信号。 作业控制信号: 暂停和继续的信号，参考在shell中使用作业控制 SIGSTP(20): 停止进程。命令行中输入ctrl+z可以向前台进程组发送该信号，并且将进程组放入后台。 SIGCONT(18): 继续进程，默认情况忽略该信号，进程可以捕获该信号，以便在恢复运行时执行某些操作。 SIGSTOP(19): 必停进程，无法阻塞、忽略或者捕获。 SIGKILL( 9): 必杀信号，无法阻塞、忽略或者捕获。 SIGTERM(15): 用来终止进程的标准信号，命令kill和killall发送的默认信号。好的程序应该考虑为SIGTERM设置处置函数以便于终止时清除临时文件和释放其它资源。故好的提前终止进程的方法是，先发送SIGTERM来终止进程，把SIGKILL作为最后的手段。在另一篇文章中从音频播放c++类的实现学习Linux系统子进程管理提前结束进程采用的SIGKILL信号并不规范。 SIGHUP( 1): 当终端断开时，系统将会发送该信号给shell进程，参考关闭终端-sighup信号，默认行为是终止进程。一些守护进程如init、httpd和inetd等捕获了该信号，在收到该信号时会重新初始化并且重读配置文件。 SIGQUIT( 3): 默认终止进程并且产生coredump。命令行中输入ctrl+\\可以向前台进程组发送该信号。 SIGPIPE: 当某一进程试图向管道、FIFO或socket写入信息时，这些设备无相应的读进程，通常是由于读进程close文件描述符，默认行为是终止进程。服务器程序通常忽略此信号，否则如果对方断开连接，继续write的话程序会意外终止。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号类型和默认行为"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 多线程与信号 在多线程程序中，使用signal的第一原则就是不要使用signal。2 UNIX信号模型是基于UNIX进程模型而设计的，问世比Pthreads要早几十年，自然而然信号与线程模型二者结合使用会非常复杂。两本书12都不建议在多线程程序中使用signal。以下是多线程遇到信号的一些关键点: 信号的动作属于进程层面，如果动作是停止或者终止则会终止该进程的所有线程。 信号的处置函数属于进程层面，某个线程设置信号处置函数则所有线程都共享该信号处置函数，某个线程将某个信号忽略，则所有线程都会忽略该信号。 信号的发送一般针对整个进程，如果该进程为此信号设置了处置函数，则内核会任选一条线程来执行信号处置函数。 信号的发送也可针对特定线程，有如下三种情况信号针对线程直接由该线程执行处置函数: 信号的产生源于线程的硬件错误，如SIGBUS、SIGFPE、SIGILL、SIGSEGV。 但线程试图向一个已经关闭的管道、FIFO或socket写入信息时产生的SIGPIPE信号。 由函数pthread_kill()或pthread_sigqueue()所产生的信号，这些函数允许在同一进程下向其它线程发送信号。下文的raise()函数就是调用pthread_kill()向调用线程发送信号。 在《Linux多线程服务端编程：使用muduo C++网络库》2中给出了多线程使用信号的建议，包括: 不要用signal作为IPC手段，包括不要使用SIGUSR1等信号来触发服务端的行为。 不要使用基于signal实现的定时函数，包括alarm/ualarm/setitimer/timer_create/sleep/usleep等等。 不主动处理各种异常信号，只用默认语义: 结束进程。除了一个例外SIGPIPE，服务器程序通常忽略此信号。 在没有别的替代方法的情况下，比方说需要处理SIGCHLD信号，可以把异步信号转换成同步的文件描述符事件。传统做法是在signal_handler里往特定的pipe(2)写一个字节，主进程从中读取事件，从而将其纳入到统一的IO事件处理框架之中。现代的Linux增加了signalfd(2)把信号直接转换成文件描述符事件，从根本上避免使用signal_handler。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#多线程与信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 发送信号在shell中一般使用kill命令向指定进程发送指定信号，kill()系统调用则可以在代码中向指定进程发送指定信号。函数定义如下: c #include \u003csignal.h\u003e int kill(pid_t pid, int sig); 其pid参数表示具体发送信号的进程，意义如下: pid \u003e 0: 发送给pid指定的进程。 pid == 0: 发送给调用进程在同一进程组的所有子进程，包括调用进程自己。 pid == -1: 发送给调用进程所有有权发送信号的所有进程，除去调用进程自身和init进程(PID=1)。如果一个特权进程调用，那么会发送信号给系统中除去上述两个进程之外的所有进程。 pid \u003c -1: 发送给进程组id==abs(pid)的所有进程。另一个函数killpg()实现同样的功能，kill(-pgrp, sig)等价于killpg(pgrp, sig)。在打断播放的音频进程组的应用使用killpg()杀死进程组的所有进程。 可以通过kill()检查另一个进程是否存在，将参数sig指定为0，则不会发送信号影响另一个进程。若调用失败且errno为ESRCH表明进程不存在。若调用失败且errno为EPERM，表明进存在但调用进程无权向目标进程发送信号，或者调用成功，都表示进程存在。 向自身发送信号: raise进程可以调用raise()函数向自身发送信号，其定义如下: c #include \u003csignal.h\u003e int raise(int sig); 在单线程程序中，调用raise()相当于调用kill(getpid(), sig)。而对于多线程程序，则相当于pthread_kill(pthread_self(), sig)意味着将信号传递给调用raise()的线程，而不是kill(getpid(), sig)会传递给任意线程。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#发送信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 发送信号在shell中一般使用kill命令向指定进程发送指定信号，kill()系统调用则可以在代码中向指定进程发送指定信号。函数定义如下: c #include int kill(pid_t pid, int sig); 其pid参数表示具体发送信号的进程，意义如下: pid \u003e 0: 发送给pid指定的进程。 pid == 0: 发送给调用进程在同一进程组的所有子进程，包括调用进程自己。 pid == -1: 发送给调用进程所有有权发送信号的所有进程，除去调用进程自身和init进程(PID=1)。如果一个特权进程调用，那么会发送信号给系统中除去上述两个进程之外的所有进程。 pid \u003c -1: 发送给进程组id==abs(pid)的所有进程。另一个函数killpg()实现同样的功能，kill(-pgrp, sig)等价于killpg(pgrp, sig)。在打断播放的音频进程组的应用使用killpg()杀死进程组的所有进程。 可以通过kill()检查另一个进程是否存在，将参数sig指定为0，则不会发送信号影响另一个进程。若调用失败且errno为ESRCH表明进程不存在。若调用失败且errno为EPERM，表明进存在但调用进程无权向目标进程发送信号，或者调用成功，都表示进程存在。 向自身发送信号: raise进程可以调用raise()函数向自身发送信号，其定义如下: c #include int raise(int sig); 在单线程程序中，调用raise()相当于调用kill(getpid(), sig)。而对于多线程程序，则相当于pthread_kill(pthread_self(), sig)意味着将信号传递给调用raise()的线程，而不是kill(getpid(), sig)会传递给任意线程。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#向自身发送信号-raise"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号传递的时机与顺序 信号传递的时机如果信号是同步产生的，例如进程本身执行造成的信号，如硬件异常SIGBUS、SIGFPE、SIGILL、SIGSEGV等或者进程调用上述的raise()函数，会立即传递信号。 而对于异步产生的信号(即引发信号产生的事件来源于内核或者其它进程)，信号的产生和实际传递给进程之间存在延迟，此时信号处于等待(pending)状态。而传递给进程的时机是进程正在执行且发生由内核态到用户态的下一次切换时，意味着以下时刻才会传递信号: 进程再度获得调度。所以可能在任意地方中断进程执行流，开始执行信号处置函数。 系统调用完成时。信号的传递可能引起正在阻塞的系统调用过早完成。 信号传递的顺序如果进程某一个时刻有多个信号等待时，就目前Linux而言，会按照信号的编号升序排序，信号编号小的优先于信号编号大传递给进程。但是不能对该顺序由任何依赖，SUSv3标准规定该顺序由系统实现而定。 当多个解除了阻塞的信号在等待传递时，如果在信号处置函数执行期间发生了内核态到用户态的切换，那么将中断处置函数的执行，转而去调用第二个信号的处置函数。如下图所示。 对多个解除信号的传递 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号传递的时机与顺序"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号传递的时机与顺序 信号传递的时机如果信号是同步产生的，例如进程本身执行造成的信号，如硬件异常SIGBUS、SIGFPE、SIGILL、SIGSEGV等或者进程调用上述的raise()函数，会立即传递信号。 而对于异步产生的信号(即引发信号产生的事件来源于内核或者其它进程)，信号的产生和实际传递给进程之间存在延迟，此时信号处于等待(pending)状态。而传递给进程的时机是进程正在执行且发生由内核态到用户态的下一次切换时，意味着以下时刻才会传递信号: 进程再度获得调度。所以可能在任意地方中断进程执行流，开始执行信号处置函数。 系统调用完成时。信号的传递可能引起正在阻塞的系统调用过早完成。 信号传递的顺序如果进程某一个时刻有多个信号等待时，就目前Linux而言，会按照信号的编号升序排序，信号编号小的优先于信号编号大传递给进程。但是不能对该顺序由任何依赖，SUSv3标准规定该顺序由系统实现而定。 当多个解除了阻塞的信号在等待传递时，如果在信号处置函数执行期间发生了内核态到用户态的切换，那么将中断处置函数的执行，转而去调用第二个信号的处置函数。如下图所示。 对多个解除信号的传递 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号传递的时机"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号传递的时机与顺序 信号传递的时机如果信号是同步产生的，例如进程本身执行造成的信号，如硬件异常SIGBUS、SIGFPE、SIGILL、SIGSEGV等或者进程调用上述的raise()函数，会立即传递信号。 而对于异步产生的信号(即引发信号产生的事件来源于内核或者其它进程)，信号的产生和实际传递给进程之间存在延迟，此时信号处于等待(pending)状态。而传递给进程的时机是进程正在执行且发生由内核态到用户态的下一次切换时，意味着以下时刻才会传递信号: 进程再度获得调度。所以可能在任意地方中断进程执行流，开始执行信号处置函数。 系统调用完成时。信号的传递可能引起正在阻塞的系统调用过早完成。 信号传递的顺序如果进程某一个时刻有多个信号等待时，就目前Linux而言，会按照信号的编号升序排序，信号编号小的优先于信号编号大传递给进程。但是不能对该顺序由任何依赖，SUSv3标准规定该顺序由系统实现而定。 当多个解除了阻塞的信号在等待传递时，如果在信号处置函数执行期间发生了内核态到用户态的切换，那么将中断处置函数的执行，转而去调用第二个信号的处置函数。如下图所示。 对多个解除信号的传递 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:1:4","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号传递的顺序"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 设置信号处置函数UNIX系统对改变信号处置函数提供了两种方法: signal()和sigaction()。signal()系统调用时设置信号处置的原始API，比sigaction()简单。当然sigaction()提供了signal()所不具备的功能。signal()在不同的UNIX实现之间存在差异，所以对于可移植性有追求的程序应该使用sigaction()。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#设置信号处置函数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" signal() signal()函数虽然记录在Linux手册页的第2部分，但实际被实现为基于sigaction()系统调用的glibc库函数。 函数原型如下: c #include \u003csignal.h\u003e typedef void(*sighandler_t)(int); sighandler_t signal(int sig, sighandler_t handler); 参数sig表示希望修改处置函数的信号编号；参数handler表示处置函数的地址，处置函数的声明形式为: void handdler(int sig)；返回值则是之前的信号处置函数地址，或者是SIG_DEL默认处置、SIG_IGN忽略处置和SIG_ERR表示调用失败。 在为signal()指定handler参数时，可以使用如下值来代替函数地址: SIG_DFL: 将信号处置函数重置为默认值。 SIG_IGN: 忽略该信号。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#signal"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" sigaction()sigaction()系统调用用法比signal()复杂，当更具灵活性和移植性。其函数原型如下: c #include \u003csignal.h\u003e int sigaction(int sig, constr struct sigaction *act, struct sigaction *oldact); 参数sig表示想要操作的信号编号，该参数是除去SIGKILL和SIGSTOP之外的任何信号。参数act是一枚指针，指向描述信号新处置的数据结构，如果仅对现有的处置感兴趣可以将其设置为NULL。参数oldact是指向同一类型的指针，用来返回之前信号处置的相关信息，如果不想获取此类信息，可以将其指定为NULL。act和oldact所指向的数据结构如下: c struct sigaction { void (*sa_handler)(int); // 信号处置函数地址 sigset_t sa_mask; // 处置函数阻塞的信号集合 int sa_flags; // 设置标志位 void (*sa_restorer)(void); // 不是给应用程序使用 }; 数据结构sigaction中字段sa_handler字段对应signal()的handler参数，可以指定为信号处置函数的地址或常量SIG_IGN、SIG_DFL之一。仅当sa_handler是信号处置函数的地址时，才会对sa_mask和sa_flags字段进行处理。字段sa_restorer供内核使用，应用程序不应该使用。 字段sa_mask定义了一组信号集合，表示在调用信号处置函数时阻塞该集合中的所有信号。此外，引发处置函数的信号将自动加在这个集合中，也就是如果同一个信号到达，信号处置函数不会递归的中断自己。由于不会对遭遇阻塞的信号进行排队处理，如果执行中重复收到这些信号中的任何信号，在解除限制后对信号的传递也是一次性的。 字段sa_flags定义位掩码，用于设置信号处理过程中的各种选项，可以使用或运算相加设置。(以下仅为部分重要选项) SA_NOCLDSTOP: 若sig为SIGCHLD信号，则当子进程终止或恢复时不会产生该信号给调用进程。 SA_NOCLDWAIT: 若sig为SIGCHLD信号，则当子进程终止时不会将其转化成僵尸进程。和设置SIGCHLD的处置为SIG_IGN主要区别在于，SA_NOCLDWAIT允许系统在子进程终止时向进程发送SIGCHLD信号，虽已经无法调用wait()来获取子进程的状态。但该特性并不在标准中保证，不过在包括Linux的一些UNIX实现中，内核确实会在设置该标志的情况下为父进程产生SIGCHLD信号。 SA_NODEFER: 不会在执行处置函数时将触发信号放入到阻塞信号集合中。 SA_RESTART: 自动重启由信号处置程序中断的系统调用。后边由详细介绍。 信号集合sigset_t多个信号的集合可用sigset_t数据结构来表示，Linux中是位掩码实现，但标准并为对实现有要求。所以在初始化一个sigset_t结构时，为了可移植性不可使用memset()等清零初始化，因为有可能实现采用位掩码之外的结构来表示信号集。必须使用如下函数: sigemptyset()函数初始化一个空的信号集，而sigfillset()函数初始化一个满的信号集，其包含所有信号包括实时信号。 c #include \u003csignal.h\u003e int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); 信号集合初始化后，可以分别使用sigaddset()和sigdelset()函数向信号集合加入或删除指定信号。 c #include \u003csignal.h\u003e int sigaddset(sigset_t *set, int sig); int sigdelset(sigset_t *set, int sig); 使用sigismember()函数可以测试指定信号是否在指定信号集中。GUN C库还实现了3个非标准函数: sigandset()求两个信号集的交集; sigorset()求两个信号集的并集; sigisemptyset()判断信号集是否为空。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#sigaction"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" sigaction()sigaction()系统调用用法比signal()复杂，当更具灵活性和移植性。其函数原型如下: c #include int sigaction(int sig, constr struct sigaction *act, struct sigaction *oldact); 参数sig表示想要操作的信号编号，该参数是除去SIGKILL和SIGSTOP之外的任何信号。参数act是一枚指针，指向描述信号新处置的数据结构，如果仅对现有的处置感兴趣可以将其设置为NULL。参数oldact是指向同一类型的指针，用来返回之前信号处置的相关信息，如果不想获取此类信息，可以将其指定为NULL。act和oldact所指向的数据结构如下: c struct sigaction { void (*sa_handler)(int); // 信号处置函数地址 sigset_t sa_mask; // 处置函数阻塞的信号集合 int sa_flags; // 设置标志位 void (*sa_restorer)(void); // 不是给应用程序使用 }; 数据结构sigaction中字段sa_handler字段对应signal()的handler参数，可以指定为信号处置函数的地址或常量SIG_IGN、SIG_DFL之一。仅当sa_handler是信号处置函数的地址时，才会对sa_mask和sa_flags字段进行处理。字段sa_restorer供内核使用，应用程序不应该使用。 字段sa_mask定义了一组信号集合，表示在调用信号处置函数时阻塞该集合中的所有信号。此外，引发处置函数的信号将自动加在这个集合中，也就是如果同一个信号到达，信号处置函数不会递归的中断自己。由于不会对遭遇阻塞的信号进行排队处理，如果执行中重复收到这些信号中的任何信号，在解除限制后对信号的传递也是一次性的。 字段sa_flags定义位掩码，用于设置信号处理过程中的各种选项，可以使用或运算相加设置。(以下仅为部分重要选项) SA_NOCLDSTOP: 若sig为SIGCHLD信号，则当子进程终止或恢复时不会产生该信号给调用进程。 SA_NOCLDWAIT: 若sig为SIGCHLD信号，则当子进程终止时不会将其转化成僵尸进程。和设置SIGCHLD的处置为SIG_IGN主要区别在于，SA_NOCLDWAIT允许系统在子进程终止时向进程发送SIGCHLD信号，虽已经无法调用wait()来获取子进程的状态。但该特性并不在标准中保证，不过在包括Linux的一些UNIX实现中，内核确实会在设置该标志的情况下为父进程产生SIGCHLD信号。 SA_NODEFER: 不会在执行处置函数时将触发信号放入到阻塞信号集合中。 SA_RESTART: 自动重启由信号处置程序中断的系统调用。后边由详细介绍。 信号集合sigset_t多个信号的集合可用sigset_t数据结构来表示，Linux中是位掩码实现，但标准并为对实现有要求。所以在初始化一个sigset_t结构时，为了可移植性不可使用memset()等清零初始化，因为有可能实现采用位掩码之外的结构来表示信号集。必须使用如下函数: sigemptyset()函数初始化一个空的信号集，而sigfillset()函数初始化一个满的信号集，其包含所有信号包括实时信号。 c #include int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); 信号集合初始化后，可以分别使用sigaddset()和sigdelset()函数向信号集合加入或删除指定信号。 c #include int sigaddset(sigset_t *set, int sig); int sigdelset(sigset_t *set, int sig); 使用sigismember()函数可以测试指定信号是否在指定信号集中。GUN C库还实现了3个非标准函数: sigandset()求两个信号集的交集; sigorset()求两个信号集的并集; sigisemptyset()判断信号集是否为空。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号集合sigset_t"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号的其它处置 信号掩码(阻塞信号传递)内核为每个进程维护一组信号掩码集合，表示阻塞一组信号对该进程传递。直至进程的信号掩码移出该信号，从而解除阻塞为止。并且并不会对阻塞的信号做排队处理。对于多线程程序，信号掩码属于线程属性，每个线程可以使用pthread_sigmask()函数来独立检查和修改其信号掩码。 操作信号掩码有如下几种方式: 使用sigprocmask()系统调用，可以显式向信号掩码中加入或删除信号。 默认情况下调用信号处置函数时，会将引发调用的信号自动添加到信号掩码中。 调用sigaction()时指定一组信号，当调用该处置函数时程序会将该组信号添加到信号掩码中。 获取处于等待的信号可以调用sigpending()获取当前正在被阻塞的信号，该函数返回处于等待状态的信号集。 等待信号: pause()调用pause()将暂停进程的执行，直到信号来临。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号的其它处置"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号的其它处置 信号掩码(阻塞信号传递)内核为每个进程维护一组信号掩码集合，表示阻塞一组信号对该进程传递。直至进程的信号掩码移出该信号，从而解除阻塞为止。并且并不会对阻塞的信号做排队处理。对于多线程程序，信号掩码属于线程属性，每个线程可以使用pthread_sigmask()函数来独立检查和修改其信号掩码。 操作信号掩码有如下几种方式: 使用sigprocmask()系统调用，可以显式向信号掩码中加入或删除信号。 默认情况下调用信号处置函数时，会将引发调用的信号自动添加到信号掩码中。 调用sigaction()时指定一组信号，当调用该处置函数时程序会将该组信号添加到信号掩码中。 获取处于等待的信号可以调用sigpending()获取当前正在被阻塞的信号，该函数返回处于等待状态的信号集。 等待信号: pause()调用pause()将暂停进程的执行，直到信号来临。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号掩码阻塞信号传递"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号的其它处置 信号掩码(阻塞信号传递)内核为每个进程维护一组信号掩码集合，表示阻塞一组信号对该进程传递。直至进程的信号掩码移出该信号，从而解除阻塞为止。并且并不会对阻塞的信号做排队处理。对于多线程程序，信号掩码属于线程属性，每个线程可以使用pthread_sigmask()函数来独立检查和修改其信号掩码。 操作信号掩码有如下几种方式: 使用sigprocmask()系统调用，可以显式向信号掩码中加入或删除信号。 默认情况下调用信号处置函数时，会将引发调用的信号自动添加到信号掩码中。 调用sigaction()时指定一组信号，当调用该处置函数时程序会将该组信号添加到信号掩码中。 获取处于等待的信号可以调用sigpending()获取当前正在被阻塞的信号，该函数返回处于等待状态的信号集。 等待信号: pause()调用pause()将暂停进程的执行，直到信号来临。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#获取处于等待的信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号的其它处置 信号掩码(阻塞信号传递)内核为每个进程维护一组信号掩码集合，表示阻塞一组信号对该进程传递。直至进程的信号掩码移出该信号，从而解除阻塞为止。并且并不会对阻塞的信号做排队处理。对于多线程程序，信号掩码属于线程属性，每个线程可以使用pthread_sigmask()函数来独立检查和修改其信号掩码。 操作信号掩码有如下几种方式: 使用sigprocmask()系统调用，可以显式向信号掩码中加入或删除信号。 默认情况下调用信号处置函数时，会将引发调用的信号自动添加到信号掩码中。 调用sigaction()时指定一组信号，当调用该处置函数时程序会将该组信号添加到信号掩码中。 获取处于等待的信号可以调用sigpending()获取当前正在被阻塞的信号，该函数返回处于等待状态的信号集。 等待信号: pause()调用pause()将暂停进程的执行，直到信号来临。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#等待信号-pause"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号处置函数通过前面的介绍，信号可能会在任意地方打断正在执行的进程开始执行信号处置函数，甚于信号处置函数本身也可能被打断。那么对于信号处置函数就要求可重入。 可重入概念: 如果同一个进程多个线程可以安全的同时调用某一函数并且函数可以交叉执行。所谓交叉执行就表示不能使用一些同步锁，同步锁可以让函数线程安全但不能保证可重入。 线程安全和可重入: 可重入的函数一定是线程安全，反过来却不一定。通过同步锁来实现的线程安全函数一定不是可重入的，想象刚一上锁要修改数据时被打断，又重入该函数又会上同一个锁，假如这个锁是不可重入的则直接死锁，即使是可重入的锁对于锁所保护的临界区数据也被修改两次，因为打断函数执行修改完后又会返回之前的地方继续执行修改数据。 信号处置函数如果需要修改全局数据，那么被修改的变量必须是volatile sig_atomic_t类型，否则被打断的进程在恢复执行后无法立刻看到信号处置函数改动后的数据，因为编译器可能假定该变量不会被他处修改从而优化了内存访问。并且使用sig_atomic_t变量唯一能做的是在信号处置函数中设置，在主程序中进行检查，反之也可。 编写信号处置函数有如下两种选择: 确保信号处置函数本身是可重入的，并且只调用异步信号安全的函数。 当主程序执行不安全函数或是去操作信号处置函数也可能修改的全局数据结构时，阻塞信号的传递。在复杂程序中难以保证。 如果使用同一处置函数来处理不同信号或者调用sigaction()时设置了SA_NODEFER标志，那么处置函数可能会中断自己。因此，处置函数如果更新了全局或局部静态变量，即使主程序不使用这些变量，该函数依然是不可重入的。 综上所述，可重入函数如果要修改全局或局部共享变量，则该变量必须是volatile sig_atomic_t类型，否则该函数是不可重入函数。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:3:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号处置函数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 异步信号安全函数异步信号安全函数指的是某一函数是可重入或者信号处置函数无法将其中断的函数。对于系统函数有如下: 1 2 3 4 5 _Exit() (v3) _exit() abort() (v3) accept() (v3) access() aio_error() (v2) aio_return() (v2) aio_suspend() (v2) alarm() bind() (v3) cfgetispeed() getpid() getppid() getsockname() (v3) getsockopt() (v3) getuid() kill() link() listen() (v3) lseek() lstat() (v3) mkdir() sigdelset() sigemptyset() sigfillset() sigismember() signal() (v2) sigpause() (v2) sigpending() sigprocmask() sigqueue() (v2) sigset() (v2) sigsuspend() cfgetospeed() cfsetispeed() cfsetospeed() chdir() chmod() chown() clock_gettime() (v2) close() connect() (v3) creat() dup() dup2() execle() execve() fchmod() (v3) fchown() (v3) fcntl() fdatasync() (v2) fork() fpathconf() (v2) fstat() fsync() (v2) ftruncate() (v3) getegid() geteuid() getgid() getgroups() getpeername() (v3) getpgrp() mkfifo() open() pathconf() pause() pipe() poll() (v3) posix_trace_event() (v3) pselect() (v3) raise() (v2) read() readlink() (v3) recv() (v3) recvfrom() (v3) recvmsg() (v3) rename() rmdir() select() (v3) sem_post() (v2) send() (v3) sendmsg() (v3) sendto() (v3) setgid() setpgid() setsid() setsockopt() (v3) setuid() shutdown() (v3) sigaction() sigaddset() sleep() socket() (v3) sockatmark() (v3) socketpair() (v3) stat() symlink() (v3) sysconf() tcdrain() tcflow() tcflush() tcgetattr() tcgetpgrp() tcsendbreak() tcsetattr() tcsetpgrp() time() timer_getoverrun() (v2) timer_gettime() (v2) timer_settime() (v2) times() umask() uname() unlink() utime() wait() waitpid() write() 除该表之外所有的函数对于信号来讲都是不安全的，但当且仅当信号处置函数中断了不安全函数的执行并且信号处置函数也调用了这个不安全的函数时才会不安全。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:3:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#异步信号安全函数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 信号中断系统调用一些阻塞的系统调用(blocking system call)，例如read()。当系统调用正在阻塞时，信号传递来引发处置函数的调用后，默认情况下，系统调用会失败，并将errno置为EINTR。(对于非阻塞系统调用则系统会执行完成后才响应信号，内核态切换到用户态才会执行信号处置函数) 通过该特性可以使用定时器产生SIGALRM来设置read()之类的阻塞系统调用超时。不过，一般的情况是希望被信号中断的系统调用得以继续运行。为此需要手动重启系统调用。在GUN C库中提供了非标准的宏TEMP_FAILURE_RETRY()用于重启系统调用，定义类似如下: c #include \u003cunistd.h\u003e #define TEMP_FAILURE_RETRY(stmt) while((stmt) == -1 \u0026\u0026 errno == EINTR); // 例子 TEMP_FAILURE_RETRY(cnt = read(fd, buf, BUF_SIZZE)); if (cnt == -1) errExit(\"read\"); 另外的一种方式是在sigaction()创建信号处置函数时，设置SA_RESTART标志，从而针对该信号触发的信号处置函数执行完毕后会自动重启被中断的阻塞系统调用。不幸的是，并非所有的阻塞系统调用都可以通过指定该标志位进行重启。在Linux上以下阻塞系统调用以及构建于其上的库函数即使指定该标志也不会自动重启: poll()、ppoll()、select()和pselect()这些 I/O 多路复用调用。(SUSv3明文规定，无论设置SA_RESTART标志与否，都不对select()和pselect()遭处理器函数中断时的行为进行定义) Linux 特有的epoll_wait()和epoll_pwait()系统调用。 Linux 特有的io_getevents()系统调用。 操作System V消息队列和信号量的阻塞系统调用：semop()、semtimedop()、msgrcv()和msgsnd()。(虽然System V原本并未提供自动重启系统调用的功能，但在某些UNIX实现上，如果设置了SA_RESTART标志，这些系统调用还是会自动重启) 对inotify文件描述符发起的read()调用。 用于将进程挂起指定时间的系统调用和库函数：sleep()、nanosleep()和clock_nanosleep()。 特意设计用来等待某一信号到达的系统调用：pause()、sigsuspend()、sigtimedwait()和sigwaitinfo()。 在Linux上进程因为信号(SIGSTOP、SIGSTP等)而停止后又受到SIGCONT信号继续执行时，也会使得某些系统调用产生EINTR错误。以下系统调用和函数存在这一行为: epoll_pwait()、epoll_wait()、对inotify文件描述符执行的read()调用、semop()、semtimedop()、sigtimedwait()和igwaitinfo()。故在使用这些函数时需要添加代码来重新启动这些系统调用，即使程序未设置信号处置函数。 ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:3:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#信号中断系统调用"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 参考 《Linux/UNIX系统编程手册》 ↩︎ ↩︎ 《Linux多线程服务端编程：使用muduo C++网络库》 ↩︎ ↩︎ ↩︎ ","date":"2024-07-11","objectID":"/posts/the_linux_programming_interface_signal/:4:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"信号的基本概念和信号处置函数 - 《Linux/UNIX系统编程手册》读书笔记【2】","uri":"/posts/the_linux_programming_interface_signal/#参考"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":"本文是在阅读《Linux/UNIX系统编程手册》1相关内容做的笔记。由于实际工作中的一个需求从音频播放C++类的实现学习Linux系统子进程管理引起此次的系统学习和记录。此次学习对Linux系统中的进程有更加深入的理解，包括进程组和会话的概念、作业控制等以前并不深入了解的知识。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:0:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 创建新进程: fork()fork()系统调用创建新进程(child)几乎为调用进程(parent)的翻版。 c #include \u003cunistd.h\u003e pid_t fork(); 程序代码可通过返回值来区分父/子进程。在父进程将返回子进程的PID，父进程可以通过子进程的PID管理子进程。而子进程将返回0，在子进程中可以通过getpid和getppid分别获取子进程和父进程的PID。但创建失败时则会返回-1，一般的原因是进程数量超过了系统的限制。 不应该对fork后父子进程执行顺序有任何假设，如果需要确保一定的顺序则需要进程间同步。在从音频播放C++类的实现学习Linux系统子进程管理中就通过父子进程在fork之后都调用相同作用的系统调用来设置子进程的进程组ID，从而保证在任何调用顺序下，父子进程后续的执行都能确保进程组设置成功。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:1:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#创建新进程-fork"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" fork()的内存语义执行fork后子进程会和父进程拥有一模一样的内存空间，现代UNIX实现都是采用写时复制(copy-on-write)技术来节省物理内存消耗，即：父子进程在fork之后共享物理内存，在二者对内存页面有修改是才将要修改的内存页面拷贝，将子进程对应的表项修改，之后父子进程就可以分别修改各自的页拷贝。在书中提到利用这个特性，可以在已知某个func会导致内存泄漏或是过渡内存碎片，可以使用子进程执行该函数，就不会影响主进程的内存占用，最后通过进程间通信来获取结果。 在fork后父子进程内存是一模一样的，打开的文件fd中存储的系统级打开文件表引用是一样的，故其当前文件的偏移量、打开文件的状态标志等都是共享的，参考从文件描述符和打开文件之间的关系重新理解shell重定向。利用这个特性可以通过pipe等进行父子进程之间通信。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:1:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#fork的内存语义"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 资源管理与fork()2fork之后，子进程不会继承如下资源状态： 父进程的内存锁，mlock(2)、mlockall(2)。 父进程的文件锁，fcntl(2)。 父进程的某些定时器，setitimer(2)、alarm(2)、timer_create(2)。 如果在子进程对如上类的资源进行释放操作就会释放一个不拥有的资源，导致未定义行为。考虑在C++中，一般通过使用对象来包装资源，利用对象的生命周期管理资源(RAII)，在构造对象时获取资源，在对象出作用域析构时释放资源。因为释放资源并不是显性调用，在fork()之后子进程可能“无意”释放了不拥有的资源，造成未定义行为。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:1:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#资源管理与fork2"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 多线程与fork()2fork()之后，对于子进程除了当前的线程之外，其他线程都消失了，会导致一个危险的局面。其他线程可能正持有某个锁，fork()之后对于子进程来说其他线程已经没有了再也没有机会解锁，如果试图再对该mutex加锁就会立刻死锁。所以fork()后只能调用可重入函数。对于诸如malloc、printf函数都不可使用，所以对于多线程程序来说调用fork()唯一安全的做法就是fork()后立即调用exec()执行另一个程序，彻底断绝子进程和父进程的关系。 SUSv3对可重入函数定义: 函数由多条线程调用时，即便交叉执行，其效果也与各线程任意顺序依次调用一致。 我的理解是“在执行过程中可以被中断，并且在中断后能够安全地再次调用(重入)函数“，更新全局变量(不是sig_atomic_t类型)或局部静态变量的函数都不是可重入的函数。所以诸如malloc函数由于涉及到全局状态的修改是不可重入函数。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:1:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#多线程与fork2"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 执行新程序: execve()系统调用execve()将新程序加载到某一进程的内存空间，进程的内存空间会被新程序所取代，在执行了各种初始化代码会从新程序的main()函数开始执行。 c #include \u003cunistd.h\u003e int execve(const char *pathname, char *const argv[], char *const envp[]); 参数pathname可以时绝对路径或者相对于调用进程当前目录的相对路径；参数argv指定了传给新进程的命令行参数，相当于main()函数的第2个参数(argv)，以NULL结束；参数envp指定了新程序的环境列表，对应environ数组，以NULL结束，字符串格式为name=alue； Linux特有的/proc/PID/exe是符号链接包含对应进程中正在运行的可执行文件的绝对路径名。 通常也不用检查execve()的返回值，因为如果成功则切换到新程序执行不会继续执行，失败的话返回值一定是-1并且代表发生了错误，可以通过errno来判断错误原因，有如下可能： EACCES: 参数pathname指向的文件因为权限等原因不可执行。 ENOENT: pathname所指代的文件并不存在。 ENOEXEC: pathname所指代的文件不是ELF文件格式。 ETEXTBSY: 存在进程已经以写入方式打开pathname所指代的文件。 ELF(Executable and Linking Format)标准描述了可执行文件的布局，二进制可执行文件都需要符合该标准。同时该标准也允许定义一个解释器来运行程序以字符#!开头。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#执行新程序-execve"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" exec()库函数库函数为执行exec()提供了多种API选择，这些函数都是参数有所区别为了方便使用对execve()调用的封装。 下表对exec()函数之间的差异总结。简单来说: 函数名带p，代表可以只ß提供程序的文件名，库函数通过环境变量$PATH的目录列表找到对应的可执行文件，与shell对命令的搜索方式一致。 函数名带l，代表可以使用参数列表来指定argv，并且以NULL指针结尾。带v的则是使用数组的形式传入argv，数组的最后一个元素也需要是NULL。 函数名带e，代表可以通过envp以数组的形式显示指定函数的环境变量。其它不带e的函数则是继承调用者的环境变量。 exec()函数之间的差异总结 函数名 程序文件描述 参数描述 环境变量来源 execve() 路径名 数组 envp 参数 execle() 路径名 列表 envp 参数 execlp() 文件名+PATH 列表 调用者的 environ execvp() 文件名+PATH 数组 调用者的 environ execv() 路径名 数组 调用者的 environ execl() 路径名 列表 调用者的 environ ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#exec库函数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" exec()库函数库函数为执行exec()提供了多种API选择，这些函数都是参数有所区别为了方便使用对execve()调用的封装。 下表对exec()函数之间的差异总结。简单来说: 函数名带p，代表可以只ß提供程序的文件名，库函数通过环境变量$PATH的目录列表找到对应的可执行文件，与shell对命令的搜索方式一致。 函数名带l，代表可以使用参数列表来指定argv，并且以NULL指针结尾。带v的则是使用数组的形式传入argv，数组的最后一个元素也需要是NULL。 函数名带e，代表可以通过envp以数组的形式显示指定函数的环境变量。其它不带e的函数则是继承调用者的环境变量。 exec()函数之间的差异总结 函数名 程序文件描述 参数描述 环境变量来源 execve() 路径名 数组 envp 参数 execle() 路径名 列表 envp 参数 execlp() 文件名+PATH 列表 调用者的 environ execvp() 文件名+PATH 数组 调用者的 environ execv() 路径名 数组 调用者的 environ execl() 路径名 列表 调用者的 environ ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#exec函数之间的差异总结"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 多线程与exec()当进程中任意线程调用exec()，那么除了进程的主线程(main函数线程)其它线程都会终止，新程序在主线程中执行。故任意线程调用exec()后的新程序中调用gettid()将会返回原主线程的线程ID。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#多线程与exec"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 文件描述符与exec()默认情况下exec()的调用程序打开的所有文件描述符在exec()成功后的程序中会保持打开状态。shell利用这一特性为其所执行的程序处理I/O重定向。例如: shell $ls /tmp \u003e dir.txt shell运行该命令时会执行如下步骤: fork()创建子进程。 子进程以描述符1(stdout)打开文件dir.txt作为输出，采取如下方式: 使用dup2()强制将标准输出fd=1复制成文件dir.txt的fd的副本。 c fd = open(\"dir.txt\", ...); if (fd != STDOUT_FILENO) { dup2(fd, STDOUT_FILENO); close(fd); } 子shell调用exec()执行程序ls，ls将其结果输出到df=1标准输出，亦即文件dir.txt中。 执行时关闭(close-on-exec)标志(FD_CLOEXEC)大部分情况下，出于节省和安全的角度来讲程序在执行exec()之前需要关闭某些特定的文件描述符。当然可以在exec()调用close()实现这一目的，但是有如下局限性：某些fd是由库函数打开，程序主动close()可能会比较困难；假设exec()失败了，之前close()的fd可能还需要。 由此内核为每个文件描述符提供了执行时关闭的标志。设置这一标志，在程序exec()成功时会自动关闭该文件描述符。可以使用fcntl()和ioctl()等函数对某一个fd设置或清除这一标志位。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#文件描述符与exec"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 文件描述符与exec()默认情况下exec()的调用程序打开的所有文件描述符在exec()成功后的程序中会保持打开状态。shell利用这一特性为其所执行的程序处理I/O重定向。例如: shell $ls /tmp \u003e dir.txt shell运行该命令时会执行如下步骤: fork()创建子进程。 子进程以描述符1(stdout)打开文件dir.txt作为输出，采取如下方式: 使用dup2()强制将标准输出fd=1复制成文件dir.txt的fd的副本。 c fd = open(\"dir.txt\", ...); if (fd != STDOUT_FILENO) { dup2(fd, STDOUT_FILENO); close(fd); } 子shell调用exec()执行程序ls，ls将其结果输出到df=1标准输出，亦即文件dir.txt中。 执行时关闭(close-on-exec)标志(FD_CLOEXEC)大部分情况下，出于节省和安全的角度来讲程序在执行exec()之前需要关闭某些特定的文件描述符。当然可以在exec()调用close()实现这一目的，但是有如下局限性：某些fd是由库函数打开，程序主动close()可能会比较困难；假设exec()失败了，之前close()的fd可能还需要。 由此内核为每个文件描述符提供了执行时关闭的标志。设置这一标志，在程序exec()成功时会自动关闭该文件描述符。可以使用fcntl()和ioctl()等函数对某一个fd设置或清除这一标志位。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:2:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#执行时关闭close-on-exec标志fd_cloexec"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 进程的终止: _exit()和exit()进程一般有两种结束方式，其一为一些信号触发的异常结束，其二就是程序主动调用_exit()系统调用正常结束程序。 c #include \u003cunistd.h\u003e void _exit(int status); 参数status为进程的退出状态，父进程调用wait()可以获得该状态。虽然为int类型，但是仅有低8位有效，并且由于shell在程序被信号终止时会将环境变量$?设置为128与信号值的和，所以返回值不能大于128,否则就与信号触发的退出区分不清了。 c #include \u003cstdlib.h\u003e void exit(int status); 程序一般调用C语言库函数exit()主动退出，该函数会在退出前执行如下动作: 调用atexit()和on_exit()注册的退出处理程序。 刷新stdio缓冲区。 执行exit_()系统调用退出程序。 另外从main()函数中return n时等同于调用exit(n)。在C99标准中定义了，main()函数不写return等同于exit(0)。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:3:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#进程的终止-_exit和exit"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" fork()与_exit()/exit()函数在进程的用户空间中维护stdio缓冲区，因此通过fork()创建子进程时会复制该缓冲区。如果父/子进程都使用exit()退出会导致刷新各自的stdio缓冲区，从而导致重复的输出结果。故fork()后的子进程应该使用_exit()退出。 另外根据前边的介绍，如果父进程是多线程程序fork()后的子进程只会继承调用线程，假使fork()时正好有其它线程加锁操作stdio缓冲区，此时子进程的stdio缓冲区的锁已经被锁定并且不会被解锁，子进程调用exit()会发生死锁。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:3:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#fork与_exitexit函数"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 等待子进程wait()和waitpid()系统调用wait()和waitpid()都是用来等待子进程终止并且获取其退出状态status。wait()等待调用进程的任一子进程终止，waitpid()可以指定等待的子进程pid。 c #include \u003csys/wait.h\u003e pid_t wait(int *status); pid_t waitpid(pid_t pid, int *status, int options); 正常二者都会返回结束的子进程pid，出错时返回-1。错误原因之一是调用进程无可被等待的子进程，此时errno设置为ECHILD。 对于waitpid(),其参数pid表示需要等待的具体子进程，意义如下: pid \u003e 0: 等待进程ID为pid的子进程。 pid == 0: 等待与调用进程在同一进程组的所有子进程。 pid == -1: 等待任意子进程，wait(\u0026status)与waitpid(-1, \u0026staus, 0)等价 pid \u003c -1: 等待进程组id==abs(pid)的所有子进程。 参数options时一个位掩码，可以设置如下标志位 WUNTRACED: 还返回因信号而停止的子进程信息。 WCONTINUED: 返回那些因受到SIGCONT信号而恢复执行的子进程信息。 WNOHANG: 如果指定的子进程未发生状态改变，则立即返回，不会阻塞。这时waitpid()返回0。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:4:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#等待子进程wait和waitpid"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 等待返回值头文件\u003csys/wait.h\u003e定义了一组解析等待状态值status的宏。 WIFEXITED(status): 若子进程是通过_exit()正常结束则返回true，此时WEXITSTATUS(status)返回子进程的退出状态。 WIFSIGNALED(status): 若子进程是被信号杀死时返回true，此时WTERNSIG(status)返回导致子进程终止的信号编号。若子进程产生coredump，则WCOREDUMP(status)返回true。 WIFSTOPPED(status): 若子进程因信号而停止，则返回true，此时WSTOPSIG(status)返回导致子进程停止的信号编号。 WIFCONTINUED(status): 若子进程因SIGCONT而恢复执行，则返回true。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:4:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#等待返回值"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" SIGCHLD信号子进程终止系统会向父进程发送SIGCHLD信号，该信号的默认处理就是忽略。在设置该信号的处理函数时，可以使用wait获取子进程退出状态，但是需要注意的是: 当调用信号处理程序时，默认会暂时将该信号阻塞起来，且不会对其进行排队处理。故当SIGCHILD信号处理程序正在执行中时，相继有两个子进程终止产生2个SIGCHLD信号被阻塞，父进程后边也只能捕获一次。所以SIGCHLD处理程序需要内部循环以WNOHANG标志来非阻塞的调用waitpid()，才可以避免出现僵尸进程，如以下代码。 c while (waitpid(-1, NULL, WNOHANG) \u003e 0) continue; 忽略SIGCHLD信号虽然对于SIGCHLD的默认处置就是忽略，但是显式的将SIGCHLD信号设置为SIG_IGN，系统会将其后产生的子进程立即删除，不会转为僵尸进程，同时后续的wait()调用不会返回子进程的任何信息。在这方面，信号SIGCHLD的处理不同于其它信号。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:4:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#sigchld信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" SIGCHLD信号子进程终止系统会向父进程发送SIGCHLD信号，该信号的默认处理就是忽略。在设置该信号的处理函数时，可以使用wait获取子进程退出状态，但是需要注意的是: 当调用信号处理程序时，默认会暂时将该信号阻塞起来，且不会对其进行排队处理。故当SIGCHILD信号处理程序正在执行中时，相继有两个子进程终止产生2个SIGCHLD信号被阻塞，父进程后边也只能捕获一次。所以SIGCHLD处理程序需要内部循环以WNOHANG标志来非阻塞的调用waitpid()，才可以避免出现僵尸进程，如以下代码。 c while (waitpid(-1, NULL, WNOHANG) \u003e 0) continue; 忽略SIGCHLD信号虽然对于SIGCHLD的默认处置就是忽略，但是显式的将SIGCHLD信号设置为SIG_IGN，系统会将其后产生的子进程立即删除，不会转为僵尸进程，同时后续的wait()调用不会返回子进程的任何信息。在这方面，信号SIGCHLD的处理不同于其它信号。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:4:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#忽略sigchld信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 进程组和会话、控制终端进程组和会话、控制终端是实现命令行的底层概念，用于命令行的输入、输出和shell的作业控制。 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成，进程组标识符（PGID）等于首次创建进程组的进程pid，其生命周期为创建时刻到最后一个进程退出进程组，在其生命周期不会有和PGID相同的pid分配给新进程。子进程会继承父进程的进程组。可以使用killpg()命令将信号发给进程组的每个成员进程，另一篇从音频播放C++类的实现学习Linux系统子进程管理就是利用这一特性实现杀死子进程和其产生的子进程。 会话则是一组进程组的集合。进程的会话成员关系是由其会话标识符（SID）确定的，会话标识符也是会话创建进程的pid。 当fork()创建新进程时，内核会保证不会和已有的进程组ID和会话ID相同。从而保证即使进程组或会话的首进程退出，新进程也不会复用首进程的PID。 每个会话可以拥有一个控制终端，终端是用户的交互设备，现代的图形界面都是使用终端模拟器xterm等软件，通过伪终端技术模拟终端设备。 下图表示了进程组和会话、控制终端之间的关系。 进程组、会话和控制终端之间的关系进程组 以上图举个实际的栗子: 打开Ubuntu系统的Terminal终端模拟软件，该软件模拟了一个终端设备并且执行/bin/bash进程pid=400。bash进程成为会话SID=400的首进程和终端的控制进程，也是进程组PGID=400的唯一成员。 用户输入执行find / 2\u003e /dev/null | wc -l \u0026，bash进程会把管道相连的两个进程find和wc放入同一个PGID=658进程组。由于命令以\u0026结尾被放入后台进程组中。 用户接着输入执行sort \u003c longlist | uniq -c，同样会将两个管道相连的进程放入同一个PGID=660进程组，并且处于前端进程组，可以接受用户的输入。显而易见，同一时间只能有一个进程组成为前端进程组。如果输入ctrl+c终端会将中断信号发送给前端进程组的每个成员，正常情况下两个进程都会结束。 由于本人不打算开发一个终端软件或者是shell软件所以对以下内容并不准备深入了解细节，只求懂个大概，简单写一写。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:5:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#进程组和会话控制终端"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 进程组通过pid_t getpgrp()和int setpgid(pid_t pid, pid_t pgid)获取和设置进程的进程组。参考另一篇使用进程组实现kill信号同时发给子进程和其产生的子进程中的实际应用。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:5:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#进程组"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 会话通过pid_t getsid(pid_t pid)和pid_t setsid()来获取进程的sid和设置当前进程为新会话的首进程和该会话中的新进程组的首进程。 注意：已经是进程组的首进程就不能调用setsid()设置自己为新会话的首进程。原因是如果可以的话，调用后进程组中原有的其他成员还属于原来的会话中，就会出现该进程组的成员不属于同一个会话中。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:5:2","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#会话"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 关闭终端: SIGHUP信号当控制进程(bash)失去与其终端的连接后，内核会向控制进程发送SIGHUP信号；当控制进程结束时，内核会向该控制进程关联的终端前台进程组发送SIGHUP信号。SIGHUP信号默认的行为是终止进程。bash进程设置了SIGHUP信号的处置函数，在退出前将SIGHUP信号发送给由它创建的所有进程组。 所以我们在ssh断开连接或者关闭终端时，仍在运行的任务会被结束。常用的nohup(1)命令在执行的命令时将SIGHUP信号设置为SIG_IGN，这样在终端退出时执行的命令不会结束。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:5:3","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#关闭终端-sighup信号"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 作业控制作业控制用来支持一个shell用户同时执行多个命令，其中最多一个命令在前台执行，其余命令在后台运行。命令可以被停止和恢复以及在前后台之间移动。 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:6:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#作业控制"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 在shell中使用作业控制首先，shell会为每个后台任务赋予一个唯一的作业号从1开始，在将任务放入后台时会将作业号放在[作业号]方括号中打印出来，后边跟着进程的PID或管道的最后一个进程的PID。通过jobs命令可以列出所有后台作业及其状态。 shell $ sleep 60\u0026 [1] 24599 $ sleep 600 ^Z [2]+ Stopped sleep 600 $ jobs [1]- Running sleep 60 \u0026 [2]+ Stopped sleep 600 使用%num可以引用作业，num为作业号。省略%num则默认指在前台最新被放入后台的作业。 产生后台作业的方式有使用ctrl+z向前台进程组发送SIGSTP(和SIGKILL一样不可修改信号默认处理函数，SIGSTOP才是不可修改)暂停进程并且放入后台，或者在命令执行时加上\u0026符号，该命令会立即在后台执行，不会暂停。可以使用fg %num命令在前台恢复作业号num的任务，也可以使用bg %num命令发送SIGCONT信号来恢复被暂停的作业。通过kill -STOP %num也可以将后台作业暂停。 在后台的作业尝试从读取标准输入，就会收到SIGTTIN信号，默认动作就是暂停作业。默认情况下，后台作业是可以写入标准输出打印在终端中的。如果终端设置了TOSTOP标志，那么当后台作业尝试输出到终端时会收到SIGTTOU信号，默认动作也是暂停作业。 shell $ stty tostop $ date \u0026 [4] 34046 $ [4]+ Stopped date $ fg date Wed Jul 10 11:21:32 PM CST 2024 下图对作业的状态转换进行了总结。 作业控制状态转换 ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:6:1","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#在shell中使用作业控制"},{"categories":["《Linux/UNIX系统编程手册》读书笔记"],"content":" 参考 《Linux/UNIX系统编程手册》 ↩︎ 《Linux多线程服务端编程：使用muduo C++网络库》 ↩︎ ↩︎ ","date":"2024-07-02","objectID":"/posts/the_linux_programming_interface_process/:7:0","series":null,"tags":["系统编程","读书笔记","《Linux/UNIX系统编程手册》"],"title":"进程、进程组和会话、作业控制 - 《Linux/UNIX系统编程手册》读书笔记【1】","uri":"/posts/the_linux_programming_interface_process/#参考"},{"categories":["实践到理论"],"content":"为了实现一个可以及时停止的音频播放类，学习使用fork、execl、setpgid、waitpid和进程组概念。 ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:0:0","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#"},{"categories":["实践到理论"],"content":" 需求之前车端软件播放音频文件都是在代码中使用popen、system等库函数执行shell命令aplay播放完整的短音频，不需要被打断。而这次的需求需要声音被及时打断，使用popen等库函数皆不能优雅的提前终止，所以有了此次造轮子的行为。其实boost库中有process模块，也能提前终止进程，但是看其示例感觉比较复杂容易使用不当，其中spawn、group等用法让人不看源代码、不学习底层原理，就不敢轻易使用。权衡了一下，总之都要学习一下进程管理，不如自己造个轮子，也能实操加深理解。 ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:1:0","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#需求"},{"categories":["实践到理论"],"content":" 代码分析代码的地址在这里 ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:2:0","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#代码分析"},{"categories":["实践到理论"],"content":" 打断播放的音频：进程组的应用在遇到另一篇文章中问题诊断: 小手册系列「1」的“popen后台符号\u0026导致僵尸进程”问题时，我就观察到用popen执行非内建命令时会至少两个进程，一个是/bin/sh，另一个才是输入命令的进程，并且如果执行kill命令杀死/bin/sh进程并不会导致输入命令的进程退出。原因是popen内部先创建shell进程将用户命令作为参数传给shell进程执行，shell进程会创建子进程执行实际的命令，而kill父进程的pid不会将信号发给子进程。 对于本需求需要主动结束播放音频进程，如果使用popen则难以获取播放音频进程的pid；如果使用fork和exec*系统调用创建子进程可以拿到子进程id，当然可以直接exec*创建播放音频进程并且拿到其pid，通过kill函数可以提前终止。而播放音频命令aplay不支持循环播放，这种做法需要在外部进行循环调用并不优雅，而且假设播放音频命令也创建子进程，kill命令不能结束子进程，可能会造成资源的泄漏。所以打算和popen一样执行shell命令，可以使用while等命令实现循环调用，使用进程组就可以将结束信号发给shell进程和其子进程。 下面主要介绍下进程组概念，进程组和会话主要用于shell作业控制。 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成，进程组标识符（PGID）等于首次创建进程组的进程pid，其生命周期为创建时刻开始，持续到最后一个进程退出进程组，在其生命周期不会有和PGID相同的pid分配给新进程。子进程会继承父进程的进程组。 会话则是一组进程组的集合。进程的会话成员关系是由其会话标识符（SID）确定的，会话标识符也是会话创建进程的pid。下图来自1，表示了进程组和会话之间的关系。 进程组、会话和控制终端之间的关系进程组 上图可以看到像sort \u003c file | uniq -c带有管道的命令会创建两个进程且在同一进程组，这样我们在前台执行ctrl+c时的终端会通过killpg将信号发送给进程组中的每个进程，从而结束这条命令。利用这个特点，我们可以fork后的子进程设置其为进程组的首进程，在父进程就可以通过killpg发送信号，杀死子进程和其产生的子进程，从而达到目的。 c++ pid_t exec(const std::string \u0026cmd) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", cmd: \" \u003c\u003c cmd; if (cmd.empty()) return -1; pid_t pid = fork(); if (pid == 0) { ::setpgid(0, 0); ::execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr); LOG_ERROR \u003c\u003c \"execl failure!\"; _exit(EXIT_FAILURE); } else if (pid \u003c 0) { LOG_ERROR \u003c\u003c \"fork failed: \" \u003c\u003c pid; } else { log_ss \u003c\u003c \", pid: \" \u003c\u003c pid \u003c\u003c \", setpgid ret: \" \u003c\u003c ::setpgid(pid, pid); } return pid; } 核心代码如上所示，其中setpgid是用来将进程为pid的进程的进程组修改为pgid，定义如下: c #include \u003cunistd.h\u003e int setpgid(pid_t pid, pid_t pgid); 如果将pid的值设置为0，那么就会设置调用进程的进程组。如果将pgid的值设置为0，那么设置的进程组pgid等于调用进程的pid。所以在fork后的子进程中可以直接调用::setpgid(0, 0);将自己设置为进程组的首进程，即其pid==pgid，从而使得其创建的子进程都继承其进程组id。父进程即可通过killpg(pid, sig)向/bin/sh进程和其产生的子进程发送sig信号。一个进程在其子进程已经执行exec()后就无法修改该子进程的进程组pgid了。 需要特别注意的是在父进程也调用了::setpgid(pid, pid)，重复设置子进程的进程组id。这是进程安全的做法，由于fork后子进程和父进程执行顺序不确定，如果只在子进程设置，可能出现子进程还没设置其线程组，而父进程就对线程组调用诸如killpg等命令造成并发问题。所以在父进程调用是很有必要的。 -c选项shell会直接执行该命令，而不是创建一个子shell进程。 ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:2:1","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#打断播放的音频进程组的应用"},{"categories":["实践到理论"],"content":" 程序崩溃时音频自动停止在循环播放音频时，如果父进程崩溃，并不会影响到子进程继续执行，此时声音就会一直被播放，这是不能被接受的。所以考虑在循环执行播放命令时做判断其父进程是否存在。 我的实现如下，通过持续判断当前进程的父进程(/proc/$$/stat文件中动态更新)是否等于进程创建时的父进程id($PPID)来判断父进程是否活着，如果父进程崩溃了，该子进程会被系统进程收养，其父进程id会改变。之所以没有直接判断$PPID进程是否还存在是因为在$PPID可能被其它进程分配到，此时虽然主进程已经崩溃，但是$PPID却还存在。 shell while [ $PPID -eq $(cut -d ' ' -f 4 /proc/$$/stat) ]; do aplay voice_path done ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:2:2","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#程序崩溃时音频自动停止"},{"categories":["实践到理论"],"content":" 锁的使用对上述进程管理操作，我封装了一个ShellProcess类，用于管理子进程，其只有一个数据成员pid_保存子进程的pid。同时封装VoicePlayer使用ShellProcess管理子进程播放音频。 在实现阻塞播放一次音频时，发现了一个难点：首先对于shell_process_对象的调用需要加锁保护防止多线程竞争，但是我不希望在阻塞播放音频时全程持有这个锁，这样就不能在其它线程调用stop(其也需要加锁)提前终止这次播放。 我的实现是在加锁的状态下进行exec播放进程并保存其pid到栈上。然后释放锁再调用waitpid，此时其它线程就可以随时stop了。之后在waitpid返回子进程结束后在, 再申请锁将shell_process_对象持有的pid赋值为-1，表明子进程已经结束。当然为了防止竟态条件，只在该对象持有的pid==保存的pid时才进行操作。 c++ void playOnceBlock(const std::string \u0026voice_path) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", path: \" \u003c\u003c voice_path; if (check_file_exist(voice_path)) { pid_t pid_voice = -1; { std::lock_guard\u003cstd::mutex\u003e lk_shell_process(shell_process_mutex_); shell_process_ = ShellProcess(\"aplay \" + voice_path); pid_voice = shell_process_.pid(); log_ss \u003c\u003c \", pid: \" \u003c\u003c pid_voice; cur_voice_path = voice_path; } log_ss.flush_log(); if (pid_voice \u003e 0) { int status = -1; int waitpid_ret = ::waitpid(pid_voice, \u0026status, 0); // waitpid阻塞时不持有锁, 其它线程可调用stop提前结束 log_ss \u003c\u003c \"waitpid, status: \" \u003c\u003c status \u003c\u003c \", exited: \" \u003c\u003c (WIFEXITED(status) ? WEXITSTATUS(status) : -1) \u003c\u003c \", signal: \" \u003c\u003c (WIFSIGNALED(status) ? WTERMSIG(status) : -1) \u003c\u003c \", waitpid_ret: \" \u003c\u003c waitpid_ret; } { std::lock_guard\u003cstd::mutex\u003e lk_shell_process(shell_process_mutex_); log_ss \u003c\u003c \"cur_pid: \" \u003c\u003c shell_process_.pid() \u003c\u003c \", pid_voice: \" \u003c\u003c pid_voice; if (shell_process_.pid() == pid_voice) log_ss \u003c\u003c \", terminate: \" \u003c\u003c shell_process_.terminate(); cur_voice_path = \"\"; } } else { log_ss \u003c\u003c \", not exist\"; } } ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:2:3","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#锁的使用"},{"categories":["实践到理论"],"content":" 完整代码update on 2024.06.25. c++ #define LOG_ERROR std::cerr \u003c\u003c std::endl #define LOG_INFO std::cout \u003c\u003c std::endl bool check_file_exist(const std::string \u0026file_path) { std::ifstream file(file_path); return file.good(); } class LogStringStream : public std::ostringstream { public: ~LogStringStream() { auto log_str = this-\u003estr(); if (log_str.size()) { LOG_INFO \u003c\u003c log_str; } } void flush_log() { auto log_str = this-\u003estr(); if (log_str.size()) { LOG_INFO \u003c\u003c log_str; this-\u003estr(\"\"); } } }; class DeferFunction { public: explicit DeferFunction(const std::function\u003cvoid()\u003e \u0026defer_func) : defer_func_(defer_func) {} ~DeferFunction() { defer_func_(); } private: std::function\u003cvoid()\u003e defer_func_; }; class ShellProcess { public: ShellProcess() = default; ShellProcess(const std::string \u0026cmd) : pid_(exec(cmd)) {} ShellProcess(ShellProcess \u0026\u0026lhs) noexcept : pid_(lhs.pid_) { lhs.pid_ = -1; } ShellProcess \u0026operator=(ShellProcess \u0026\u0026lhs) noexcept { if (this != \u0026lhs) { terminate(); this-\u003epid_ = lhs.pid_; lhs.pid_ = -1; } return *this; } ShellProcess(const ShellProcess \u0026) = delete; ShellProcess \u0026operator=(const ShellProcess \u0026) = delete; int terminate() { if (pid_ \u003e 0) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", pid: \" \u003c\u003c pid_; int killpg_ret = ::killpg(pid_, SIGKILL); log_ss \u003c\u003c \", killpg_ret: \" \u003c\u003c killpg_ret; std::this_thread::yield(); if (killpg_ret \u003c 0) { log_ss \u003c\u003c \", error: \" \u003c\u003c strerror(errno); } return waitNoBlock(); } return -1; } int wait() { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", pid: \" \u003c\u003c pid_; if (pid_ \u003e 0) { int status = -1; int waitpid_ret = ::waitpid(pid_, \u0026status, 0); pid_ = -1; log_ss \u003c\u003c \", status: \" \u003c\u003c status \u003c\u003c \", exited: \" \u003c\u003c (WIFEXITED(status) ? WEXITSTATUS(status) : -1) \u003c\u003c \", signal: \" \u003c\u003c (WIFSIGNALED(status) ? WTERMSIG(status) : -1) \u003c\u003c \", waitpid_ret: \" \u003c\u003c waitpid_ret; if (waitpid_ret \u003c 0) { log_ss \u003c\u003c \", error: \" \u003c\u003c strerror(errno); return -1; } return status; } return -1; } ~ShellProcess() { terminate(); } pid_t pid() const { return pid_; }; private: pid_t exec(const std::string \u0026cmd) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", cmd: \" \u003c\u003c cmd; if (cmd.empty()) return -1; pid_t pid = fork(); if (pid == 0) { ::setpgid(0, 0); ::execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr); LOG_ERROR \u003c\u003c \"execl failure!\"; _exit(EXIT_FAILURE); } else if (pid \u003c 0) { LOG_ERROR \u003c\u003c \"fork failed: \" \u003c\u003c pid; } else { log_ss \u003c\u003c \", pid: \" \u003c\u003c pid \u003c\u003c \", setpgid ret: \" \u003c\u003c ::setpgid(pid, pid); } return pid; } int waitNoBlock() { DeferFunction defer_func([this] { this-\u003epid_ = -1; }); LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", pid: \" \u003c\u003c pid_; if (pid_ \u003e 0) { static const int max_retry_times = 15; int status = -1; int waitpid_ret = 0; int retry_times = max_retry_times; do { waitpid_ret = ::waitpid(pid_, \u0026status, WNOHANG); if (max_retry_times - retry_times \u003c 5) std::this_thread::sleep_for(std::chrono::milliseconds(10)); else std::this_thread::yield(); } while (--retry_times \u003e 0 \u0026\u0026 ((waitpid_ret == 0) || (waitpid_ret == -1 \u0026\u0026 errno == EINTR) || (waitpid_ret != -1 \u0026\u0026 !WIFEXITED(status) \u0026\u0026 !WIFSIGNALED(status)))); log_ss \u003c\u003c \", retry_times: \" \u003c\u003c retry_times + 1 \u003c\u003c \", status: \" \u003c\u003c status \u003c\u003c \", exited: \" \u003c\u003c (WIFEXITED(status) ? WEXITSTATUS(status) : -1) \u003c\u003c \", signal: \" \u003c\u003c (WIFSIGNALED(status) ? WTERMSIG(status) : -1) \u003c\u003c \", waitpid_ret: \" \u003c\u003c waitpid_ret; return status; } return -1; } pid_t pid_ = -1; }; class VoicePlayer { public: void playContinuous(const std::string \u0026voice_path) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \", path: \" \u003c\u003c voice_path; if (check_file_exist(voice_path)) { std::lock_guard\u003cstd::mutex\u003e lk_shell_process(shell_process_mutex_); shell_process_ = ShellProcess(\"while [ $PPID -eq $(cut -d ' ' -f 4 /proc/$$/stat) ]; do aplay \" + voice_path + \"; done\"); log_ss \u003c\u003c \", pid: \" \u003c\u003c shell_process_.pid(); cur_voice_path = voice_path; } else { log_ss \u003c\u003c \", not exist\"; } } void playOnce(const std::string \u0026voice_path) { LogStringStream log_ss; log_ss \u003c\u003c __PRETTY_FUNCTION__ \u003c\u003c \"","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:3:0","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#完整代码"},{"categories":["实践到理论"],"content":" 参考 《Linux/UNIX系统编程手册》 ↩︎ ","date":"2024-06-25","objectID":"/posts/voice_player_system_programming/:4:0","series":null,"tags":["C++","shell","系统编程"],"title":"从音频播放C++类的实现学习Linux系统子进程管理","uri":"/posts/voice_player_system_programming/#参考"},{"categories":["生活"],"content":"2023年12月，出差海南，闲暇之余，志在饱览诗书，勿使光阴虚度也。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:0:0","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#"},{"categories":["生活"],"content":" 读书目录","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:0","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#读书目录"},{"categories":["生活"],"content":" 1、《大变局：晚清改革五十年》谌旭彬 读书日期：2023.12.03～2023.12.24 读后感 该书在1861年咸丰皇帝因英法联军进攻北京逃亡承德为改革开端至1911年清朝灭亡五十年里，每年选取一些和改革相关的一些大小事进行讲述。 改革派和保守派的斗争，改革路上的每一步路都很艰难，有种之前看过的《中国改革年代的政治斗争》的感觉。可能中国这艘巨轮每一次转向都会如此艰难痛苦。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:1","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#1大变局晚清改革五十年谌旭彬"},{"categories":["生活"],"content":" 2、《我在北京送快递》 读书日期：2023.12.25～2023.12.26 读后感 讲述作者做过的几份工作，让我看到不同工作的辛酸苦辣。作者这种不太争抢的性格说实话和我也有点相像，写的在一些事情下的心理活动就如我一样。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:2","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#2我在北京送快递"},{"categories":["生活"],"content":" 3、《中国历代政治得失》 读书日期：2023.12.27～2023.12.31 读后感 作者钱穆对中国几个主要朝代的政治制度进行描述比照和演变过程。该书和我的一些历史观有些许不同，对古代的政治制度还是有一定的推崇。而我觉得历史上从秦以来的专制独裁制度没啥可取之处。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:3","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#3中国历代政治得失"},{"categories":["生活"],"content":" 4、《一地鸡毛》 读书日期：2023.12.31～2024.01.06 读后感 讲了几个有意思的故事，《塔铺》中讲述了恢复高考后的补习班的一段爱情故事，女生为了凑父亲的看病钱不得不放弃高考并且嫁给别人，还是挺感动的。《新兵连》中关于友情与背叛。《头人》里面讲得村里几代人的恩怨。《单位》、《一地鸡毛》中讲述小林的公务员生活。《官场》讲述了领导的生活。故事性不强，但是文字有意思，让人很容易看下去。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:4","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#4一地鸡毛"},{"categories":["生活"],"content":" 5、《丰乳肥臀》 读书日期：2024.01.05～2024.01.20 读后感 讲述了上官一家从抗日战争到改革开放经历的苦难，感觉到莫言是想用几个女儿代表国民党、共产党等等势力，可惜能力不足没有完全对应上，表面的故事也不错，也有魔幻现实的情节，也有史诗的感觉。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:5","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#5丰乳肥臀"},{"categories":["生活"],"content":" 6、《看见》 读书日期：2024.01.21～2024.01.29 读后感 柴静讲述了其作为记者遇到的人或事，我能猜出其中有一些不便写于书中，有些地方我看还是有点矫情。如今言论的空间更为收缩，公知也成为一个贬义词，看到柴静移居海外在youtube上还在进行一些采访继续探明真相还是比较感动，希望有一天在这片大地上调查真相、讲述真相不再是禁忌。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:6","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#6看见"},{"categories":["生活"],"content":" 7、《显微镜下的大明》 读书日期：2024.01.29～2024.02.05 读后感 明代的平民政治生活，民间的诉讼，官员的平衡等等。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:7","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#7显微镜下的大明"},{"categories":["生活"],"content":" 8、《中苏关系史纲：1917～1991年中苏关系若干问题再探讨》 读书日期：2024.02.06～2024.02.15 读后感 读沈志华的第一本书，之前在youtube上经常看其讲座。讲述中苏关系从结盟走向分裂、从对抗走向正常化。从关系不设上限，到最后兵戎相见，看到了通过意识形态铸就关系的脆弱，领袖独裁的灾难。在今天来看某些事情也难免会重蹈覆辙。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:8","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#8中苏关系史纲19171991年中苏关系若干问题再探讨"},{"categories":["生活"],"content":" 9、《我的母亲做保洁》 读书日期：2024.02.14～2024.02.17 读后感 作者的母亲来深圳做保洁，重新和女儿生活在同一屋檐下。年轻时在矿场、工地挥洒汗水，如今在写字楼做保洁。看到了一位坚韧的母亲如同我的母亲和千千万万的母亲。为城市化付出很多，最后还得在城市中打工养老。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:9","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#9我的母亲做保洁"},{"categories":["生活"],"content":" 10、《置身事内：中国政府与经济发展》 读书日期：2024.02.18～2024.02.27 读后感 理解不透，看完大部分都已经遗忘，比较认同书中所说“政府不但影响蛋糕的分配也参与蛋糕的生产，所以不能脱离政府谈中国的经济。“虽然没有带有价值评判，但我觉得经济发展快速时，政府把其归功与制度优势，希望其在经济不好时也能承认面对，而不是利用权力逃脱责任。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:10","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#10置身事内中国政府与经济发展"},{"categories":["生活"],"content":" 11、《万历十五年》 读书日期：2024.02.27～2024.03.12 读后感 这本书读的匆匆，基本遗忘。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:11","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#11万历十五年"},{"categories":["生活"],"content":" 12、《35岁，我无路可退？》 读书日期：2024.03.12～2024.03.17 读后感 讲述几个人，人到中年，为了挣钱的几个故事。基本遗忘。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:12","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#1235岁我无路可退"},{"categories":["生活"],"content":" 13、《叫魂》 读书日期：2024.03.17～2024.03.28 读后感 开始在通勤路上，听书。和《万历十五年》一样是在美国的作者写中国的历史。讲述清乾隆年间名为“叫魂”的妖术演变成全国除妖运动，读出愚昧、专制的大清各色人等。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:13","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#13叫魂"},{"categories":["生活"],"content":" 14、《白夜追凶》 读书日期：2024.03.28～2024.04.10 读后感 以为会写道同名电视剧之后的故事，结果这本书就像剧本一样，电视剧拍到哪里书就写到哪里。里面也有一些和电视剧细微的不同。听此书不用思考可以让我通勤路上放松。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:14","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#14白夜追凶"},{"categories":["生活"],"content":" 15、《被讨厌的勇气：”自我启发之父“阿德勒的哲学课》 读书日期：2024.04.28～2024.04.10 读后感 书中用青年和哲人对话的形式讲述阿德勒心理学。几个启发的点：1. 不要拿过去的事情来说明此刻的问题，过去已经过去此刻的你只有此刻的你决定。2. 不是内向选择了你，而是你选择了内向。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:15","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#15被讨厌的勇气自我启发之父阿德勒的哲学课"},{"categories":["生活"],"content":" 16、《牛鬼蛇神录》 读书日期：2024.04.17～2024.04.21 读后感 从秦晖的文革讲座中知道的这本书，本书作者杨小凯是个传奇人物，文革时高中生的他写了一篇《中国向何处去》的文章，被康生等领导人批评为大毒草，被关入监狱，其母亲不忍批斗自杀。文革后移居澳洲，研究经济，曾经获得诺贝尔经济学家的提名。 本书是作者文革期间在监狱的所见所闻，讲述其遇到的刑事犯、政治犯的人和事。保守派和造反派都在同一个监狱中，文革中各种政治斗争，毛的翻手为云覆手为雨各个势力你方唱罢我登场，毛的两派平衡之下，双方的积怨越来越深，其坐享渔翁。这场运动全中国获利的人恐怕只有毛一人。其中秘密政治结社的刘凤祥故事更让人感动。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:16","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#16牛鬼蛇神录"},{"categories":["生活"],"content":" 17、《绿皮火车》 读书日期：2024.04.21～2024.04.24 读后感 本书为民谣歌手周云蓬所写的散文合集。挺喜欢其唱的《中国孩子》、《九月》、《不会说话的爱情》。书中写了一些其所见所闻，可能有一些矫情，不过我已经记不太清了:) ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:17","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#17绿皮火车"},{"categories":["生活"],"content":" 18、《夹边沟纪事》 读书日期：2024.04.24～2024.05.07 读后感 此为杨显惠所作书籍，之前读过两次都未读完，这次完整的读了一遍，这本书没想到还短暂上架微信读书，当然目前已经下架了。 这本书写了很多在反右运动中被打为右派送到甘肃的夹边沟劳改农场的故事，在三年饥荒时期他们大多数饿死在农场中。他们大多数都为领导干部因为各种荒缪的原因被选为右派，其中很多人甚至非常忠诚。在饥饿中为了填饱肚子没有尊严，逃跑、偷东西、出卖朋友等等，只为了能活下去。其中也有各种人性的光辉。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:18","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#18夹边沟纪事"},{"categories":["生活"],"content":" 19、《北京三千年：从考古发现看北京建城史》 读书日期：2024.05.07～2024.05.13 读后感 本书讲了北京三千年建城史，八百年的建都史。西周就在先房山琉璃河建城。讲了一些考古的故事，多数已经遗忘。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:19","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#19北京三千年从考古发现看北京建城史"},{"categories":["生活"],"content":" 20、《定西孤儿院纪事》 读书日期：2024.05.13～2024.05.24 读后感 看的杨显惠作者第二本书，讲述在三年饥荒下甘肃孤儿的故事，他们的亲人在饥荒年月饿死在家中，这些孤儿跑出农村要饭，被收容在政府成立的孤儿院中，虽然在孤儿院中不能吃饱，但也不至于饿死。书中尽是苦难，都是关于生存的故事。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:20","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#20定西孤儿院纪事"},{"categories":["生活"],"content":" 21、《活在洪武时代：朱元璋治下小人物的命运》 读书日期：2024.05.24～2024.06.01 读后感 该书写朱元璋的四编《大诰》笔下的“洪武愚顽”，没有帝王将相的雄才大略，只有被统治者的辗转腾挪。朱元璋在这四编中讲述了两百桩案子，作者对这些案子重审，展示出洪武时代人民的生活状况。书中的描述的洪武时代和今朝开年的时代相似度很高，包括乡里饮酒和组织生活、路引制度和户口、《大诰》和毛语录、大举报时代、各种运动。那些近代的残酷制度在几百年前就已经上演，如今那些灾难还在上演，孕育的土壤还存在，希望下次这艘巨船的转向能够让我们进入现代正常国家，也希望转向的浪花能够小一些，卷进风浪的人们能少一些。 ","date":"2024-06-09","objectID":"/posts/reading_202312-202406/:1:21","series":null,"tags":["书单盘点","读书笔记"],"title":"书单盘点: 2023年12月～2024年05月","uri":"/posts/reading_202312-202406/#21活在洪武时代朱元璋治下小人物的命运"},{"categories":["troubleshooting"],"content":"此次coredump断断续续查了约两个月才查明原因，迄今为止遇到最棘手的问题，深刻的体会到debug C/C++内存损坏是多么痛苦。为了debug还写了两个内存检测工具，可惜最终还是通过注释代码和人肉检查找到了问题根因，不过自制的检测工具还是能把模拟的demo检测出来问题，还是比较有成就感。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:0:0","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#"},{"categories":["troubleshooting"],"content":" 前置知识","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:1:0","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#前置知识"},{"categories":["troubleshooting"],"content":" 内存管理器如果想要对内存损坏有一个深刻意识需要对内存分配器有一个初步的认识，接下来对其做基本概念介绍。 堆内存（Heap Memory）是由内存管理器进行管理的，用户通过void *malloc( size_t size )申请堆内存块，通过void free(void *)将申请的内存块还给内存分配器。一般我们使用的内存管理器是glibc中的ptmalloc。 在linux中内存管理器通过brk和mmap系统调用向操作系统申请一大块内存进行管理，用户申请的内存优先在申请的大块内存中分配，从而减少系统调用的次数。通过brk控制下图1中狭义的Heap Segment区域扩大或缩小，其作为主线程的堆内存由内存管理器管理。对于其它线程则是通过mmap在Memory Mapping Segment区域申请内存块使用，从而减少多线程共享内存块。所以内存管理器的难点就是合理化利用从操作系统申请的一大块内存，在用户malloc申请内存时能及时找到满足用户申请大小的内存返回给用户；在用户free释放内存能合理的管理这些被释放的内存块，比方说合并相连的内存块减少内存碎片。 Linux内存布局 对于ptmalloc有如下一些数据结构： Arena 用于管理向操作系统申请的内存块，分为主线程的main arena和线程的thread arena。main arena是通过brk系统调用在空间用尽时可以拓展，而thread arena无拓展能力，所以可能会管理多个内存块。内存块在ptmalloc中用struct heap_info作为header保存元信息。arena使用struct malloc_state作为header保存元信息。 另外对于一些用户线程数量高于cpu核数，每个线程分配一个arena开销过大，所以thread arena其实是受限于cpu核数，总之不是一个线程就对应一个arena。 Chunk 用于管理分配给用户的内存块，主要有Allocated chunk已经分配给用户的内存块和Free chunk用户释放的内存块。其header数据结构称为malloc_chunk。 Allocated chunck已经分配给用户的内存块 Allocated chunk已经分配给用户的内存块 其中左方第一个箭头chunk表示起始地址，mem表示分配给用户的起始地址，next_chunk为下一个chunk的起始地址同时也是分配给用户的结束地址。This chunk size是分配的size大小，其有对齐的需求，所以后三位都为0,为了节省空间，将其利用放入三个标志位。N表示该chunk是否为thread chunk，M表示是否是mmap分配的chunk。P表示前一个chunk是否被分配。 Free chunck free chunk已经分配给用户的内存块 比起Allocated chunck增加了两个指针，指向同一个bin中前后的free chunk。bin就是用来管理free chunk的数据结构。 可以见得存储前一个chunk的是否分配和分配大小就是为了在释放时检查如果前后的chunk也是free chunk可以进行合并，减少内存碎片。 Bin bin就是用来管理free chunk的数据结构，其包含Fast bin、Unsorted bin、Small bin、Large bin等，已经释放的chunk会根据一些规则放入不同的bin中，设置多个bin主要是满足用户的不同分配内存大小，加快找到合适的free chunk分配给用户。 根据上述的介绍可以了解到，假设用户拿到分配的内存，不小心修改了不是所申请范围的内存，就可能修改到内存分配器存储的一些元信息，在之后的内存管理器执行时造成错误。这也是我们见到程序挂在malloc相关函数中一个可能的原因。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:1:1","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#内存管理器"},{"categories":["troubleshooting"],"content":" 内存损坏(memory corruption)内存损坏通常是对不是自己向内存管理器申请的内存块进行操作，而在大多数情况下对该内存操作对操作系统角度看却是合法的，因为访问的地址是内核分配给进程的空间，所以程序不会马上崩溃，数据被悄悄修改，最后可能会挂在不相关的地方。《高效C/C++调试》2书中写道: 调试内存损坏的真正挑战在于，程序错误时并不能揭示导致错误的有缺陷的代码。通常，程序在有bug的代码做出错误的内存访问时，不会显示任何症状，但是程序中的某个变量意外地被改变为不正确的值。在一些文献中，这被叫作传染。随着程序继续运行，该变量会感染其他变量。这种错误传播最终会发展为严重的失败：程序要么崩溃，要么生成错误的结果。由于导致错误的原因和结果之间的距离很长，崩溃时的变量和执行代码与实际错误往往没有关联，而且在时间和位置方面可能会表现出很多随机性。 所以如果程序崩溃在错误代码运行时，那问题就很好debug。对于更“高级”的语言像java/python有越界检查和垃圾回收gc机制基本可以做到程序崩溃的地方就是错误代码运行的地方，而对于C/C++就不一定了，当然也不用为越界检查和gc付出“代价”。参考《高效C/C++调试》堆内存损坏的常见几种类型，如下: 内存溢出和下溢 用户代码访问超出内存管理器分配的内存(溢出)或者访问可用内存之前的内存块(下溢)。可能会损坏堆元数据结构，导致下一个块被释放或者分配时产生未定义行为。而且也不一定会内存损坏，因为内存块有最小块大小和对齐的要求，可能实际分配给用户的内存大于用户请求大小，破坏的可能是填充的内存，就不会有影响。 操作已经释放的内存 另一种情况是操作已经释放的内存，当用户操作空悬指针或引用时会造成内存损坏，同样症状因许多因素而异，例如，访问的内存已经还给内核，则程序因非法地址访问直接崩溃；释放的内存可能再一次分配给用户，从而导致数据对象被意外破坏；如果内存被内存管理器缓存，修改其可能会破坏堆元数据。 使用未初始化的值 对于未初始化的变量具有随机不可确定的值，如果是恰巧是以前变量留下的野指针，一旦使用也会造成内存损坏。不过此类问题通过代码静态检查一般就可以发现，很好避免。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:1:2","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#内存损坏memory-corruption"},{"categories":["troubleshooting"],"content":" 内存调试工具根据《高效C/C++调试》书中所写，内存调试工具的大致可以分为3中类型: 填充字节方法 在每个分配的内存块开头和结尾添加额外的填充字节，内存溢出和下溢的代码就会修改填充字节，调试工具可以在内存分配api的入口(malloc和free函数)检查这些填充字节，如果发生填充字节被修改，就表示发生了内存损坏，报告错误的堆栈等信息。 系统保护页方法 在可能内存块前后设置不可访问的系统保护页，程序试图非法访问受保护的内存时，马上就会停止执行程序，因此可以找到具体越界的代码。但是，频繁地设置系统保护页会调用系统调用(linux下mprotect函数)有一定的时间消耗，有可能会改变程序的行为，使问题无法复现。 影子内存方法 在内部使用影子内存来跟踪程序的内存使用情况，每次内存访问都会更新影子内存，发生错误时，可以立即发现，但是对程序的性能影响较大。Valgrind的memcheck工具和asan都属于这一类型，平均性能损耗分别是10～20和2倍左右。 如下图，目前主流的内存检测工具对比。图来自《高效C/C++调试》，其中AccuTrak是该书作者开发的工具也加入了对比。 内存检测工具对比 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:1:3","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#内存调试工具"},{"categories":["troubleshooting"],"content":" 问题排查软件是运行在arm板子有操作系统的车端状态机模块。该问题有稳定复现的方法，虽然需要几个小时才能复现。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:2:0","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#问题排查"},{"categories":["troubleshooting"],"content":" coredump分析此版本coredump的堆栈不固定，一般最后都挂在malloc_consolidate函数中。从最后一条指令看出x19寄存器存储的指针高4字节被修改为0xffffffff，通过堆上前后数据特征，可以确定真正合法的地址是0x7f2c000c40被篡改为0xffffffff 2c000c40。 coredump bt 而在之前的版本中，coredump多是在另一个地方，堆上对象虚表指针的高4位被修改为0xffffffff。 pre_coredump bt debug之前的版本的coredump时，曾经在对象操作前后打印其虚表指针，明确看到其在执行完某个rpc操作后指针被篡改，当时一直怀疑的点是rpc操作中操作堆内存溢出，修改了虚表指针。在之前版本中着急发版没有找到根因，通过改写避开了coredump堆栈的代码。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:2:1","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#coredump分析"},{"categories":["troubleshooting"],"content":" 分析过程最初通过coredump的分析主要猜测原因是内存溢出。分析多个coredump时，尽管对比了被篡改数据前后的内存值，并未发现多个coredump有明显一致性的值。使用了MALLOC_CHECK、Valgrind/Memcheck工具和自制的两个内存检测工具，但都未找到问题所在。由于在编译SDK不支持，未使用asan工具。为了进一步排查问题，采用了“笨”办法，一点点注释怀疑的代码并尝试复现。 然而，最终通过自制的内存越界检测工具未能复现coredump的现象，因此认为不太可能是内存溢出修改导致的问题。经过一夜的思考，我想到了另一种可能性：多线程共享变量。如果一个线程在析构时，另一个线程还在使用这些变量，就可能导致coredump。最后，在注释了几个线程的启动后，通过代码review发现项目中存在这种竞态条件，导致操作已经释放的内存，并将其修改为-1（0xffffffff）。写了一个小demo模拟，可以复现这个问题。通过自制的堆数据释放后使用的内存检测工具也检测出了问题。 通过修改此处的代码，经过两天的压测，问题未再复现。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:2:2","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#分析过程"},{"categories":["troubleshooting"],"content":" 问题原因原因简单讲就是对ros::Timer对象，在timer回调线程中调用其stop方法，另一个线程在某些条件下会销毁该对象。即 c++ // thread 1 timer = n.createTimer(ros::Duration(1), std::bind(\u0026TimerTester::fun1, this)); // thread 2 timer.stop(); 在thread 1中对栈上timer重新赋值，会将之前的timer销毁。虽然timer是栈上变量，但其内部申请了堆内存。其stop函数实现如下，其中正好有赋值-1，并且也能看出stop函数并不是线程安全的。 c++ void Timer::Impl::stop() { if (started_) { started_ = false; TimerManager\u003cTime, Duration, TimerEvent\u003e::global().remove(timer_handle_); // line6 timer_handle_ = -1; } } 同事提出一个问题，即在timer销毁时也会调用stop函数，从代码和实际测试中能发现，stop函数在回调线程外部调用时如果回调函数正在执行会阻塞在line6等回调函数执行完毕。而stop函数在回调线程内部调用则不会阻塞等待(否则会产生死锁，ros内部通过tls线程局部存储变量判断是否在回调线程调用stop函数)。问题就是thread 1申请的内存释放前会调用stop函数，如果stop函数需要等待回调函数执行完成，则会等待thread 2执行完stop函数并且退出回调函数后才会释放内存，也就不会出现内存释放后使用的问题。 答案也很简单，由于stop不是线程安全的，所以完全可能thread 2执行stop把started设置为false，之后thread 1释放内存前调用stop由于started为false跳过阻塞等待直接执行完毕释放内存。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:2:3","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#问题原因"},{"categories":["troubleshooting"],"content":" 自制内存检查工具本人在这次问题排查过程中，开发了两个内存检查工具，虽未用其查明根因，但在验证问题还是起到一定作用。两个内存检测工具都是通过LD_PRELOAD环境变量注入自己实现的malloc和free函数，在两个函数中进行一些检查，从而在用户使用有问题的地方能打印出堆栈提醒用户。并且工具实现较简单不会对程序有大幅影响，导致问题可能不复现。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:3:0","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#自制内存检查工具"},{"categories":["troubleshooting"],"content":" 代码注入方法总结对于代码注入在《高效C/C++调试》2介绍了如下几种方法： 链接时替换 在生成可执行文件或共享库时，连接器发现如果存在多个实现与未定义的符号，会选择在搜索列表中最先找到的实现。所以可以将代理函数放在最前面，使链接器优先选择该函数。这种方式需要重新编译，对于未重新编译的第三方库来说注入就不会成功。 例如将自己实现的malloc、free、realloc等函数编译到目标文件my_malloc.o中，然后链接时将其放入其他目标文件之前，执行类似如下的命令： shell g++ my_malloc.o other_object_files -o target 预先加载函数 在运行时，系统加载器将读取环境变量LD_PRELOAD预加载环境变量制定的动态链接库，但链接器尝试解析未定义的符号时，会优先使用库中的函数。该方法无需对程序重新编译。 修改导入和导出表 运行时需要动态链接的函数时通过程序链接表PLT进行路由的，会在第一次调用进行符号解析找到函数对应的GOT表项中的函数地址，设置PLT表项跳转指令为GOT表项中的函数地址。我们可以通过修改GOT表项为代理函数，从而注入检查代码。每个so模块都有自己的GOT表所以需要对每个模块都进行修补，也可以进行细粒度的控制选择某些模块修补。 对目标函数进行手术改变 还有一种更具有侵入性的方式，修改目标函数的代码，通常不是直接覆写原始代码(由于原始代码空间较短无足够的空间容纳新代码)，而是在函数开始时注入跳转指令，将其设置为代理函数的地址。该方法可以注入不是动态链接的函数。另外原始函数在.text段通常为可读的需要将内存保护模式从只读修改为科协，插入跳转指令后，再将函数的内存页面保护模式恢复成只读。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:3:1","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#代码注入方法总结"},{"categories":["troubleshooting"],"content":" 堆数据越界 原理 代码地址: 通过自定义的malloc和free等函数，在申请内存时内存块上下多申请几个字节并且放入魔数，在free时对上下魔数进行校验，如果发现被修改，则说明该释放数据在使用时出现了溢出情况，同时打印释放时的堆栈，以便提醒用户检查释放数据在之前的使用时有溢出的发生。 实例 对如下错误代码可以有效检测出来。 c++ #include \u003ciostream\u003e using namespace std; int main(){ int *a = new(int); a[2] = 10; delete a; } 缺点 由于只在释放时才会进行检查，所以对于一直运行的程序在其整个生命周期都存在的堆数据，只能使用ctrl+c提前结束程序才能触发检测。 使用mmap真实分配内存。所以分配内存的性能不如原始的ptmalloc，这一点可以进行优化。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:3:2","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#堆数据越界"},{"categories":["troubleshooting"],"content":" 堆数据释放后使用 原理 代码地址: 通过对用户调用free释放的内存块进行魔数填充，在一段时间后在去检查该魔数是否被修改，再还给操作系统。以此来检测是否用户存在释放后的内存块还在修改其内容。实现细节如下： 使用__attribute__((constructor))在该工具so被加载时执行一些准备工作 使用dlsym(RTLD_NEXT, \"malloc\")找到原始的malloc函数，内存实际的分配其实是转发给原始的malloc函数。 在用户调用malloc时保存其调用堆栈放入队列中，用户free时将内存块填充为魔数，并且检查队列是否满了，如果满了就取队头进行魔数校验，然后调用原始的free释放。如果魔数被修改则打印之前保存的申请时堆栈，调用terminate()生成coredump。 工具在检测到魔数被修改时，会打印申请内存块时的堆栈。 实例 对如下错误代码可以有效检测出来。 c++ #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cchrono\u003e using namespace std; void func() { uint i = 0; while (true) { int *a = new (int); a[0] = 0; delete a; if (i == 10) { a[0] = i; } ++i; } } int main() { std::thread t1(func); t1.join(); } 缺点 由于__attribute__((constructor))会在so被加载时执行，如果用户程序含有popen、system等新建进程时也会在该进程中执行一遍，所以可能会打印多次初始化的日志。 虽然对性能影响很小，但是也可能导致某些多线程原因导致释放后修改触发的概率减小。 ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:3:3","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#堆数据释放后使用"},{"categories":["troubleshooting"],"content":" 参考 理解 glibc malloc：主流用户态内存分配器实现原理 ↩︎ 《高效C/C++调试》 ↩︎ ↩︎ ","date":"2024-05-12","objectID":"/posts/troubleshooting_data_races_coredump/:4:0","series":null,"tags":["C++","data races","memory corruption"],"title":"记一次数据竞争导致内存损坏的coredump - 问题诊断","uri":"/posts/troubleshooting_data_races_coredump/#参考"},{"categories":["这都不知道"],"content":"最近发现我竟然不知道或理解错误的系统知识，包含Linux系统时区设置、coredump文件命名的问题。 ","date":"2023-12-17","objectID":"/posts/dont-even-know-that_system/:0:0","series":null,"tags":["C++","系统编程"],"title":"一些我竟然不知道的系统相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_system/#"},{"categories":["这都不知道"],"content":" 这都不知道","date":"2023-12-17","objectID":"/posts/dont-even-know-that_system/:1:0","series":null,"tags":["C++","系统编程"],"title":"一些我竟然不知道的系统相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_system/#这都不知道"},{"categories":["这都不知道"],"content":" Linux系统时区设置设置Linux时区主要有两种方法，来源与man 5 localtime 设置/etc/localtime文件链接到/usr/share/zoneinfo目录下对应时区文件 shell $ ll /etc/localtime lrwxrwxrwx 1 root root /etc/localtime -\u003e /usr/share/zoneinfo/Asia/Shanghai 此为系统级别的修改，其文件格式可通过man 5 tzfile查看。timedatectl命令就是对该文件进行修改从而达成修改时区的目的。 设置环境变量TZ 设置环境变量TZ可对上述文件设置的时区进行覆盖，一般应用于临时设置，而不作为系统级别的设置。 shell export TZ='Asia/Shanghai' ","date":"2023-12-17","objectID":"/posts/dont-even-know-that_system/:1:1","series":null,"tags":["C++","系统编程"],"title":"一些我竟然不知道的系统相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_system/#linux系统时区设置"},{"categories":["这都不知道"],"content":" coredump文件命名问题一般情况下我们的软件都会打开coredump功能，在程序崩溃时将终止时的内存映像保存为文件即coredump，可以使用gdb等工具分析崩溃时程序执行的语句和运行数据。该coredump文件生成的文件名一般配置成包含可执行文件名，这样就可以从coredump文件名就可以知道是哪个程序产生的，从而方便用gdb加载可执行文件。 但在实际工作中，曾多次遇到coredump文件名中可执行文件的名变成其它名称，例如thread_pool等，而不是原本的可执行文件名。这种coredump实际使用gdb打开其实可以看到实际产生的进程名core was generated by /path/your_bin。这个疑点一直埋藏心中。 这次频繁遇到该问题，仔细分析发现是由于日志库的线程设置了线程名称，导致如果该线程收到异常信号生成coredump时，文件命名使用该线程的名称而不是默认的可执行文件名。 设置和获取线程名称的系统调用prctl()如下: c #include \u003clinux/prctl.h\u003e /* Definition of PR_* constants */ #include \u003csys/prctl.h\u003e int prctl(PR_SET_NAME, char name[16]); int prctl(PR_GET_NAME, const char name[16]); 使用ChatGPT写个测试程序来验证下。首先设置coredump的路径和pattern。 shell sudo sysctl -w kernel.core_pattern=\"/tmp/core_%e_%p_%t\" 下表1为/proc/sys/kernel/core_pattern的说明符，在实际生成coredump时就会替代为对应的值。其中%e就是会被替换成崩溃线程的线程名称。 说明符 替代为 %c 对核心文件大小的资源软限制（字节数；始于 Linux 2.6.24） %e 可执行文件名（不含路径前缀），准确说是线程名称，线程名称默认是可执行文件名 %g 遭转储进程的实际组 ID %h 主机系统的名称 %p 遭转储进程的进程 ID %s 导致进程终止的信号编号 %t 转储时间，始于 Epoch，以秒为单位 %u 遭转储进程的实际用户 ID %% 单个 % 字符 编写如下程序，在创建的线程中打印当前线程名然后设置线程名为TestThread，之后调用raise()触发崩溃产生coredump。 c++ #include \u003ciostream\u003e #include \u003cpthread.h\u003e #include \u003csys/prctl.h\u003e #include \u003ccsignal\u003e #include \u003cunistd.h\u003e // 线程函数 void* threadFunc(void* arg) { char threadName[16]; prctl(PR_GET_NAME, threadName); std::cout \u003c\u003c \"Thread name is: \" \u003c\u003c threadName \u003c\u003c std::endl; // 设置线程名称 prctl(PR_SET_NAME, \"TestThread\"); // 打印线程名称 prctl(PR_GET_NAME, threadName); std::cout \u003c\u003c \"Thread name set to: \" \u003c\u003c threadName \u003c\u003c std::endl; // 故意引发崩溃 raise(SIGSEGV); // 发送 SIGSEGV 信号引发段错误 return nullptr; } int main() { pthread_t thread; // 创建线程 if (pthread_create(\u0026thread, nullptr, threadFunc, nullptr) != 0) { std::cerr \u003c\u003c \"Failed to create thread\" \u003c\u003c std::endl; return 1; } // 等待线程完成 pthread_join(thread, nullptr); // raise(SIGSEGV); // 发送 SIGSEGV 信号引发段错误 return 0; } 最后编译并运行。 shell $ g++ test_pr_set_name.cc -o test_pr_set_name -lpthread $ ulimit -c unlimited \u0026\u0026 ./test_pr_set_name Thread name is: test_pr_set_nam Thread name set to: TestThread [1] 13480 segmentation fault (core dumped) ./test_pr_set_name 最后产生的coredump名称为core_TestThread_10757_1724462863，可以看到%e被替换成了设置的线程名称TestThread。而如果将raise放在主线程中执行，则会产生core_test_pr_set_nam_18496_1724463124名称的coredump，原因也很好理解，主线程没有设置线程名称，所以是默认的test_pr_set_nam可执行文件名。而且也说明了线程名最长为15byte+1byte(\\0)。 ","date":"2023-12-17","objectID":"/posts/dont-even-know-that_system/:1:2","series":null,"tags":["C++","系统编程"],"title":"一些我竟然不知道的系统相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_system/#coredump文件命名问题"},{"categories":["这都不知道"],"content":" 参考 《Linux/UNIX系统编程手册》 ↩︎ ","date":"2023-12-17","objectID":"/posts/dont-even-know-that_system/:2:0","series":null,"tags":["C++","系统编程"],"title":"一些我竟然不知道的系统相关知识 - 这都不知道「持续更新」","uri":"/posts/dont-even-know-that_system/#参考"},{"categories":["troubleshooting"],"content":"记录下最近遇到的一些问题: popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败、tar压缩中返回short read生成破损的压缩包、getifaddrs返回ifa_addr可能为空。 ","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:0:0","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#"},{"categories":["troubleshooting"],"content":" 问题列表","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:1:0","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#问题列表"},{"categories":["troubleshooting"],"content":" popen后台符号\u0026导致僵尸进程下面是popen执行shell命令获取命令输出打印到屏幕上的小例子 c++ #include \u003climits.h\u003e #include \u003costream\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char *argv[]) { string files; char buf[PIPE_BUF]; for (int i = 1; i \u003c argc; i++) { files += string(argv[i]) + \" \"; } string cmd = files; std::cout \u003c\u003c cmd \u003c\u003c std::endl; FILE *fp = popen(cmd.c_str(), \"r\"); if (fp == NULL) { perror(\"popen\"); exit(1); } while (fgets(buf, sizeof(buf), fp) != NULL) { std::cout \u003c\u003c buf; std::flush(std::cout); } pclose(fp); } 在车端发现了很多个僵尸进程zomble，排查发现是分别由两个原因导致出现僵尸进程： 忘记调用pclose函数关闭popen打开的fd导致popen打开的进程未被父进程回收。 在popen的命令结尾加\u0026后台运行符号，即类似popen(\"sleep 60s \u0026\", \"r\"); 第一种情况很好理解，第二种情况完全解释清楚需要很强的系统知识，目前我所不具备。 大概来讲，popen会先fork新进程执行/bin/sh -c 提供的命令，而/bin/sh也会新建个进程执行用户指定的命令。当然其中也涉及到一些管道的操作用于拿到命令输出或者设置命令的输入。 如果在命令后边加上\u0026的符号则/bin/sh进程会不等执行的命令而直接结束，此时如果命令还未执行完毕，则/bin/sh进程不会被父进程调用wait函数拿到其退出返回值，从而导致/bin/sh成为僵尸进程。 不过该僵尸进程在用户命令结束时也会跟着被回收，所以不会出现僵尸进程导致pid用尽的情况，不过在代码中最好要避免这种写法。 2024.06.26 在写另一篇文章从音频播放C++类的实现学习Linux系统子进程管理中想到这个问题，基本确认了上述的想法。并且由于用户命令在执行中不会关闭pipe管道，所以fgets会阻塞等待用户命令的输出不能调用pclose，此时/bin/sh成为僵尸进程。 ","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:1:1","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#popen后台符号导致僵尸进程"},{"categories":["troubleshooting"],"content":" 空间未满却新建不了文件一般车端都需要日志滚删的功能，从而不至于让日志写满磁盘，该功能的实现，一般很自然想到当剩余空间小于某个阈值时，进行日志文件的删除动作，删除按照文件修改时间由小到大，直到空间满足要求。 不过，这次遇到了问题是使用df -h查看磁盘空间未满，但是新建文件时又会报No space left on device类似的错误。 搜索发现可能的原因是文件过多，inode用尽导致的。一般完整的命令行可以直接使用df -i查看文件系统inode的使用情况，如下所示 shell Filesystem Inodes IUsed IFree IUse% Mounted on /dev/nvme0n1p4 25493504 965653 24527851 4% / 当IUse%达到100%时，此时新建文件则会报错。在我的笔记本上该值有2千万之多，不过在车端上只有30万左右，当出现一些异常情况下是有可能inode用尽。 在车端板子上df命令为阉割版本，不支持-i参数，无法查看inode使用情况，需要写个小程序调用statvfs系统api获取。在文档可以看到该函数的说明。写个如下小程序在车端运行就可以获取到inode使用情况。 c++ #include \u003csys/statvfs.h\u003e #include \u003csys/statvfs.h\u003e #include \u003ccstdio\u003e #include \u003ciostream\u003e using namespace std; int main(int argc, char **argv) { struct statvfs fs; if (statvfs(argv[1], \u0026fs) == 0) { cout \u003c\u003c \"f_bsize: \" \u003c\u003c fs.f_bsize \u003c\u003c \", f_frsize: \" \u003c\u003c fs.f_frsize \u003c\u003c \", f_blocks: \" \u003c\u003c fs.f_blocks \u003c\u003c \", f_bfree: \" \u003c\u003c fs.f_bfree \u003c\u003c \", f_bavail: \" \u003c\u003c fs.f_bavail \u003c\u003c endl; cout \u003c\u003c \"f_files: \" \u003c\u003c fs.f_files \u003c\u003c \", f_ffree: \" \u003c\u003c fs.f_ffree \u003c\u003c \", f_favail: \" \u003c\u003c fs.f_favail \u003c\u003c endl; cout \u003c\u003c \"f_fsid: \" \u003c\u003c fs.f_fsid \u003c\u003c \", f_flag\" \u003c\u003c fs.f_flag \u003c\u003c \", f_namemax\" \u003c\u003c fs.f_namemax \u003c\u003c endl; } else { perror(\"statvfs\"); } } 主要看f_files和f_ffree两个字段即可。果不其然，确实是板子上的文件数量过多，超过inode的限制导致的该问题。 接下来就是找到是那个模块文件数量过多，使用如下命令，可以统计当前路径下的目录含有的文件数量 shell find . -type f | cut -d \"/\" -f 2 | sort | uniq -c | sort -nr 通过该命令就可以找到那个模块文件数量过多，再去分析数量过多的原因。 同时，也说明日志滚删的功能不光需要对文件大小作出限制，同时也应该对文件个数进行限制，防止文件过多inode用尽。 ","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:1:2","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#空间未满却新建不了文件"},{"categories":["troubleshooting"],"content":" tar压缩中返回short read生成破损的压缩包工作中我负责的模块会将车端上其它模块的日志打包上传到云端，使用的是popen执行tar -zcf upload.tar.gz files命令进行打包解压。注意该命令是分为两个步骤，首先是打包：将files文件打包成一个tar文件，最后是压缩：将打包好的tar文件进行gzip算法的压缩生成最终的压缩文件。 本次遇到的问题就是在打包过程中返回short read错误从而终止打包，直接进入压缩步骤，从而导致在解压后将tar还原成各个文件时报错，当然在错误发生之前打包的文件还在。 最后通过google和实验确定是在打包过程中，当前正在被打包的文件大小缩小，就会导致报该错误。通过用vim查看打包进tar文件的标头，发现报错的打包文件名，该文件可能会缩小文件size（有程序会执行覆盖重定向\u003e该文件），所以可以确定该问题发生的原因。由于发生该错误的概率较小，所以解决办法就是遇到该报错时重试。 该问题让我学习到了tar文件的结构，其结构非常简单，即又多个File entry组成表示不同文件，每个file entry由头部和实际文件数据组成。头部的数据结构如下： c /* Source: https://www.gnu.org/software/tar/manual/html_node/Standard.html */ /* tar Header Block, from POSIX 1003.1-1990. */ /* POSIX header. */ struct posix_header { /* byte offset */ char name[100]; /* 0 */ char mode[8]; /* 100 */ char uid[8]; /* 108 */ char gid[8]; /* 116 */ char size[12]; /* 124 */ char mtime[12]; /* 136 */ char chksum[8]; /* 148 */ char typeflag; /* 156 */ char linkname[100]; /* 157 */ char magic[6]; /* 257 */ char version[2]; /* 263 */ char uname[32]; /* 265 */ char gname[32]; /* 297 */ char devmajor[8]; /* 329 */ char devminor[8]; /* 337 */ char prefix[155]; /* 345 */ /* 500 */ }; 其比较重要的是size表示文件的数据的大小，特别的是存储为ASCII码的八进制表示。字段都是对齐512字节，用0 padding。该格式看起来是个很有历史的格式。 该问题也衍生出一个思考，对于被打包的文件在打包过程中被删除或被移动会影响到打包压缩吗？ 答案是不会，首先文件一旦被打开，其即使被删除也会等到打开该文件的最后一个进程被关闭时才会真的删除磁盘文件，所以删除不会有影响。而文件一旦被打开，其就是用inode作为文件标识而不是文件名字，文件被移动是不会改变inode的值，而只是变动存储该inode的目录文件，所以移动也不会有影响。 ","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:1:3","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#tar压缩中返回short-read生成破损的压缩包"},{"categories":["troubleshooting"],"content":" getifaddrs返回ifa_addr可能为空在工作项目中使用getifaddrs函数获取网卡信息，返回如下数据结构: c struct ifaddrs { struct ifaddrs *ifa_next; /* Next item in list */ char *ifa_name; /* Name of interface */ unsigned int ifa_flags; /* Flags from SIOCGIFFLAGS */ struct sockaddr *ifa_addr; /* Address of interface */ struct sockaddr *ifa_netmask; /* Netmask of interface */ union { struct sockaddr *ifu_broadaddr; /* Broadcast address of interface */ struct sockaddr *ifu_dstaddr; /* Point-to-point destination address */ } ifa_ifu; #define ifa_broadaddr ifa_ifu.ifu_broadaddr #define ifa_dstaddr ifa_ifu.ifu_dstaddr void *ifa_data; /* Address-specific data */ }; 可以看到返回的是一个链表,可以通过其ifa_flags，如下判断某个wifi网卡(通过ifa_name区分)其是否连接到路由器 c (ifa-\u003eifa_flags \u0026 IFF_UP) \u0026\u0026 (ifa-\u003eifa_flags \u0026 IFF_RUNNING) 但是当时测试时发现同一个网卡会分别返回两次，ifa_addr-\u003esa_family分别是AF_INET和AF_INET6即ipv4和ipv6.。由于我的目的仅仅判断wifi是否连接路由器，所以我对AF_INET6进行过滤，防止出现同一个网卡判断两遍结果出现不一致的情况。 需要特别注意其中ifa_addr和ifa_netmask可能为NULL，所以在调用ifa_addr-\u003esa_family之前必须要判断ifa_addr是否为空指针，否则就会和我一样悲剧了。 The ifa_addr field points to a structure containing the interface address. (The sa_family subfield should be consulted to determine the format of the address structure.) This field may contain a null pointer. The ifa_netmask field points to a structure containing the netmask associated with ifa_addr, if applicable for the address family. This field may contain a null pointer. 而什么情况下ifa_addr会为空指针呢，通过网上搜索到的文章大概了解到类似虚拟网卡(隧道)就可能返回空指针，具体的情况还有待深入的学习。 ","date":"2023-12-04","objectID":"/posts/troubleshooting_guide_1/:1:4","series":null,"tags":["shell","系统编程"],"title":"问题诊断系列「1」popen后台符号\u0026导致僵尸进程、空间未满却新建文件失败等","uri":"/posts/troubleshooting_guide_1/#getifaddrs返回ifa_addr可能为空"},{"categories":["实践到理论"],"content":"本文是从git对象存储模型出发搞懂git常用命令的原理，主要参考了《Git权威指南》1和网上的一些文章234。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:0:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#"},{"categories":["实践到理论"],"content":" 基础知识","date":"2023-10-02","objectID":"/posts/git_in_detail/:1:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#基础知识"},{"categories":["实践到理论"],"content":" .git下对象存储模型众所周知，一个使用git管理的代码库，其commit历史等信息是存储在隐藏目录.git下面，如果要了解git常用命令的原理从这个文件夹的结构和内容讲起比较合适。 1. git对象存储模型 上图1中展示了commit提交是如何保存在.git目录下(图中对实际中40个十六进制commit id、tree id、blob id简化成type_id_n的形式): git对象库 存储在.git/objects目录下(id的前两位作为目录名，后38位作为文件名)存储，主要是有commit、tree、blob类型组成，其对应的内容如下: blob(binary large object)类型: 文件，存储了使用gzip压缩后的文件内容和实际大小。在git管理的文件都以该类型保存，如何使用脚本解压后查看blob文件内容2。同时也说明git存储的是文件的快照而非diff3。 tree类型: 目录树，存储了*个blob类型的id及对应的文件名权限等，和*个tree类型的id及对应的文件夹名称权限等。其保存了文件目录将blob表示的文件串起来。blob和tree类型有些类似inode和目录文件，文件名等信息实际存储在tree中。 commit: 提交，存储了tree id和一个或多个parent提交的id及一些commit msg等信息。对于merge消息就会产生多个parent提交id。 以上对象库对象内容及其类型可通过如下命令查看: shell $git cat-file -t 7c16725a3529a00feecfb81ecb6ecedaef2fa60c # 查看id类型 commit $git cat-file -p 7c16725a3529a00feecfb81ecb6ecedaef2fa60c # 查看id内容 tree 0e9755249e11e845e99ffd46f43056e869eb50e7 parent 6fd19369e33bb37bdf1fb06debe44d634b287dd1 parent ad7b317c479c01e593593b573752e4ac9b1509fd author ImportMengjie \u003cmengjie@hotmail.com\u003e 1696338677 +0800 committer ImportMengjie \u003cmengjie@hotmail.com\u003e 1696338677 +0800 Merge branch 'bB' HEAD和refs/heads/master 实际都是存储在.git目录下的文本文件: refs/heads/master: 存储了master分支当前的commit id。 HEAD: 存储了当前checkout的commit id或分支。 git历史提交的表示~和^git提交列表是一个多叉树结构，其每个commit节点保存有一个或多个父commit节点，对当前commit节点的多个父节点或祖宗节点git有很方便的表示方式，可以用在git checkout和git reset等命令中。 commit_id~: 表示当前提交的父提交，如果有多个父提交选择第一个父提交；可以使用commit_id~~或commit_id~2方式表示父父提交等方式 commit_id^: 同样表示当前提交的父提交，和~波浪号的区别在于当提交含有多个父提交时可以通过commit_id^2方式表示第二个父提交 commit_id当然可以是分支名或者HEAD，因为其背后都引用某个commit_id，常用的一种是git checkout HEAD^checkout到当前提交的第一个父提交。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:1:1","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git下对象存储模型"},{"categories":["实践到理论"],"content":" .git下对象存储模型众所周知，一个使用git管理的代码库，其commit历史等信息是存储在隐藏目录.git下面，如果要了解git常用命令的原理从这个文件夹的结构和内容讲起比较合适。 1. git对象存储模型 上图1中展示了commit提交是如何保存在.git目录下(图中对实际中40个十六进制commit id、tree id、blob id简化成type_id_n的形式): git对象库 存储在.git/objects目录下(id的前两位作为目录名，后38位作为文件名)存储，主要是有commit、tree、blob类型组成，其对应的内容如下: blob(binary large object)类型: 文件，存储了使用gzip压缩后的文件内容和实际大小。在git管理的文件都以该类型保存，如何使用脚本解压后查看blob文件内容2。同时也说明git存储的是文件的快照而非diff3。 tree类型: 目录树，存储了*个blob类型的id及对应的文件名权限等，和*个tree类型的id及对应的文件夹名称权限等。其保存了文件目录将blob表示的文件串起来。blob和tree类型有些类似inode和目录文件，文件名等信息实际存储在tree中。 commit: 提交，存储了tree id和一个或多个parent提交的id及一些commit msg等信息。对于merge消息就会产生多个parent提交id。 以上对象库对象内容及其类型可通过如下命令查看: shell $git cat-file -t 7c16725a3529a00feecfb81ecb6ecedaef2fa60c # 查看id类型 commit $git cat-file -p 7c16725a3529a00feecfb81ecb6ecedaef2fa60c # 查看id内容 tree 0e9755249e11e845e99ffd46f43056e869eb50e7 parent 6fd19369e33bb37bdf1fb06debe44d634b287dd1 parent ad7b317c479c01e593593b573752e4ac9b1509fd author ImportMengjie 1696338677 +0800 committer ImportMengjie 1696338677 +0800 Merge branch 'bB' HEAD和refs/heads/master 实际都是存储在.git目录下的文本文件: refs/heads/master: 存储了master分支当前的commit id。 HEAD: 存储了当前checkout的commit id或分支。 git历史提交的表示~和^git提交列表是一个多叉树结构，其每个commit节点保存有一个或多个父commit节点，对当前commit节点的多个父节点或祖宗节点git有很方便的表示方式，可以用在git checkout和git reset等命令中。 commit_id~: 表示当前提交的父提交，如果有多个父提交选择第一个父提交；可以使用commit_id~~或commit_id~2方式表示父父提交等方式 commit_id^: 同样表示当前提交的父提交，和~波浪号的区别在于当提交含有多个父提交时可以通过commit_id^2方式表示第二个父提交 commit_id当然可以是分支名或者HEAD，因为其背后都引用某个commit_id，常用的一种是git checkout HEAD^checkout到当前提交的第一个父提交。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:1:1","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git历史提交的表示和"},{"categories":["实践到理论"],"content":" 工作区、暂存区、HEAD中的目录树(tree)git中有三个重要的目录树即: 工作区、暂存区和当前commit(HEAD)中的目录树。 工作区目录树 即为当前文件系统的目录树，不包含未被git跟踪的文件(Untracked files)。 暂存区目录树 存储在.git/index文件内，使用git commit之前调用git add就是增加文件在暂存区目录树中。需要调用git write-tree可以将暂存区目录树写入并且返回其tree id。可以理解git commit会先调用git write-tree写入目录树并将其id保存在commit的tree id。 当前commit(HEAD)中的目录树 即当前HEAD文件中保存的commit id或者引用的分支指向的commit id中保存的tree id指向的目录树。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:1:2","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#工作区暂存区head中的目录树tree"},{"categories":["实践到理论"],"content":" git diffgit diff命令可以对两个目录树内的文件对比差异，实际工作中我们一般对比工作区、暂存区、HEAD中的目录树两两之间比较差异。 2. git diff命令 上图2中展示git diff常用参数: git diff id_2 id_3是对id_2和id_3指向的目录树对比 git diff是对暂存区和工作区目录树对比 git diff --cache是对HEAD和暂存区目录树对比 git diff HEAD是对HEAD和工作区目录树对比 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:2:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git-diff"},{"categories":["实践到理论"],"content":" git checkoutgit checkout命令会对工作区和暂存区目录树进行检出，即会对工作区和暂存区替换。主要有如下三种用法: git checkout \u003ccommit_id\u003e 3. git checkout commit_id命令 checkout最常用的命令就是切换分支(commit_id)，如上图3中所示，checkout命令会将暂存区和工作区替换成commit_id所指向的目录树。同时设置HEAD为commit_id。 git checkout -可以很方便的切回之前的commit(分支)，类似于cd -。 git checkout [\u003ccommit_id\u003e] [--] \u003cpath\u003e 该命令主要是用于将指定commit的目录树中的某些文件覆盖工作区和暂存区的文件，其不会改变HEAD的值，如果省略commit_id则设置为暂存区的目录树。路径前加上–主要是防止路径和引用或者commit id同名造成歧义，如果不冲突则可省略。 该用法最常用的是git checkout .将当前工作区替换暂存区的目录树，此时未add进暂存区的修改都会消失！ git checkout -b \u003cnew_branch\u003e [\u003ccommit_id\u003e] 该命令主要用于新建分支(new_branch)即在/refs/heads/下面增加以新分支命名的文件内容保存着commit_id，然后将HEAD指向新分支。 值得注意该命令不会对工作区和暂存区进行替换。如果后边省略commit_id则设置为HEAD。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:3:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git-checkout"},{"categories":["实践到理论"],"content":" git resetgit reset命令可以将当前分支指向另一个指定提交，并且有选择的替换暂存区和工作区，类似checkout可以对单独文件进行操作。主要有以下两种用法: git reset [--soft|--mixed|--hard] [\u003ccommit_id\u003e] 当HEAD中保存的是分支的引用时此用法会替换分支引用保存的commit_id为用户的设置，这就是该命令和checkout的最大区别同样commit_id如果省略则为HEAD，如下图4所示，有三种参数soft/mixed/hard会设置是否替换暂存区和工作区。 4. git reset [--soft|--mixed|--hard] commit_id命令 git reset --soft id_2只进行master分支指向commit替换而不修改暂存区和工作区，即只执行了图中的①。 对于最新提交的进行修改并且将add进暂存区的修改一并重新提交的命令git commit --amend就是如下两个命令的的组合 shell # 将当前分支指向的提交替换为父提交，不替换暂存区和工作区，所以之前add进暂存区的修改还在 $git reset --soft HEAD^ # .git/COMMIT_EDITMSG保存当前提交的commit_msg，此时之前add进暂存区的修改也在提交中 $git commit -e -F .git/COMMIT_EDITMSG 还有常用的一个用法，即将多个提交修改合并成一个提交，可以执行如下命令将当前提交和其父提交压缩成一个提交: shell $git reset --soft HEAD~2 $git commit -m \"compression commit\" git reset [--mixed] id_2在–soft的基础上还对暂存区进行替换，即图中①和②。默认行为，–mixed可以省略。最常用的命令是将add进暂存区的修改都重置，即git reset，替换暂存区为HEAD指向的目录树，之前add进暂存区的修改都会被重置，而分支的引用替换到HEAD相当于没有替换分支引用。 git reset --hard id_2在–mixed基础上还进行工作区的替换，即图中①、②和③。由于会将工作区进行替换是个比较危险的用法。可以执行类似git reset --hard HEAD^撤销当前commit。 git reset [\u003ccommit_id\u003e] [--] \u003cpath\u003e 该命令不会替换分支引用和工作区的目录树，而是用指定提交下的文件\u003cpath\u003e替换掉暂存区的文件。注意与git checkout [\u003ccommit_id\u003e] [--] \u003cpath\u003e的区别，checkout命令还会覆盖工作区的文件。该命令最常用的用法是git reset filename将filename文件的改动撤出暂存区，相当于git add filename的反向操作。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:4:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git-reset"},{"categories":["实践到理论"],"content":" git cherry-pick该命令特别好理解，就是将一些commit在当前分支提交一次一样的commit。 4. git cherry-pick 如上图4，当前在main分支，执行git cherry-pick F，F为commit_id，会在main分支提交一次一样的commit，但是commit id会不同。可以一次cherry-pick多个commit，以空格分割。当然cherry-pick会将暂存区和工作区替换成pick之后的提交。 如果遇到冲突需要用户解决冲突后执行git cherry-pick --continue或者git cherry-pick --abort终止。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:5:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git-cherry-pick"},{"categories":["实践到理论"],"content":" git rebase该命令是主要用途就是批量的cherry-pick提交，全量的命令格式是git rebase --onto base from to，将from到to“范围”内的提交cherry-pick到base上。 5. git rebase main 上图5是很常用的rebase用法，可以取代merge命令将main分支的新增修改带入到dev分支中并且保持提交线性。git rebase --onto dev main dev命令在当前分支是dev时可以省略为git rebase main就和git merge main类似了。即git rebase from会被展开为git rebase --onto from from HEAD。 结合上图5的命令git rebase --onto main main dev，rebase操作的过程如下: 首先会执行git checkout to切换到to分支，需要注意的是rebase之后HEAD引用的分支是to分支上，如果to不是分支，则会出现detached HEAD状态。在上图5中，会checkout到dev分支上，最终rebase作用到的分支也是dev分支。 将在to分支所有历史提交中但是不在from分支所有历史提交范围的提交列表保存在临时文件中，在加上-i交互模式参数时可以看到提交的列表。在1中对范围的阐释是:包括to的所有历史提交排出from及from的历史提交。在上图5中，这个范围就是在dev分支，但是不在main分支的提交列表: E、F提交。 将当前分支强制重置到base上，相当于执行git reset --hard base。在上图5中，就是git reset --hard main将dev分支指向的提交强制改为main分支指向的提交，即dev分支增加了C、D提交但是少了E、F提交。 从保存在临时文件中的提交列表逐一cherry-pick到重置之后的分支上。如果提交已经在分支中包含则跳过该提交。在上图5中，就是将缺少的E、F提交cherry-pick到dev分支上，此时dev上的修改就基于最新的main分支。 如果cherry-pick过程中遇到冲突，则rebase暂停，用户解决冲突后执行git rebase --continue继续rebase或者git rebase --skip跳过此提交或者git rebase --abort终止rebase，所有改动回滚。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:6:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#git-rebase"},{"categories":["实践到理论"],"content":" rebase小例子🌰 基于不稳定分支上的提交rebase到稳定分支上，例子来源4 6. git rebase 一般化 如上图6中，想将基于next分支提交的topic分支，变基为基于main分支。例如在topic一些feature基于开发分支next测试完成，想将其基于更稳定的分支main上准入测试，就可以执行git rebase --onto main next topic。 将本地修改提交到指定历史commit 该例子是我在实际工作遇到: 在本地提交了多个commit，每个commit中包含不同功能。需要修改某个功能的提交，如果直接新建一个commit肯定比较难看，想优雅的直接修改历史commit。当然如果该提交是最近一次提交，可直接使用git commit --amend修改，如果不是的话就需要rebase命令了。 首先将本地的修改git stash保存 找到要修改的commit id，假设为f744c32。则可在当前分支执行git rebase -i f744c32^即git rebase -i --onto f744c32^ f744c32^ HEAD。在编辑器中找到需要修改的commit id，将前面的pick修改为edit。 此时rebase就会在需要修改的commit上暂停，可以执行git stash pop将需要的修改pop出来，然后git add等命令将修改添加进暂存区，最后执行git commit --amend将修改保存到当前提交中，最终执行git rebase --continue继续rebase命令。 ","date":"2023-10-02","objectID":"/posts/git_in_detail/:6:1","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#rebase小例子"},{"categories":["实践到理论"],"content":" 参考画图有参考图解git 《Git权威指南》 ↩︎ ↩︎ 这才是真正的Git——Git内部原理揭秘！ ↩︎ ↩︎ progit git基础 ↩︎ ↩︎ git-scm ↩︎ ↩︎ ","date":"2023-10-02","objectID":"/posts/git_in_detail/:7:0","series":null,"tags":["git","git对象模型","工具"],"title":"从git对象存储模型理解git常用命令","uri":"/posts/git_in_detail/#参考"},{"categories":["实践到理论"],"content":"本文缘起遇到的shell重定向的先后顺序问题，下定决心搞懂linux下非常常用的重定向原理。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:0:0","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#"},{"categories":["实践到理论"],"content":" 问题缘起在使用shell命令时，重定向是一种方便的将命令执行的结果输出到文件中或者将文件内容输入到命令中，其最常用的用法如下: shell # 输出 ls \u003e output.txt # 1. 将ls命令标准输出重定向到output.txt文件，文件已存在会清空 ls \u003e\u003e output.txt # 2. 将ls命令标准输出重定向到output.txt文件，文件已存在会append ls 2\u003e\u00261 # 3. 将ls命令输出中标准错误(文件描述符2)重定向到标准输出(文件描述符1) ls \u0026\u003e output.txt # 4. 将ls命令标准输出和标准错误输出到output.txt文件 ls \u003e output.txt 2\u003e\u00261 # 5. 和4语义上相同 # 输入 grep search-word \u003cinput.txt # 6. grep输入重定向到input.txt文件 我一直对重定向的理解都是很简单的，即: cmd 1\u003e filename就是将命令的标准输出(fd为1,命令中可省略)输出的目的地从终端屏幕到文件 cmd 2\u003e\u00261就是将命令的标准错误2合并到标准输出1 当设置重定向时，比方说将标准输出1重定向到一个文件中，程序中有一条printf语句，其内部最终会调用write(fd=1, …)而重定向将fd=1替换成文件，就会使该语句从打印到屏幕改为打印到文件。 该简单的理解大部分情况已经够用了，但是难以理解下边重定向的顺序问题，在man bash文档中REDIRECTION小节对重定向的顺序问题的描述，即 Note that the order of redirections is significant. For example, the command ls \u003e dirlist 2\u003e\u00261 directs both standard output and standard error to the file dirlist, while the command ls 2\u003e\u00261 \u003e dirlist directs only the standard output to file dirlist, because the standard error was duplicated from the standard output before the standard output was redirected to dirlist. 该语句想要实现的功能是将命令的标准输出和标准错误都输出到文件之中，想要实现该功能必须重定向标准输出到文件要在重定向标准错误到标准输出之前，即第一种写法才是正确的。当然更方便的写法是ls \u0026\u003e dirlist，可以理解其是对第一种写法的一种简写。 其对第二种写法错误的地方解释为：其标准错误从标准输出复制时，标准输出还未重定向到文件之中。该写法实际效果就是命令的标准输出重定向到文件之中，而标准错误则和重定向前的标准输出一样输出到屏幕上。 隐隐的感觉到需要了解文件描述符的复制才能真正理解重定向，从而对该问题有一个正确的解释。最近在《Linux/UNIX系统编程手册(上册)》中得到了答案，未防遗忘故记此文。文末对之前工作中遇到使用exec重定向shell脚本打印日志的方法进行记录。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:1:0","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#问题缘起"},{"categories":["实践到理论"],"content":" 问题解答下边是对《Linux/UNIX系统编程手册(上册)》1第5章内容的总结归纳，从而解释上述问题。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:2:0","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#问题解答"},{"categories":["实践到理论"],"content":" 文件描述符和打开文件之间的关系众所周知，文件描述符fd是一个整数，其是内核维护的文件打开表中的index，通过该index在文件表中可以找到打开文件的相关信息，包含文件偏移量、对文件系统i-node引用等。这大概就是我之前所理解的fd，其益于理解，但是忽略了很多的细节，为了理解上述问题，需要填补这些细节。 在内核中为了实现文件描述符和打开文件之间的关系，维护了3个数据结构： fd与打开文件之间的关系 进程级的文件描述表 针对每个进程，内核为其维护打开文件的描述符(open file descritor)表，其含有: 进程对fd私有的设置flag(目前仅有close-on-exec标志) 对系统级打开文件表中的打开文件句柄(open file handle)的引用 系统级的打开文件表 内核会对所有打开的文件维护系统级的描述符表，表中的各个元素的名称为打开文件句柄(open file handle)，其每一项含有: 当前文件偏移量(调用read和write、lseek时更改) 打开文件时所使用的状态标志 文件访问模式(如open时所设置的只读模式、只写或读写模式) 与信号驱动IO相关的设置 对该文件i-node对象的引用 文件系统的i-node表 文件系统会对所有文件建立一个i-node表，每个文件对应一个i-node表项，其含有: 文件类型(例如，常规文件、套接字或FIFO和访问权限) 一个执政，直线该文件所持有的锁列表 文件的各种属性，包含文件大小以及不同类型操作相关的时间戳(没有文件名，文件名存储在目录文件中，其中含有该目录下所有文件名和inode对应关系) 对图中进程A中fd=2和进程B中fd=2都指向同一个打开文件句柄73的情况可能在调用fork后出现（即进程A与进程B为父子关系），同时也需要注意到fork之后打开的文件会共享偏移量、状态标志等。或者当某进程通过UNIX域套接字至将一个打开的文件描述符传递给另一个进程时，也会发生。 对图中进程A中fd=0和进程B中fd=3指向不同的打开文件句柄，但这两个句柄指向同一个inode项1976，这种情况就是两个进程open了同一个文件，其偏移量并不共享，所以两个进程都write时会相互覆盖。在用一个进程打开同一个文件两次也类似。 ps: 所有的系统调用都是原子操作，两个进程同时往一个文件里write，不会出现交织一起的情况，但是涉及到偏移量的问题，可能会互相覆盖。 通过打开文件时加上O_APPEND参数，内核会保证向文件末尾追加时，移动偏移量到文件末尾和写入两个操作是原子的。在多进程往同一个文件追加写日志的时候很有用。 对图中进程A中fd=1和fd=20都指向同一个打开的文件句柄23，就可能是通过复制文件描述符dup()、dup2()、dup3()或fcntl()形成的，在下边一节中着重介绍。 这里想到一个问题，假如对fd=20调用close会影响到fd=1吗？从man close会得到答案，即close只会关闭进程级的文件描述符表，在所有对打开文件句柄的引用文件描述符都关闭时，才会释放打开文件句柄。 The close() call deletes a descriptor from the per-process object reference table. If this is the last reference to the underlying object, the object will be deactivated. 上述的分层设计让我想到了那句名言 Any problem in computer science can be solved by another layer of indirection. 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:2:1","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#文件描述符和打开文件之间的关系"},{"categories":["实践到理论"],"content":" 复制文件描述符和重定向复制文件描述的系统调用可以实现复制一个fd生成一个副本，而副本的fd值可以由调用者设置。共有dup()、dup2()、dup3()和fcntl()系统调用实现该功能，简单来说： int dup(int oldfd)仅仅是复制oldfd返回副本fd，如果需要设定副本fd值，需要利用系统保证新描述符一定是编号最低的未用文件描述符来设置，并不是十分可靠的。 newfd = fcntl(oldfd, F_DUPFD, startfd)复制oldfd并且选择大于等于startfd的最小未用值作为newfd的值，通过先close(startfd)基本可以保证设置newfd的值为startfd。 int dup2(int oldfd, int newfd)复制oldfd并且设置副本fd值为newfd，如果newfd参数所指的文件描述符之前已打开，那么dup2会将其先关闭close，并且忽略关闭期间的任何错误。故，更好的做法是在调用dup2之前若newfd已经打开，先手动close处理可能发生错误。 int dup3(int oldfd, int newfd, int flags)和dup2的区别便是增加了附加参数flags，目前仅支持O_CLOEXEC为复制的newfd设置close_on_exec标志。为linux 2.6.27之后的版本所特有。 所以对于重定向 cmd 1\u003e filename 可以理解为bash(父进程)exec cmd命令之前打开filename文件得到fd设为N，然后调用dup2(N, 1)将fd=1原本指向的文件(终端屏幕)关闭，复制成N的副本。最后调用exec cmd执行命令，此时cmd命令的打印都会重定向到filename文件中。 1. 重定向cmd \u003e ./filename cmd 2\u003e\u00261 可以理解为bash(父进程)exec cmd命令之前执行dup2(1, 2)，关闭fd2，将fd2设置为fd的副本，此时fd1/fd2共享同一个打开文件表。 2. 重定向cmd \u003e ./filename 综上所述，就可以回答ls \u003e dirlist 2\u003e\u00261和ls 2\u003e\u00261 \u003e dirlist的区别了。第一种先将stdout重定向到文件，再将stderr重定向到stdout，此时stdout和stderr再系统文件表中指向了文件。而第二种情况如图，stderr并没有重定向到文件，所以默认还会输出到屏幕上。 3. 重定向顺序区别 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:2:2","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#复制文件描述符和重定向"},{"categories":["实践到理论"],"content":" 使用exec重定向对shell的执行打印同时保存在文件中在工作中曾经遇到过这样的一个需求：当时需要实现个车端应用层总的启动脚本，有不同的模块需要启动多个程序，启动程序是通过调用各个模块的启动脚本来实现。因为该脚本不光会人为手动调用还会在总的状态管理程序中调用，为了便于排查问题(甩锅)，将各模块启动时各模块的日志的输出不仅要打印在屏幕上，也需要保存在日志文件之中。实现该需求就用到了在脚本中使用exec重定向当前脚本的功能，一行代码优雅实现。 在man bash中介绍exec的一节中提到在调用exec没有指定命令，此时进行重定向会应用到当前环境之中: If no command is specified, redirections may be used to affect the current shell environment. If there are no redirection errors, the return status is zero; otherwise the return status is non-zero. 按照上边的需求，需要将stdout和stderr打印屏幕的同时输出到日志文件之中，在脚本开始前加上如下一行即可。 shell exec \u0026\u003e \u003e(tee -a \"$LOG_FILE\") 对于exec重定向很好理解，如果将当前脚本的stdout和stderr重定向到文件之中执行exec \u0026\u003e $LOG_FILE即可，而上边的代码为了同时输出到文件和屏幕使用了\u003e(tee -a \"$LOG_FILE\")，该命令涉及到目录/dev/fd和进程替换(Process Substitution) ","date":"2023-09-24","objectID":"/posts/shell-redirection/:3:0","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#使用exec重定向对shell的执行打印同时保存在文件中"},{"categories":["实践到理论"],"content":" 目录/dev/fd在《Linux/Unix系统编程手册(上册)》5.11节对该目录的用途进行了阐释，对每个进程，内核都会提供一个虚拟目录/dev/fd，链接到linux专有的/proc/self/fd目录。该目录中包含\"/dev/fd/n\"形式的文件名，n是与进程中打开的文件描述符对应的编号。 而打开open该文件就相当于复制了相应的文件描述符，下列两行代码是等价的: shell fd = open(\"/dev/fd/1\", O_WRONLY); fd = dup(1); 显而易见open调用设置的flag访问模式需要和原文件描述符一致。程序中当然用不太到该目录下文件，直接调用dup即可，其主要用途在shell中，有一些命令只支持从文件中读取内容，而不支持从标准输入中读取内容，此时想使用管道将上个命令的输出作为输入就有点困难了。使用/dev/fd目录就可以解决该问题，通过 shell ls | cmd_only_read_file /dev/fd/0 管道会将上个命令ls的标准输出重定向到下个命令的标准输入中，所以对与cmd_only_read_file读取/dev/fd/0就相当于读取ls的输出。 为了方便起见，系统还提供了3个符号链接: /dev/stdin、/dev/stdout和/dev/stderr，分别链接了/dev/fd/{0,1,2}。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:3:1","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#目录devfd"},{"categories":["实践到理论"],"content":" 进程替换(Process Substitution)在man bash中对进程替换有如下阐述: man bash Process substitution is supported on systems that support named pipes (FIFOs) or the /dev/fd method of naming open files. It takes the form of \u003c(list) or \u003e(list). The process list is run with its input or output connected to a FIFO or some file in /dev/fd. The name of this file is passed as an argument to the current command as the result of the expansion. If the \u003e(list) form is used, writing to the file will provide input for list. If the \u003c(list) form is used, the file passed as an argument should be read to obtain the output of list. When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion. 我理解为在shell命令中有进程替换shell会首先根据不同类型进行如下操作: \u003e(cmd list)类似管道会将(cmd list)的stdin替换成fd=n的文件描述符。根据上边的介绍/dev/fd目录，此时对文件/dev/fd/n进行写入时，会如同输入到(cmd list)的stdin中。 \u003c(cmd list)类似管道会将(cmd list)的stdout替换成fd=n的文件描述符。同样的，此时对文件/dev/fd/n进行读取时，就相当于读取(cmd list)的stdout。 之后，文本替换命令中的\u003e(cmd list)、\u003c(cmd list)为/dev/fd/n，此时/dev/fd/n作为一个文件，同时也作为(cmd list)的标准输入/标准输出。这也就解释了\u003e(tee -a \"$LOG_FILE\")的用法，将tee -a \"$LOG_FILE\"命令看成一个可以输入的文件，对该文件输入时会同时输出到屏幕和LOG_FILE中。 ","date":"2023-09-24","objectID":"/posts/shell-redirection/:3:2","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#进程替换process-substitution"},{"categories":["实践到理论"],"content":" 参考 《Linux/Unix系统编程手册(上册)》 ↩︎ ","date":"2023-09-24","objectID":"/posts/shell-redirection/:4:0","series":null,"tags":["shell","重定向","系统编程"],"title":"从文件描述符和打开文件之间的关系重新理解shell重定向","uri":"/posts/shell-redirection/#参考"},{"categories":["troubleshooting"],"content":"记录一次由于动态链接库提供的含有虚函数的类不兼容导致的诡异coredump。 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:0:0","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#"},{"categories":["troubleshooting"],"content":" 问题排查","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:1:0","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#问题排查"},{"categories":["troubleshooting"],"content":" 问题表面首先找到程序挂掉前打印出如下： shell terminate called after throwing an instance of 'std::system_error' what(): Resource deadlock avoided Aborted google了下，大概率是因为以下两个原因: 线程自己join自己 =\u003e 悖论：即线程join结束的前提是线程本身结束执行，而线程本身结束的前提是join结束 两个线程互相join对方 =\u003e 悖论：即线程A结束的前提是B线程结束，线程B结束的前提是A线程结束 结合coredump程序挂掉的堆栈来看，涉及到对象析构=\u003e对象的成员变量std::future析构=\u003e调用std::thread::join，而刚好执行析构的线程是被std::async创建，返回值保存在该对象的成员变量std::future，这就造成了在自己线程自己join自己 std::future通过std::async返回，类似下边的调用方式 c++ std::future future_ = std::async(std::launch::async, myfunc); ps: std::future在离开作用域时如果之前没有调用过get会执行join等待函数执行完毕； 之前看到过滑天下之大稽的写法，不把std::async(std::launch::async, ...)结果赋值出去，调用者会阻塞到目标函数结束，完全变成同步调用。 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:1:1","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#问题表面"},{"categories":["troubleshooting"],"content":" 深入分析接下来就需要分析下，为何会调用到析构函数。 先介绍下具体的业务，有个so库通过zeromq和其它进程通信，我们这边按照其提供的带有虚函数的class，继承实现其虚函数，再将该class传递给so提供的方法，在对应数据到来的时候so库会调用对应的虚函数，从而执行到我们业务的代码。 将其抽象了下，即so的实现如下： c++ class RunMe { public: virtual void fun1() { cout \u003c\u003c \"base func1\" \u003c\u003c endl; } virtual void fun2() { cout \u003c\u003c \"base func2\" \u003c\u003c endl; } virtual void fun3() { cout \u003c\u003c \"base func3\" \u003c\u003c endl; } virtual ~RunMe() { cout \u003c\u003c \"base ~RunMe()\" \u003c\u003c endl; } }; void call_run_me(RunMe *r) { r-\u003efun1(); r-\u003efun2(); r-\u003efun3(); } 其中RunMe就是业务代码需要继承的类，实现其虚函数，将函数指针传递给class_run_me，在具体数据到来就会调用具体的函数。这个是多态的典型用法，用户代码如下： c++ #include \"mylib.h\" class MyRunMe : public RunMe { public: void fun1() override { cout \u003c\u003c \"my fun1\" \u003c\u003c endl; } void fun2() override { cout \u003c\u003c \"my fun2\" \u003c\u003c endl; } void fun3() override { cout \u003c\u003c \"my fun3\" \u003c\u003c endl; } ~MyRunMe() { cout \u003c\u003c \"~MyRunMe()\" \u003c\u003c endl; } }; int main() { MyRunMe r; call_run_me(\u0026r); } 实际的业务是使用智能指针shared_ptr来持有MyRunMe r，so提供的也拥有接收shared_ptr的类成员函数call_run_me的对象client，该client也由shared_ptr所管理，双方都会拥有对方的shared_ptr，这块我们这边写的非常不规范(不是我写的！)，出现了循环引用，按理说这两个对象永远也不会被delete。但是这两个对象在整个程序的生命周期里都需要，虽然不优雅但是没有错误。不过如果用查内存泄漏的工具查下，这个肯定是definitely泄漏！ classDiagram RunMe \u003c|-- MyRunMe RunMe: +func1() RunMe: +func2() RunMe: +func3() class MyRunMe{ +shared_ptr Client client_; +func1(); +func2(); +func3(); } class Client{ +shared_ptr RunMe r_; +std::future future_; +call_run_me(shared_ptr r); } 这块对象之间的关系很乱，总之，看coredump堆栈调用链是： 在call_run_me函数(单独线程执行)中RunMe r莫名调用析构函数 在RunMe r析构时会析构shared_ptr Client client_ client_的引用计数==0，触发client_的析构 client_析构触发future_析构 future_析构触发std::thread::join 出现线程自己join自己被系统kill掉 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:1:2","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#深入分析"},{"categories":["troubleshooting"],"content":" 问题根因现在的问题就在于RunMe r的析构函数为何被调用，通过将原so替换成debug版本的so，再打开core文件可以看到出错的行号，通过源代码看到程序在r-\u003efun4()之后堆栈就就是析构函数了，而r-\u003efun4()函数为新增虚函数 突然想到在书中看到过析构函数是通过偏移量来决议 《Linux多线程服务端编程：使用muduo C++网络库》1p434 先说修改动态库导致二进制不兼容的例子。比如原来动态库里定义了 non-virtual，函数 void foo(int)，新版的库把参数改成了 double。那么现有的可执行文件就无法启动，会发生 undefined symbol 错误，因为这两个函数的 mangled name 不同。但是对于 virtual 函数 foo(int)，修改其参数类型并不会导致加载错误，而是会发生诡异的运行时错误。因为虚函数的决议（resolution）是靠偏移量，并不是靠符号名。再举一些源代码兼容但是二进制代码不兼容的例子： 给函数增加默认参数，现有的可执行文件无法传这个额外的参数。 增加虚函数，会造成 vtbl 里的排列变化。（不要考虑“只在末尾增加”这种取巧行为，因为你的 class 可能已被继承。） 增加默认模板类型参数，比方说 Foo\u003cT\u003e 改为 Foo\u003cT, Alloc=alloc\u003cT\u003e \u003e，这会改变 name mangling。 改变 enum 的值，把 enum Color { Red = 3 }; 改为 Red = 4 。这会造成错位。当然，由于 enum 自动排列取值，添加 enum 项也是不安全的（在末尾添加除外）。 通过看当时版本和编译时/运行时so版本，可以确认编译时使用的旧的so未增加该虚函数，而运行时的so版本则为新版增加该虚函数，而该虚函数在类中的顺序增加在析构函数之前，导致运行时so调用该虚函数实际调用的是老版本的继承类的析构函数，导致一系列的连锁反应。 通过gdb中info vtbl r指针可以看到虚函数表，其中并不含有新增的虚函数。基本可以确认是该问题 info vtbl可以看到虚表中含有两个析构函数，经google查明编译器会在虚表生成两个析构函数指针，其中一个在析构函数的基础上增加了释放内存等操作(virtual function thunk)，涉及到编译器的细节，不再深入研究。 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:1:3","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#问题根因"},{"categories":["troubleshooting"],"content":" 问题复现","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:2:0","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#问题复现"},{"categories":["troubleshooting"],"content":" 复现方法具体代码在虚表版本不匹配测试 先声明定义两个版本的RunMe，新版本增加了fun_2_5()虚函数 c++ // v1 so class RunMe { public: virtual void fun1() { cout \u003c\u003c \"base func1\" \u003c\u003c endl; } virtual void fun2() { cout \u003c\u003c \"base func2\" \u003c\u003c endl; } virtual void fun3() { cout \u003c\u003c \"base func3\" \u003c\u003c endl; } virtual ~RunMe() { cout \u003c\u003c \"base ~RunMe()\" \u003c\u003c endl; } }; void call_run_me(RunMe *r) { r-\u003efun1(); r-\u003efun2(); r-\u003efun3(); } // v2 so class RunMe { public: virtual void fun1() { cout \u003c\u003c \"base func1\" \u003c\u003c endl; } virtual void fun2() { cout \u003c\u003c \"base func2\" \u003c\u003c endl; } virtual void fun2_5() { cout \u003c\u003c \"base func2.5\" \u003c\u003c endl; } // 对应增加的虚函数 virtual void fun3() { cout \u003c\u003c \"base func3\" \u003c\u003c endl; } virtual ~RunMe() { cout \u003c\u003c \"base ~RunMe()\" \u003c\u003c endl; } }; void call_run_me(RunMe *r) { r-\u003efun1(); r-\u003efun2(); r-\u003efun2_5(); r-\u003efun3(); } 分别在各自的目录执行g++ mylib.cc -fPIC -shared -o libmylib.so -ggdb编译成so 用户实现的main.cc c++ #include \"mylib.h\" class MyRunMe : public RunMe { public: void fun1() override { cout \u003c\u003c \"my fun1\" \u003c\u003c endl; } void fun2() override { cout \u003c\u003c \"my fun2\" \u003c\u003c endl; } void fun3() override { cout \u003c\u003c \"my fun3\" \u003c\u003c endl; } ~MyRunMe() { cout \u003c\u003c \"~MyRunMe()\" \u003c\u003c endl; } }; int main() { MyRunMe r; call_run_me(\u0026r); } 使用不同版本的so编译main.cc shell g++ main.cc -L v1 -I v1 -lmylib -o main_use_v1 -ggdb # 使用v1下的so和头文件编译 g++ main.cc -L v2 -I v2 -lmylib -o main_use_v2 -ggdb # 使用v2下的so和头文件编译 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:2:1","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#复现方法"},{"categories":["troubleshooting"],"content":" 虚表分析与运行情况main中v1和v2中MyRunMe的虚表排序: index main_v1中的虚表vptr main_v2中的虚表vptr 0 fun1() fun1() 1 fun2() fun2() 2 fun3() fun2.5() 3 ~MyRunMe() fun3() 4 ~MyRunMe()编译器增加 ~MyRunMe() 5 ~MyRunMe()编译器增加 而so中call_run_me调用虚表index的偏移量: v1 call_run_me调用虚表index v2 call_run_me调用虚表index r-\u003efun1()=\u003ecall vptr[0]() r-\u003efun1()=\u003ecall vptr[0]() r-\u003efun2()=\u003ecall vptr[1]() r-\u003efun2()=\u003ecall vptr[1]() r-\u003efun3()=\u003ecall vptr[2]() r-\u003efun2_5()=\u003ecall vptr[2]() r-\u003e~RunMe()=\u003ecall vptr[3]() r-\u003efun3()=\u003ecall vptr[3]() r-\u003e~RunMe()=\u003ecall vptr[4]() 之后可以通过LD_LIBRARY_PATH设置不同的运行so即不同版本的call_run_me函数，调用不同的main程序从而设置不同版本的虚表。 例如使用v1 main的虚表，v2 so的call_run_me调用虚表，就可以执行LD_LIBRARY_PATH=\"v2/\" ./main_use_v1，得到结果： shell ~/Documents/git/recipes/test/vptr (main*) » LD_LIBRARY_PATH=\"v2/\" ./main_use_v1 my fun1 my fun2 my fun3 ~MyRunMe() base ~RunMe() ~MyRunMe() base ~RunMe() 可以发现v2 call_run_me中调用fun2_5，调用的是虚表vptr[2]()而对应v1 MyRunMe则是func3()；而v2 call_run_me中调用fun3，调用的就是虚表vptr[3]()对应的就是v1 MyRunMe的析构函数，类似于此次coredump产生的原因。 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:2:2","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#虚表分析与运行情况"},{"categories":["troubleshooting"],"content":" 总结 虚函数调用是通过偏移来决定的跟函数名无关，如果三方库如果更新了虚函数，即使跟本模块无关，最好也要重新编译下，否则可能会发生诡异的问题 虚函数的二进制兼容性并不好，如果用《Linux多线程服务端编程：使用muduo C++网络库》中所推荐的函数指针的方式来实现类似虚函数的功能则是极好的 ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:3:0","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#总结"},{"categories":["troubleshooting"],"content":" 参考 《Linux多线程服务端编程：使用muduo C++网络库》 ↩︎ ","date":"2023-09-21","objectID":"/posts/troubleshooting_guide_vtable-coredump/:4:0","series":null,"tags":["C++","虚函数"],"title":"记一次虚函数二进制兼容问题导致的coredump - 问题诊断","uri":"/posts/troubleshooting_guide_vtable-coredump/#参考"},{"categories":[],"content":" Linux学习笔记","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#linux学习笔记"},{"categories":[],"content":" 配置文件","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#配置文件"},{"categories":[],"content":" shell配置文件 系统级 /etc/profile :该文件是用户登录时，操作系统定制用户环境时使用的第一个文件，应用于登录到系统的每一个用户 /etc/bash.bashrc /etc/environment :在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。 用户级 ~/.bashrc ~/.bash_logout:logout时执行 login shell 和 nologin shell login shell 载入全部的配置文件 nologin shell 载入不完全 su - username 是login shell;避免用su username. ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:1","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#shell配置文件"},{"categories":[],"content":" shell配置文件 系统级 /etc/profile :该文件是用户登录时，操作系统定制用户环境时使用的第一个文件，应用于登录到系统的每一个用户 /etc/bash.bashrc /etc/environment :在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。 用户级 ~/.bashrc ~/.bash_logout:logout时执行 login shell 和 nologin shell login shell 载入全部的配置文件 nologin shell 载入不完全 su - username 是login shell;避免用su username. ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:1","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#login-shell-和-nologin-shell"},{"categories":[],"content":" 快捷键及特殊符号","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:2:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#快捷键及特殊符号"},{"categories":[],"content":" 快捷键 ^l 清屏 ^p 重复上一条命令 ^d 退出 ^a 将光标移到最前 ^e 将光标移到最后 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:2:1","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#快捷键"},{"categories":[],"content":" 特殊符号 历史命令 !number :以前的第num条(history表中的num) !-number：重复执行前第number条指令 !string :最近的以string开头的命令 !$ :上一个命令的最后一个参数 !! :上一个命令(sudo !!) ^R :搜索命令 别名功能 alias 查看当前shell别名 unalias 取消别名 命令前加\\屏蔽别名 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:2:2","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#特殊符号"},{"categories":[],"content":" 前台后台 \u0026 挂起后可能会停止 nohub 不会停止 ^c结束前台, ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:3:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#前台后台"},{"categories":[],"content":" Deep Learning学习笔记","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#deep-learning学习笔记"},{"categories":[],"content":" 名词解释","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#名词解释"},{"categories":[],"content":" 泛化(generalization)在先前为观测到的输入上表现的能力,用测试集(test set)来度量泛化误差 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:1","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#泛化generalization"},{"categories":[],"content":" 正则化(regularization) 解决过拟合问题指我们修改学习算法，使其降低泛化误差而非训练误差。 L1 \u0026 L2正则化 Dropout early stopping","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:2","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#正则化regularization-解决过拟合问题"},{"categories":[],"content":" 正则化(regularization) 解决过拟合问题指我们修改学习算法，使其降低泛化误差而非训练误差。 L1 \u0026 L2正则化 Dropout early stopping","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:2","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#l1--l2正则化"},{"categories":[],"content":" 正则化(regularization) 解决过拟合问题指我们修改学习算法，使其降低泛化误差而非训练误差。 L1 \u0026 L2正则化 Dropout early stopping","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:2","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#dropout"},{"categories":[],"content":" 正则化(regularization) 解决过拟合问题指我们修改学习算法，使其降低泛化误差而非训练误差。 L1 \u0026 L2正则化 Dropout early stopping","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:2","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#early-stopping"},{"categories":[],"content":" 超参数不是由学习而来的参数 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:3","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#超参数"},{"categories":[],"content":" 验证集(validation set)用于挑选超参数的数据子集 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:4","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#验证集validation-set"},{"categories":[],"content":" Bias\u0026Variance 欠拟合(underfitting)==\u003ehigh bias 过拟合(overfitting)==\u003ehigh variance ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:5","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#biasvariance"},{"categories":[],"content":" 梯度爆炸\u0026梯度消失参数过大或过小,导致梯度非常大或者梯度为零; ReLU ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:1:6","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#梯度爆炸梯度消失"},{"categories":[],"content":" golang slice,map 笔记禁止slice之间的比较, 原因如下: slice元素是间接引用,一个slice甚至可以包含自身.虽然有很多方法可以处理这种情形,但是没有一个时简单有效的. 因为slice的元素是间接引用的,一个固定值的slice在不同的时间可能包含不同的元素,因为底层数组的元素可能会被修改。针对slice的浅相等==(即判断是否引用相同的对象)可能有点卵用,也能临时解决map中key的问题,但是与数组不同的相等测试会让我很困惑. 所以要禁止slice之间的比较. 不可对map中的value进行取址操作, 因为map可能通过元素数量的增长而重新分配内存,导致之前的地址无效. ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#golang-slicemap-笔记"},{"categories":[],"content":" golang-奇怪的nil 变量 var 接口 interface 首先需要知道接口值分为两个部分 类型 类型的值 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#golang-奇怪的nil"},{"categories":[],"content":" 英语音标学习cop [ɑ] 类似于医生让你张大嘴说\"啊\" the [ə] 类似于汉字\"额\" cup [ʌ] 用[ə]的嘴型发[ɑ] boot [u] 类似于汉字\"乌\" book [ʊ] 用[ə]的嘴型发[u] beat [i] 类似于汉字\"衣\" bit [ɪ] 类似于惊讶时发出的\"咦\" make [eɪ] 类似于接电话时说的\"喂\"的尾音 head [ɛ] 类似于欢呼时喊的\"耶\"拖长后的尾音 had [æ] 类似于羊叫声\"咩\"拖长后的尾音 law [ɔ] 类似于汉字\"奥\" now [aʊ] 类似于突然被人在肚子上打了一锤后发出的叫声 bite [aɪ] 类似于老外说\"我爱你\"中的\"爱\"字 boy [ɔɪ] 从[ɔ]滑动到[ɪ] go [əʊ] 从[ə]滑动到[ʊ] 辅音 web [w] 类似于汉字\"乌\" yes [j] 类似于汉字\"衣\" father [f] 类似于汉语拼音声母f very [v] 发[f]时声带振动 red [r] 嘴巴向前撅, 舌头向后缩, 舌尖向上卷(r位于元音前) car [r] 舌头向后缩, 舌尖向上卷(r位于元音后) light [l] 舌尖抵住上齿背后, 把舌头滑落下来, 在滑落的过程中发音(l位于元音前) well [l] 舌尖向前向上滑动, 抵住上牙齿背后, 在上滑的过程中发音(l位于元音后) night [n] 和l动作一模一样, 但气流从鼻腔发出(n位于元音前) pen [n] 和n动作一模一样, 但气流从鼻腔发出(n位于元音后) mom [m] 类似于闭着嘴巴说\"嗯\" sing [ŋ] 舌头后部上抬, 抵住软腭, 说\"嗯\" roads [dz] 类似于汉字\"资\" let’s [ts] 类似于汉字\"词\" boss [s] 类似于汉字\"思\" rose [z] 发[s]时声带振动 thanks [ɵ] 舌尖放到上下齿之间, 然后发[s] them [ð] 舌尖放到上下齿之间, 然后发[z] just [dʒ] 类似于汉字\"知\" check [tʃ] 类似于汉字\"吃\" she [ʃ] 类似于汉字\"师\" Asia [ʒ]类似于汉字\"日\" try [tr] 类似于汉字\"出\" dry [dr] 类似于汉字\"猪\" pet [p] 类似于汉语拼音声母p bed [b] 类似于汉语拼音声母b too [t] 类似于汉语拼音声母t do [d] 类似于汉语拼音声母d kiss [k] 类似于汉语拼音声母k go [g] 类似于汉语拼音声母g how [h] 类似于汉语拼音声母h https://zhuanlan.zhihu.com/p/21298089 ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#英语音标学习"},{"categories":[],"content":" cpp的坑 数组vs指针 数组退化 cpp int GetSize(int data[]){ return sizeof(data); } int main(){ int data1[] = {1,2,3,4,5}; int size1 = sizeof(data1); // 20 int *data2 = data1; int size2 = sizeof(data1); // 4 int size3 = GetSize(data1); // 4 当数组作为函数参数进行传递时,数组自动退化成同类型的指针. } ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#cpp的坑"},{"categories":[],"content":" Linux高性能服务器编程读书笔记 同步IO和异步IO: 同步IO 要求用户代码自行执行I/O操作(将数据从内核缓冲区读入用户缓冲区, 或将数据从用户缓冲区写入到内核缓冲区) 阻塞IO,IO复用和信号驱动IO都是同步IO模型 异步IO 有内核来执行IO操作, 用户告诉内核读写缓冲区的位置, 之后由内核完全接管, 操作完成后通知应用程序 aio.h ","date":"2019-04-01","objectID":"/posts/unfinish_old_notes/:0:0","series":null,"tags":["杂"],"title":"半途而废 - 旧笔记","uri":"/posts/unfinish_old_notes/#linux高性能服务器编程读书笔记"},{"categories":[],"content":"考研807操作系统复习笔记","date":"2018-11-30","objectID":"/posts/operating-system/","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/"},{"categories":[],"content":" （一）基本概念","date":"2018-11-30","objectID":"/posts/operating-system/:1:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#一基本概念"},{"categories":[],"content":" 计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE； 计算机的基本构成存储器、控制器、运算器、输入设备、输出设备 处理器的内部结构CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。 cache当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#计算机基本构成处理器的内部结构高速缓冲存储器cache"},{"categories":[],"content":" 计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE； 计算机的基本构成存储器、控制器、运算器、输入设备、输出设备 处理器的内部结构CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。 cache当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#计算机的基本构成"},{"categories":[],"content":" 计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE； 计算机的基本构成存储器、控制器、运算器、输入设备、输出设备 处理器的内部结构CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。 cache当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#处理器的内部结构"},{"categories":[],"content":" 计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE； 计算机的基本构成存储器、控制器、运算器、输入设备、输出设备 处理器的内部结构CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。 cache当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#cache"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#操作系统的概念演变历程特性分类运行环境功能"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#操作系统的概念"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#演变历程"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#特征"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#运行环境"},{"categories":[],"content":" 操作系统的概念、演变历程、特性、分类、运行环境、功能； 操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境 功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#功能"},{"categories":[],"content":" 存储器的层次结构。 ","date":"2018-11-30","objectID":"/posts/operating-system/:1:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#存储器的层次结构"},{"categories":[],"content":" （二）进程","date":"2018-11-30","objectID":"/posts/operating-system/:2:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#二进程"},{"categories":[],"content":" 进程的概念和特点； 概念为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。 组成: PCB: 保存进程运行期间相关数据,是进程存在的唯一标识 程序段: 能被进程调度程序调度到CPU运行的程序的代码段 数据段: 存储程序运行期间的相关数据 特点 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。动态性是进程最基本的特征。 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与其他进程的程序并发执行，以提高资源利用率。 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。 ","date":"2018-11-30","objectID":"/posts/operating-system/:2:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#进程的概念和特点"},{"categories":[],"content":" 进程的概念和特点； 概念为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。 组成: PCB: 保存进程运行期间相关数据,是进程存在的唯一标识 程序段: 能被进程调度程序调度到CPU运行的程序的代码段 数据段: 存储程序运行期间的相关数据 特点 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。动态性是进程最基本的特征。 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与其他进程的程序并发执行，以提高资源利用率。 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。 ","date":"2018-11-30","objectID":"/posts/operating-system/:2:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#概念"},{"categories":[],"content":" 进程的概念和特点； 概念为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。 组成: PCB: 保存进程运行期间相关数据,是进程存在的唯一标识 程序段: 能被进程调度程序调度到CPU运行的程序的代码段 数据段: 存储程序运行期间的相关数据 特点 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。动态性是进程最基本的特征。 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与其他进程的程序并发执行，以提高资源利用率。 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。 ","date":"2018-11-30","objectID":"/posts/operating-system/:2:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#特点"},{"categories":[],"content":" 进程状态转换进程状态 运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。 阻塞状态：又称为等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。及时处理器空闲，该进程也不能运行。 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。 结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要获得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，即使处理器空闲也不能运行。 状态转换 就绪状态=\u003e运行状态: 通过处理器调度,就绪进程得到处理器资源 运行状态=\u003e就绪状态: 时间片用完或有更高优先级的进程进入 运行状态=\u003e阻塞状态: 进程所需要的某一资源还未准备好 阻塞状态=\u003e就绪状态: 进程需要的资源已经准备好 ","date":"2018-11-30","objectID":"/posts/operating-system/:2:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#进程状态转换"},{"categories":[],"content":" （三）线程、对称多处理SMP和微内核","date":"2018-11-30","objectID":"/posts/operating-system/:3:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#三线程对称多处理smp和微内核"},{"categories":[],"content":" 线程的概念，定义线程的必要性和可能性； 概念程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成. 必要性进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性. 可能性当然可能,废话 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#线程的概念定义线程的必要性和可能性"},{"categories":[],"content":" 线程的概念，定义线程的必要性和可能性； 概念程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成. 必要性进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性. 可能性当然可能,废话 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#概念-1"},{"categories":[],"content":" 线程的概念，定义线程的必要性和可能性； 概念程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成. 必要性进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性. 可能性当然可能,废话 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#必要性"},{"categories":[],"content":" 线程的概念，定义线程的必要性和可能性； 概念程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成. 必要性进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性. 可能性当然可能,废话 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#可能性"},{"categories":[],"content":" 线程的功能特性与实现方式； 功能特性线程状态 阻塞: 当线程需要等待一个事件,它将被阻塞(保存它的用户寄存器,程序计数器,栈指针),此时处理器执行同一进程中或不同进程的就绪线程 注:程序计数器是用于存放下一条指令所在单元的地址的地方。 解除阻塞 结束 实现方式用户级线程\u0026内核级线程 用户级线程(多对一) 优点: 效率比较高 缺点: 当一个线程在使用内核服务时被阻塞了,那么整个进程都会被阻塞 内核级线程(一对一) 优点: 当一个线程在被阻塞时,完全不慌 缺点: 效率低 多对多模型: 将n个用户级线程映射到m个内核级线程上,要求m小于等于n 缺点\u0026优点: 集大成者 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#线程的功能特性与实现方式"},{"categories":[],"content":" 线程的功能特性与实现方式； 功能特性线程状态 阻塞: 当线程需要等待一个事件,它将被阻塞(保存它的用户寄存器,程序计数器,栈指针),此时处理器执行同一进程中或不同进程的就绪线程 注:程序计数器是用于存放下一条指令所在单元的地址的地方。 解除阻塞 结束 实现方式用户级线程\u0026内核级线程 用户级线程(多对一) 优点: 效率比较高 缺点: 当一个线程在使用内核服务时被阻塞了,那么整个进程都会被阻塞 内核级线程(一对一) 优点: 当一个线程在被阻塞时,完全不慌 缺点: 效率低 多对多模型: 将n个用户级线程映射到m个内核级线程上,要求m小于等于n 缺点\u0026优点: 集大成者 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#功能特性"},{"categories":[],"content":" 线程的功能特性与实现方式； 功能特性线程状态 阻塞: 当线程需要等待一个事件,它将被阻塞(保存它的用户寄存器,程序计数器,栈指针),此时处理器执行同一进程中或不同进程的就绪线程 注:程序计数器是用于存放下一条指令所在单元的地址的地方。 解除阻塞 结束 实现方式用户级线程\u0026内核级线程 用户级线程(多对一) 优点: 效率比较高 缺点: 当一个线程在使用内核服务时被阻塞了,那么整个进程都会被阻塞 内核级线程(一对一) 优点: 当一个线程在被阻塞时,完全不慌 缺点: 效率低 多对多模型: 将n个用户级线程映射到m个内核级线程上,要求m小于等于n 缺点\u0026优点: 集大成者 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#实现方式"},{"categories":[],"content":" 线程vs进程 调度 线程时独立调度的基本单位,进程时拥有资源的基本单位 拥有资源 进程拥有系统资源,线程也有一点必不可少的资源. 并发性 拥有线程的操作系统并发性更好. 系统开销 进程的创建,切换,撤销的效率低于线程 地址空间和其他资源 进程之间的地址空间相互独立 通信资源 进程间的通信(IPC)需要进行进程同步和互斥手段的辅助 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#线程vs进程"},{"categories":[],"content":" 对称多处理SMP体系结构； SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； ","date":"2018-11-30","objectID":"/posts/operating-system/:3:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#对称多处理smp体系结构"},{"categories":[],"content":" 对称多处理SMP体系结构； SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； ","date":"2018-11-30","objectID":"/posts/operating-system/:3:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#smp-symmetric-multiprocessing"},{"categories":[],"content":" 对称多处理SMP体系结构； SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； ","date":"2018-11-30","objectID":"/posts/operating-system/:3:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#对称多处理系统"},{"categories":[],"content":" 对称多处理SMP体系结构； SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； ","date":"2018-11-30","objectID":"/posts/operating-system/:3:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#非对称处理系统"},{"categories":[],"content":" 对称多处理SMP体系结构； SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； ","date":"2018-11-30","objectID":"/posts/operating-system/:3:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#smp体系结构"},{"categories":[],"content":" 操作系统的体系结构（微内核与单内核）及其性能分析。 单内核单内核就是把os从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。性能好,Unix系统就是单内核.Linux也是单内核,但它加入了很多高级的东西 微内核微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。各个服务器通信需要IPC机制,模块化安全且省地方.windows等 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#操作系统的体系结构微内核与单内核及其性能分析"},{"categories":[],"content":" 操作系统的体系结构（微内核与单内核）及其性能分析。 单内核单内核就是把os从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。性能好,Unix系统就是单内核.Linux也是单内核,但它加入了很多高级的东西 微内核微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。各个服务器通信需要IPC机制,模块化安全且省地方.windows等 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#单内核"},{"categories":[],"content":" 操作系统的体系结构（微内核与单内核）及其性能分析。 单内核单内核就是把os从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。性能好,Unix系统就是单内核.Linux也是单内核,但它加入了很多高级的东西 微内核微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。各个服务器通信需要IPC机制,模块化安全且省地方.windows等 ","date":"2018-11-30","objectID":"/posts/operating-system/:3:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#微内核"},{"categories":[],"content":" （四）并发","date":"2018-11-30","objectID":"/posts/operating-system/:4:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#四并发"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#并发性问题及相关概念如临界区互斥信号量和管程等"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#临界区"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#互斥间接制约关系"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#同步直接制约关系"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#信号量"},{"categories":[],"content":" 并发性问题及相关概念，如临界区、互斥、信号量和管程等； 临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=\u003eP操作 c wait(S){ while(S\u003c=0) ; S--; } signal(S)=\u003eV操作 c signal(S){ S++; } 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=\u003e就绪状态,等系统调度执行. 定义如下: c typedef struct{ int value; struct process *list; //PCB链表 }semaphore; wait(semaphore *S){ S-\u003evalue--; if (S-\u003evalue\u003c0){ // add this process to list block(); } } signal(S){ S-\u003evalue++; if (S-\u003evalue \u003c=0 ){ remove a process P from list wakeup(P); } } 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 c monitor dp { enum {thinking, hungry, eating} state[5]; condition self[5]; void pickup(int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 } void putdown(int i) { state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important } void test(int i) { if ((state[(i+4)%5] != eating) \u0026\u0026 (state[i] == hungry) \u0026\u0026 (state[(i+1)%5] != eating)) { state[i] = eating; self[i].signal();//V操作 } } void init() { for (int i = 0; i \u003c 5; i++) state[i] = thinking; } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#管程--互斥锁--条件变量"},{"categories":[],"content":" 进程互斥、同步和通信的各种算法； 生产者-消费者问题 c semaphore mutex = 1; semaphore empty = n; semaphore full = 0; producer(){ while(true){ produce an item in nextp; wait(empty) // P操作,empty-- wait(mutex); add nextp to buffer; signal(mutex); signal(full); // V操作,full++ } } consumer(){ while(true){ wait(full); wait(mutex); remove an item from buffer; signal(mutex); signal(empty); consumer the item; } } 读者-写者问题: 允许多个读者读,但只允许一个写者写 读者优先 c int count=0; semaphore mutex=1; //保护count semaphore rw=1; //保证读者和写者互斥地访问文件 writer(){ while(true){ wait(rw); writing; singal(rw); } } reader(){ while(true){ wait(mutex); if(cout==0) wait(rw); cout++; singal(mutex); reading; wait(mutex); count--; if(count==0) singal(rw); singal(mutex); } } 写者优先(公平算法) c int count=0; semaphore mutex=1; semaphore rw=1; semaphore w=1; writer(){ while(true){ wait(w); wait(rw); writing; singal(rw); singal(w); } } reader(){ while(true){ wait(w); //无写进程时请求进入 wait(mutex); if (count==0) wait(rw); count++; singal(mutex); singal(w); reading; wait(mutex); count--; if (count==0) singal(rw); singal(mutex); } } ","date":"2018-11-30","objectID":"/posts/operating-system/:4:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#进程互斥同步和通信的各种算法"},{"categories":[],"content":" 死锁的概念、死锁的原因和条件； 概念互相等待 死锁的必要条件产生死锁必须同时满足一下四个条件 互斥条件 至少有一个资源处于非共享模式,即一次只能有一个进程使用 非抢占(不可剥夺条件) 资源不能被抢占,即资源只有在进程完成时后才释放. 占有并等待(请求和保持条件) 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有 循环等待条件 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有 资源分配图 如果分配图有环,则可能存在死锁 如果每个资源类型刚好有一个实例,那么有环一定死锁 ","date":"2018-11-30","objectID":"/posts/operating-system/:4:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的概念死锁的原因和条件"},{"categories":[],"content":" 死锁的概念、死锁的原因和条件； 概念互相等待 死锁的必要条件产生死锁必须同时满足一下四个条件 互斥条件 至少有一个资源处于非共享模式,即一次只能有一个进程使用 非抢占(不可剥夺条件) 资源不能被抢占,即资源只有在进程完成时后才释放. 占有并等待(请求和保持条件) 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有 循环等待条件 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有 资源分配图 如果分配图有环,则可能存在死锁 如果每个资源类型刚好有一个实例,那么有环一定死锁 ","date":"2018-11-30","objectID":"/posts/operating-system/:4:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#概念-2"},{"categories":[],"content":" 死锁的概念、死锁的原因和条件； 概念互相等待 死锁的必要条件产生死锁必须同时满足一下四个条件 互斥条件 至少有一个资源处于非共享模式,即一次只能有一个进程使用 非抢占(不可剥夺条件) 资源不能被抢占,即资源只有在进程完成时后才释放. 占有并等待(请求和保持条件) 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有 循环等待条件 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有 资源分配图 如果分配图有环,则可能存在死锁 如果每个资源类型刚好有一个实例,那么有环一定死锁 ","date":"2018-11-30","objectID":"/posts/operating-system/:4:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的必要条件"},{"categories":[],"content":" 死锁的概念、死锁的原因和条件； 概念互相等待 死锁的必要条件产生死锁必须同时满足一下四个条件 互斥条件 至少有一个资源处于非共享模式,即一次只能有一个进程使用 非抢占(不可剥夺条件) 资源不能被抢占,即资源只有在进程完成时后才释放. 占有并等待(请求和保持条件) 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有 循环等待条件 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有 资源分配图 如果分配图有环,则可能存在死锁 如果每个资源类型刚好有一个实例,那么有环一定死锁 ","date":"2018-11-30","objectID":"/posts/operating-system/:4:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#资源分配图"},{"categories":[],"content":" 死锁的预防、避免和检测算法。 资源分配策略 各种可能模式 主要优点 主要缺点 死锁预防 保守,宁可资源闲置 一次请求所有资源,资源剥夺,资源按序分配 适用与做突发式处理的进程,不必进行剥夺 效率低;剥夺次数多;不便灵活申请新资源 死锁避免 折中(在运行时判断是否可能死锁) 寻找可能的安全允许顺序 不必进行剥夺 必须知道将来的资源需求;进程不能被长时间阻塞 死锁检测 宽松,只要允许就分配资源 定期检查死锁是否已经发生 不延长进程初始化事件,允许堆死锁进行现场处理 通过剥夺解除死锁,造成损失 死锁的预防破坏死锁的四个必要条件之一 破坏互斥条件 如果允许所有资源都可以共享使用即可. 破坏非抢占 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源. 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源. 破坏占有并等待 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源. 缺点: 系统资源被严重浪费,而且还会导致饥饿. 破坏循环等待 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源. 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦. 死锁的避免在资源动态分配过程中防止系统进入不安全的状态. 系统安全状态 对于进程顺序\u003cp1,p2..pn\u003e, pi还需要的资源数 \u003c 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表 进程 最大需求 已分配 可用 P1 10 5 3 P2 4 2 P3 9 2 存在一个安全序列\u003cp2 p1 p3\u003e，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态. 如果此时分配1个磁带机给p3,此时就处于不安全状态了. 资源分配图法(每个资源的实例只有一个) 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了. 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数 银行家算法 当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源; 进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数. 银行家算法的数据结构 可利用资源向量Available 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 需求矩阵Need。 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 Need[i,j]=Max[i,j] - Allocation[i,j] 算法过程: 银行家算法 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： 如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 系统试探着把资源分配给进程P i，并修改下面数据结构中的数值： Available[j]:= Available[j]-Request i[j]； Allocation[i,j]:= Allocation[i,j]+Request i[j]； Need[i,j]:= Need[i,j]-Request i[j]； 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性检测算法 设置两个向量： 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。 Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。 从进程集合中找到一个能满足下述条件的进程： Finish[i]=false； Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:= Work[j]+Allocation[i,j]； Finish[i]:=true； go to step （2）; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 示例 假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号） T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。 P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查： Request1(1，0，2)≤Need1(1，2，2) Request1(1，0，2)≤Available1(3，3，2) 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示 再利用安全性算法检查此时系统是否安全。如图所示。 P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查： Request4(3，3，0)≤Need4(4，3，1)； Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正） P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)； Request0(0，2，0)≤Available(2，3，0)； 系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 https://blog.csdn.net/cout_sev/article/details/24980627 死锁的检测 每种资源都只有单个实例 创建等待图,如果等待图成环就代表发生了死锁 多个实例的死锁检测 数据结构 示例 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4 假如p2 又请求了资源C的实例 此时就发生了死锁 死锁解除 一旦检测出死锁,应立即采取相应的措施,如: 资源剥夺法 挂起某些死锁进程,并抢占其资源,给其他的死锁进程 撤销进程法 强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价. 进程回退法 让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点. ","date":"2018-11-30","objectID":"/posts/operating-system/:4:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的预防避免和检测算法"},{"categories":[],"content":" 死锁的预防、避免和检测算法。 资源分配策略 各种可能模式 主要优点 主要缺点 死锁预防 保守,宁可资源闲置 一次请求所有资源,资源剥夺,资源按序分配 适用与做突发式处理的进程,不必进行剥夺 效率低;剥夺次数多;不便灵活申请新资源 死锁避免 折中(在运行时判断是否可能死锁) 寻找可能的安全允许顺序 不必进行剥夺 必须知道将来的资源需求;进程不能被长时间阻塞 死锁检测 宽松,只要允许就分配资源 定期检查死锁是否已经发生 不延长进程初始化事件,允许堆死锁进行现场处理 通过剥夺解除死锁,造成损失 死锁的预防破坏死锁的四个必要条件之一 破坏互斥条件 如果允许所有资源都可以共享使用即可. 破坏非抢占 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源. 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源. 破坏占有并等待 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源. 缺点: 系统资源被严重浪费,而且还会导致饥饿. 破坏循环等待 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源. 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦. 死锁的避免在资源动态分配过程中防止系统进入不安全的状态. 系统安全状态 对于进程顺序, pi还需要的资源数 \u003c 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表 进程 最大需求 已分配 可用 P1 10 5 3 P2 4 2 P3 9 2 存在一个安全序列，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态. 如果此时分配1个磁带机给p3,此时就处于不安全状态了. 资源分配图法(每个资源的实例只有一个) 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了. 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数 银行家算法 当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源; 进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数. 银行家算法的数据结构 可利用资源向量Available 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 需求矩阵Need。 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 Need[i,j]=Max[i,j] - Allocation[i,j] 算法过程: 银行家算法 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： 如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 系统试探着把资源分配给进程P i，并修改下面数据结构中的数值： Available[j]:= Available[j]-Request i[j]； Allocation[i,j]:= Allocation[i,j]+Request i[j]； Need[i,j]:= Need[i,j]-Request i[j]； 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性检测算法 设置两个向量： 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。 Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。 从进程集合中找到一个能满足下述条件的进程： Finish[i]=false； Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:= Work[j]+Allocation[i,j]； Finish[i]:=true； go to step （2）; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 示例 假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号） T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。 P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查： Request1(1，0，2)≤Need1(1，2，2) Request1(1，0，2)≤Available1(3，3，2) 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示 再利用安全性算法检查此时系统是否安全。如图所示。 P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查： Request4(3，3，0)≤Need4(4，3，1)； Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正） P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)； Request0(0，2，0)≤Available(2，3，0)； 系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 https://blog.csdn.net/cout_sev/article/details/24980627 死锁的检测 每种资源都只有单个实例 创建等待图,如果等待图成环就代表发生了死锁 多个实例的死锁检测 数据结构 示例 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4 假如p2 又请求了资源C的实例 此时就发生了死锁 死锁解除 一旦检测出死锁,应立即采取相应的措施,如: 资源剥夺法 挂起某些死锁进程,并抢占其资源,给其他的死锁进程 撤销进程法 强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价. 进程回退法 让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点. ","date":"2018-11-30","objectID":"/posts/operating-system/:4:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的预防"},{"categories":[],"content":" 死锁的预防、避免和检测算法。 资源分配策略 各种可能模式 主要优点 主要缺点 死锁预防 保守,宁可资源闲置 一次请求所有资源,资源剥夺,资源按序分配 适用与做突发式处理的进程,不必进行剥夺 效率低;剥夺次数多;不便灵活申请新资源 死锁避免 折中(在运行时判断是否可能死锁) 寻找可能的安全允许顺序 不必进行剥夺 必须知道将来的资源需求;进程不能被长时间阻塞 死锁检测 宽松,只要允许就分配资源 定期检查死锁是否已经发生 不延长进程初始化事件,允许堆死锁进行现场处理 通过剥夺解除死锁,造成损失 死锁的预防破坏死锁的四个必要条件之一 破坏互斥条件 如果允许所有资源都可以共享使用即可. 破坏非抢占 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源. 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源. 破坏占有并等待 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源. 缺点: 系统资源被严重浪费,而且还会导致饥饿. 破坏循环等待 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源. 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦. 死锁的避免在资源动态分配过程中防止系统进入不安全的状态. 系统安全状态 对于进程顺序, pi还需要的资源数 \u003c 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表 进程 最大需求 已分配 可用 P1 10 5 3 P2 4 2 P3 9 2 存在一个安全序列，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态. 如果此时分配1个磁带机给p3,此时就处于不安全状态了. 资源分配图法(每个资源的实例只有一个) 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了. 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数 银行家算法 当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源; 进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数. 银行家算法的数据结构 可利用资源向量Available 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 需求矩阵Need。 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 Need[i,j]=Max[i,j] - Allocation[i,j] 算法过程: 银行家算法 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： 如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 系统试探着把资源分配给进程P i，并修改下面数据结构中的数值： Available[j]:= Available[j]-Request i[j]； Allocation[i,j]:= Allocation[i,j]+Request i[j]； Need[i,j]:= Need[i,j]-Request i[j]； 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性检测算法 设置两个向量： 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。 Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。 从进程集合中找到一个能满足下述条件的进程： Finish[i]=false； Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:= Work[j]+Allocation[i,j]； Finish[i]:=true； go to step （2）; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 示例 假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号） T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。 P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查： Request1(1，0，2)≤Need1(1，2，2) Request1(1，0，2)≤Available1(3，3，2) 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示 再利用安全性算法检查此时系统是否安全。如图所示。 P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查： Request4(3，3，0)≤Need4(4，3，1)； Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正） P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)； Request0(0，2，0)≤Available(2，3，0)； 系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 https://blog.csdn.net/cout_sev/article/details/24980627 死锁的检测 每种资源都只有单个实例 创建等待图,如果等待图成环就代表发生了死锁 多个实例的死锁检测 数据结构 示例 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4 假如p2 又请求了资源C的实例 此时就发生了死锁 死锁解除 一旦检测出死锁,应立即采取相应的措施,如: 资源剥夺法 挂起某些死锁进程,并抢占其资源,给其他的死锁进程 撤销进程法 强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价. 进程回退法 让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点. ","date":"2018-11-30","objectID":"/posts/operating-system/:4:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的避免"},{"categories":[],"content":" 死锁的预防、避免和检测算法。 资源分配策略 各种可能模式 主要优点 主要缺点 死锁预防 保守,宁可资源闲置 一次请求所有资源,资源剥夺,资源按序分配 适用与做突发式处理的进程,不必进行剥夺 效率低;剥夺次数多;不便灵活申请新资源 死锁避免 折中(在运行时判断是否可能死锁) 寻找可能的安全允许顺序 不必进行剥夺 必须知道将来的资源需求;进程不能被长时间阻塞 死锁检测 宽松,只要允许就分配资源 定期检查死锁是否已经发生 不延长进程初始化事件,允许堆死锁进行现场处理 通过剥夺解除死锁,造成损失 死锁的预防破坏死锁的四个必要条件之一 破坏互斥条件 如果允许所有资源都可以共享使用即可. 破坏非抢占 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源. 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源. 破坏占有并等待 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源. 缺点: 系统资源被严重浪费,而且还会导致饥饿. 破坏循环等待 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源. 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦. 死锁的避免在资源动态分配过程中防止系统进入不安全的状态. 系统安全状态 对于进程顺序, pi还需要的资源数 \u003c 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表 进程 最大需求 已分配 可用 P1 10 5 3 P2 4 2 P3 9 2 存在一个安全序列，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态. 如果此时分配1个磁带机给p3,此时就处于不安全状态了. 资源分配图法(每个资源的实例只有一个) 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了. 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数 银行家算法 当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源; 进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数. 银行家算法的数据结构 可利用资源向量Available 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 需求矩阵Need。 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 Need[i,j]=Max[i,j] - Allocation[i,j] 算法过程: 银行家算法 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： 如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 系统试探着把资源分配给进程P i，并修改下面数据结构中的数值： Available[j]:= Available[j]-Request i[j]； Allocation[i,j]:= Allocation[i,j]+Request i[j]； Need[i,j]:= Need[i,j]-Request i[j]； 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性检测算法 设置两个向量： 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。 Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。 从进程集合中找到一个能满足下述条件的进程： Finish[i]=false； Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:= Work[j]+Allocation[i,j]； Finish[i]:=true； go to step （2）; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 示例 假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号） T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。 P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查： Request1(1，0，2)≤Need1(1，2，2) Request1(1，0，2)≤Available1(3，3，2) 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示 再利用安全性算法检查此时系统是否安全。如图所示。 P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查： Request4(3，3，0)≤Need4(4，3，1)； Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正） P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)； Request0(0，2，0)≤Available(2，3，0)； 系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 https://blog.csdn.net/cout_sev/article/details/24980627 死锁的检测 每种资源都只有单个实例 创建等待图,如果等待图成环就代表发生了死锁 多个实例的死锁检测 数据结构 示例 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4 假如p2 又请求了资源C的实例 此时就发生了死锁 死锁解除 一旦检测出死锁,应立即采取相应的措施,如: 资源剥夺法 挂起某些死锁进程,并抢占其资源,给其他的死锁进程 撤销进程法 强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价. 进程回退法 让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点. ","date":"2018-11-30","objectID":"/posts/operating-system/:4:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#死锁的检测"},{"categories":[],"content":" （五）存储器管理","date":"2018-11-30","objectID":"/posts/operating-system/:5:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#五存储器管理"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#分区存储管理覆盖与交换"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#工作集和驻留集"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#连续分配方式"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#覆盖"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#交换"},{"categories":[],"content":" 分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#覆盖与交换比较"},{"categories":[],"content":" 页式管理及段式管理； 页式管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 页式管理方式的优点是： 没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是: 一个程序不必连续存放。 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。 段式管理在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等 每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。 页式和段式区别 需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。 逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页式管理及段式管理"},{"categories":[],"content":" 页式管理及段式管理； 页式管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 页式管理方式的优点是： 没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是: 一个程序不必连续存放。 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。 段式管理在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等 每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。 页式和段式区别 需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。 逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页式管理"},{"categories":[],"content":" 页式管理及段式管理； 页式管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 页式管理方式的优点是： 没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是: 一个程序不必连续存放。 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。 段式管理在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等 每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。 页式和段式区别 需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。 逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#段式管理"},{"categories":[],"content":" 页式管理及段式管理； 页式管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 页式管理方式的优点是： 没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是: 一个程序不必连续存放。 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。 段式管理在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等 每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。 页式和段式区别 需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。 逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页式和段式区别"},{"categories":[],"content":" 段、页式存储管理方法及实现技术； 页式存储进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。 基本地址变换 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制) 计算页号P=A/L,页内偏移W=A%L 比较页号P和页表长度M,若P\u003e=M则产生越界中断 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号). 计算E=b*L+W得结果 页式管理中地址空间是一维的 页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log21M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小\u003e=20/8向上去整=3B. 具有快表的地址变换 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中. 两级页表 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈； 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项 段式存储段式存储更易于信息共享.比说代码段多用户共享. 地址变换 为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S\u003eTL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,再检查段内地址 d 是否超过该段的段长 SL。若超过,即 d\u003eSL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。 段页式存储管理方式段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。 在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S\u003cTL,表示未越界,于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置,从中得到该段的页表始址,并利用逻辑地址中的段内页号 P 来获得对应页的页表项位置,从中读出该页所在的物理块号 b,再利用块号 b 和页内地址来构成物理地址。 https://blog.csdn.net/hguisu/article/details/5713164 ","date":"2018-11-30","objectID":"/posts/operating-system/:5:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#段页式存储管理方法及实现技术"},{"categories":[],"content":" 段、页式存储管理方法及实现技术； 页式存储进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。 基本地址变换 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制) 计算页号P=A/L,页内偏移W=A%L 比较页号P和页表长度M,若P\u003e=M则产生越界中断 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号). 计算E=b*L+W得结果 页式管理中地址空间是一维的 页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log21M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小\u003e=20/8向上去整=3B. 具有快表的地址变换 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中. 两级页表 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈； 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项 段式存储段式存储更易于信息共享.比说代码段多用户共享. 地址变换 为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S\u003eTL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,再检查段内地址 d 是否超过该段的段长 SL。若超过,即 d\u003eSL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。 段页式存储管理方式段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。 在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S","date":"2018-11-30","objectID":"/posts/operating-system/:5:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页式存储"},{"categories":[],"content":" 段、页式存储管理方法及实现技术； 页式存储进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。 基本地址变换 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制) 计算页号P=A/L,页内偏移W=A%L 比较页号P和页表长度M,若P\u003e=M则产生越界中断 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号). 计算E=b*L+W得结果 页式管理中地址空间是一维的 页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log21M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小\u003e=20/8向上去整=3B. 具有快表的地址变换 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中. 两级页表 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈； 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项 段式存储段式存储更易于信息共享.比说代码段多用户共享. 地址变换 为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S\u003eTL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,再检查段内地址 d 是否超过该段的段长 SL。若超过,即 d\u003eSL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。 段页式存储管理方式段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。 在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S","date":"2018-11-30","objectID":"/posts/operating-system/:5:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#段式存储"},{"categories":[],"content":" 段、页式存储管理方法及实现技术； 页式存储进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。 基本地址变换 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制) 计算页号P=A/L,页内偏移W=A%L 比较页号P和页表长度M,若P\u003e=M则产生越界中断 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号). 计算E=b*L+W得结果 页式管理中地址空间是一维的 页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log21M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小\u003e=20/8向上去整=3B. 具有快表的地址变换 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中. 两级页表 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈； 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项 段式存储段式存储更易于信息共享.比说代码段多用户共享. 地址变换 为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S\u003eTL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,再检查段内地址 d 是否超过该段的段长 SL。若超过,即 d\u003eSL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。 段页式存储管理方式段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。 在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S","date":"2018-11-30","objectID":"/posts/operating-system/:5:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#段页式存储管理方式"},{"categories":[],"content":" 虚存的原理及相关的各种算法和数据结构。 虚存的概念 传统的存储管理方式的特征 一次性: 作业必须一次性全部装入内存,才能运行 驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束 虚存的定义和特征 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。 多次性: 无需在作业运行时一次性地全部装入内存. 对换性: 允许作业在运行过程中,进行换进换出 虚拟性: 从逻辑上扩充内存的容量 一定要有一下几个方面 一定的内存和外存 页表机制 缺页中断机构 地址变换机构(MMU) 页面置换算法 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. 先进先出(FIFO)算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现 Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现. 最久未使用(LRU)置换算法 选择最长时间未访问过的页面予以淘汰.堆栈类算法 时钟(CLOCK)置换算法,又称最近未用算法(NRU) 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间 优先级: u=0,m=0\u003eu=0,m=1 页面分配策略给特定的进程分配多大的主存空间 固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换 可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配 可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点. ","date":"2018-11-30","objectID":"/posts/operating-system/:5:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#虚存的原理及相关的各种算法和数据结构"},{"categories":[],"content":" 虚存的原理及相关的各种算法和数据结构。 虚存的概念 传统的存储管理方式的特征 一次性: 作业必须一次性全部装入内存,才能运行 驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束 虚存的定义和特征 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。 多次性: 无需在作业运行时一次性地全部装入内存. 对换性: 允许作业在运行过程中,进行换进换出 虚拟性: 从逻辑上扩充内存的容量 一定要有一下几个方面 一定的内存和外存 页表机制 缺页中断机构 地址变换机构(MMU) 页面置换算法 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. 先进先出(FIFO)算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现 Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现. 最久未使用(LRU)置换算法 选择最长时间未访问过的页面予以淘汰.堆栈类算法 时钟(CLOCK)置换算法,又称最近未用算法(NRU) 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间 优先级: u=0,m=0\u003eu=0,m=1 页面分配策略给特定的进程分配多大的主存空间 固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换 可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配 可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点. ","date":"2018-11-30","objectID":"/posts/operating-system/:5:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#虚存的概念"},{"categories":[],"content":" 虚存的原理及相关的各种算法和数据结构。 虚存的概念 传统的存储管理方式的特征 一次性: 作业必须一次性全部装入内存,才能运行 驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束 虚存的定义和特征 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。 多次性: 无需在作业运行时一次性地全部装入内存. 对换性: 允许作业在运行过程中,进行换进换出 虚拟性: 从逻辑上扩充内存的容量 一定要有一下几个方面 一定的内存和外存 页表机制 缺页中断机构 地址变换机构(MMU) 页面置换算法 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. 先进先出(FIFO)算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现 Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现. 最久未使用(LRU)置换算法 选择最长时间未访问过的页面予以淘汰.堆栈类算法 时钟(CLOCK)置换算法,又称最近未用算法(NRU) 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间 优先级: u=0,m=0\u003eu=0,m=1 页面分配策略给特定的进程分配多大的主存空间 固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换 可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配 可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点. ","date":"2018-11-30","objectID":"/posts/operating-system/:5:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页面置换算法"},{"categories":[],"content":" 虚存的原理及相关的各种算法和数据结构。 虚存的概念 传统的存储管理方式的特征 一次性: 作业必须一次性全部装入内存,才能运行 驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束 虚存的定义和特征 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。 多次性: 无需在作业运行时一次性地全部装入内存. 对换性: 允许作业在运行过程中,进行换进换出 虚拟性: 从逻辑上扩充内存的容量 一定要有一下几个方面 一定的内存和外存 页表机制 缺页中断机构 地址变换机构(MMU) 页面置换算法 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. 先进先出(FIFO)算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现 Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现. 最久未使用(LRU)置换算法 选择最长时间未访问过的页面予以淘汰.堆栈类算法 时钟(CLOCK)置换算法,又称最近未用算法(NRU) 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间 优先级: u=0,m=0\u003eu=0,m=1 页面分配策略给特定的进程分配多大的主存空间 固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换 可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配 可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点. ","date":"2018-11-30","objectID":"/posts/operating-system/:5:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#页面分配策略"},{"categories":[],"content":" （六）单处理器调度","date":"2018-11-30","objectID":"/posts/operating-system/:6:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#六单处理器调度"},{"categories":[],"content":" 处理器的三种调度类型； 作业调度(高级调度) 从外存的后备队列中选择一批作业进入内存，为他们建立进程。这些进程被送入就绪队列。频率最低.多道批处理系统才有. 中级调度 将暂时不能运行的进程调至外存等待,为了提高内存利用率和系统吞吐量 进程调度(低级调度) 按照某种方法和策略从就绪队列中选取一个进程执行. ","date":"2018-11-30","objectID":"/posts/operating-system/:6:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#处理器的三种调度类型"},{"categories":[],"content":" 调度算法的分类 抢占和非抢占调度 根据任务运行的过程中能否被中断的情况，把调度算法分为抢占和非抢占两种。在抢占式调度算法中，正在运行的任务可以被其他任务打断。在非抢占式调度算法中，一旦任务开始运行，该任务只有在运行完后而主动放弃CPU资源或者是因为等待其他资源而被阻塞的情况下才可能停止。 静态和动态调度 根据任务优先级确定的时机，把调度算法分为静态调度和动态调度两种。在静态调度算法中，所有任务的优先级在运行之前已经确定下来，这就要求能够完全把握系统中的所有任务及其时间约束（如截止时间，运行时间，优先顺序等）。在动态调度算法中，任务的优先级在在运行时确定，并且可能不断的发生变化。 原文：https://blog.csdn.net/Stephan14/article/details/46468241 ","date":"2018-11-30","objectID":"/posts/operating-system/:6:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#调度算法的分类"},{"categories":[],"content":" 进程调度方式 当一个进程从运行状态切换到等待状态(例如,IO请求,调用wait) 当一个进程从运行状态切换到就绪状态(例如,出现中断) 当一个进程从等待状态切换到就绪状态(例如,IO完成时) 当一个进程终止时 当调度只发生在1和4两种情况时,称为非抢断.否则是抢断的. ","date":"2018-11-30","objectID":"/posts/operating-system/:6:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#进程调度方式"},{"categories":[],"content":" 调度准则 CPU使用率 吞吐量: 单位事件内完成进程的数量 周转时间: 从某个特定的进程的角度看,从进程提交到进程完成的时间段.包括,等待进入内存,在就绪队列中等待,在cpu执行和IO执行 等待时间: 进程在就绪队列中等待所花费时间之和. 响应时间: 在交互系统中,从提交请求到产生第一响应的事件.就是开始响应所需要的时间 ","date":"2018-11-30","objectID":"/posts/operating-system/:6:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#调度准则"},{"categories":[],"content":" 进程调度的各种算法及其特点。 先到先服务调度(FCFS:first-come,first-served) 最短作业优先调度(SJF:shortest-job-first)非抢占式 最短剩余事件优先调度(SRTN:shortest-remaining-time-first) 抢占式的SJF 优先级调度（Priority Scheduling）/一般用小数字表示高优先级 缺陷: 叽饿;无穷阻塞,低优先级的无穷等待 解决方法: 老化(aging),逐渐增加系统中等待事件长的进程的优先级 轮转法(Round Robin，RR)专门为分时系统设计 每个就绪进程获得一小段CPU时间（时间片，time quantum），通常10ms - 100ms 时间片用毕，这个进程被迫交出CPU，重新挂回到就绪队列,当然，进程在时间片用毕之前其Burst Cycle结束，也（主动）交出CPU 假设n个就绪进程，时间片q，每个就绪进程得到1/n的CPU时间。任何就绪进程最多等待(n-1)*q单位时间. 轮转法还有一个好处，就是他的响应时间一定优于前面的SJF。因为时间片的存在。 多级队列调度 要求交互的进程，在前台队列。可以批处理的进程，在后台队列。 每个队列都有其自己的调度算法，例如： 前台就绪队列 — RR 后台就绪队列 — FCFS 按优先级分别为： 系统进程队列，要实时响应。 交互进程队列（要求响应非常及时）—— RR 交互编辑队列（人输入键盘，移动鼠标等，响应时间可能半秒也可以，对操作系统来说已经很长了。交互要求不是很高）—— RR 批处理进程队列，不需要交互。—— FCFS CPU怎么在队列间分配？ 固定优先权法。例如，先前台队列，再后台队列。 时间片办法，例如，80%的CPU时间给前台队列，20%CPU时间给后台进程。 多层反馈队列调度 图上三层队列： Q0 — 用RR算法，时间片8ms Q1 — 用RR算法，时间片16ms Q2 — 用FCFS算法。 调度场景 一个就绪进程进入Q0层，当它分配到CPU，可执行8ms。如果它8ms后没有执行完毕，则迁移至Q1层。否则，它离开就绪队列该干嘛干嘛。 在Q1层，当它分配到CPU，可执行16ms。如果它16ms后没有执行完毕，则迁移至Q2层。否则，它离开就绪队列，该干嘛干嘛。 总结 忽略HRRN,Feedback https://www.jianshu.com/p/65360b500ad9 ","date":"2018-11-30","objectID":"/posts/operating-system/:6:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#进程调度的各种算法及其特点"},{"categories":[],"content":" （七）多处理器调度和实时调度","date":"2018-11-30","objectID":"/posts/operating-system/:7:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#七多处理器调度和实时调度"},{"categories":[],"content":" 多处理器对进程调度的影响； 处理器亲和性 由于使缓存无效或重新构建的代价高,绝大多数SMP系统试图避免将进程从一个处理器移至另一个处理器,而是努力使-个进程在同一个处理器上运行,这被称为处理器亲和性. 当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略,但不能做任何保证时,则会出现软亲和性,有可能在处理器之间移动。,还提供一个支持硬亲和性的系统调用,从而允许进程指定它不允许移至其他处理器上。 负载均衡 ","date":"2018-11-30","objectID":"/posts/operating-system/:7:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#多处理器对进程调度的影响"},{"categories":[],"content":" 多处理器环境下的进程和线程调度算法； CPU调度 全局队列调度 操作系统维护一个全局的任务等待队列。 当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。 这种方法的优点是CPU核心利用率较高。 局部队列调度 操作系统为每个CPU内核维护一个局部的任务等待队列。 当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行。 这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。 目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。 ","date":"2018-11-30","objectID":"/posts/operating-system/:7:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#多处理器环境下的进程和线程调度算法"},{"categories":[],"content":" 多处理器环境下的进程和线程调度算法； CPU调度 全局队列调度 操作系统维护一个全局的任务等待队列。 当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。 这种方法的优点是CPU核心利用率较高。 局部队列调度 操作系统为每个CPU内核维护一个局部的任务等待队列。 当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行。 这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。 目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。 ","date":"2018-11-30","objectID":"/posts/operating-system/:7:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#cpu调度"},{"categories":[],"content":" 实时进程的特点； 这些进程往往执行非常重要的操作,要求立即响应并执行 只能被更高优先级的实时进程抢占 比普通进程的优先级都要高 ","date":"2018-11-30","objectID":"/posts/operating-system/:7:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#实时进程的特点"},{"categories":[],"content":" 限期调度和速率单调调度方法。实时系统的可调度条件: (有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间来处理事件) 速率单调调度（实时静态算法）Rate Monotonic Scheduling，RMS 以用于满足以下条件的进程： 每个周期性进程必须在其周期内完成。 没有进程依赖于任何其他进程。 每一个进程在一次突发中需要相同的CPU时间量。 任何非周期进程都没有最终时限。 进程抢占时刻发生而没有系统开销。（理想模型） 单调速率算法按照以下规则给进程设立优先级：比如A进程每30ms运行一次，则每秒运行33次，则获得优先级33；B进程每秒运行20次，则获得优先级20，所以优先级与速率成线性关系，这就是这个算法的名字的来历。RMS算法是最优的实时静态算法中。 如果 成立,则其可以正常工作 最早最终时限调度（实时动态算法）Earliest Deadline First，EDF 列表按最终时限排序，EDF算法运行列表中的第一个进程，也是具有最近最终时限的进程。当一个新的进程就绪时，系统进行检查以了解其最终时限是否发生在当前运行的进程结束之前。如果是这样，那么新的进程就抢占当前正在运行的进程。 对比 对于RMS来说,前70ms,A以30ms为周期,每秒运行33次故优先级为33,同理得优先级A\u003eB\u003eC(33\u003e25\u003e20),在90ms时,A4的优先级高于B,所以抢占. 对于EDF来说,最终期限就是下一周期的起始时刻.在90ms时A和B的最终期限一样,不进行抢占 由于RMS的优先级只于速率有关,而与进程运行时间无关,所以在40-50ms时选择了执行B导致C未在下个周期开始前执行,导致失败. https://www.cnblogs.com/Philip-Tell-Truth/p/6680529.html ","date":"2018-11-30","objectID":"/posts/operating-system/:7:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#限期调度和速率单调调度方法"},{"categories":[],"content":" （八）设备管理和磁盘调度","date":"2018-11-30","objectID":"/posts/operating-system/:8:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#八设备管理和磁盘调度"},{"categories":[],"content":" 操作系统中输入/输出功能的组织； I/O控制方式外围设备和内存之间的I/O控制方式: 程序直接控制法 无中断机制,cpu对外设状态进行循环检查 中断驱动方式 I/O控制器收到cpu的一个读命令之后cpu就做其他事情,一旦数据读入,I/O控制器给CPU发送中断信号,表示数据已准备好.然后等待CPU请求该数据. 但由于每个字再存储器与I/O设备之间的传输必须经过cpu,导致了消耗过多的cpu时间 DMA方式 (直接内存访问) 通道控制方式 I/O通道和DMA方式的区别是:DMA方式需要CPU来控制传输的数据块大小,传输的内存位置,而I/O通道方式中这些信息由通道控制.另外,每个DMA控制器对应一台设备与内存传递数据,而一个通道可以控制多台设备与内存的数据交换. ","date":"2018-11-30","objectID":"/posts/operating-system/:8:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#操作系统中输入输出功能的组织"},{"categories":[],"content":" 操作系统中输入/输出功能的组织； I/O控制方式外围设备和内存之间的I/O控制方式: 程序直接控制法 无中断机制,cpu对外设状态进行循环检查 中断驱动方式 I/O控制器收到cpu的一个读命令之后cpu就做其他事情,一旦数据读入,I/O控制器给CPU发送中断信号,表示数据已准备好.然后等待CPU请求该数据. 但由于每个字再存储器与I/O设备之间的传输必须经过cpu,导致了消耗过多的cpu时间 DMA方式 (直接内存访问) 通道控制方式 I/O通道和DMA方式的区别是:DMA方式需要CPU来控制传输的数据块大小,传输的内存位置,而I/O通道方式中这些信息由通道控制.另外,每个DMA控制器对应一台设备与内存传递数据,而一个通道可以控制多台设备与内存的数据交换. ","date":"2018-11-30","objectID":"/posts/operating-system/:8:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#io控制方式"},{"categories":[],"content":" 中断处理； 应用进程请求读操作。 设备启动程序（设备驱动程序的上半部分）查询设备控制器的状态寄存器，确定设备是否空闲；如果设备忙，则设备启动程序等待，直到它变为空闲为止。 设备启动程序把输入命令存入设备控制器的命令寄存器中，从而启动设备。 设备启动程序将相应信息写入到设备状态表的设备对应表项中，如最初调用的返回地址，以及I／O操作的一些特定参数等。然后CPU就可以分配给其他进程使用了，因此设备管理器调用进程管理器的调度程序执行，原进程的执行就被暂停了。 经过一段时间设备完成了I／O操作后，设备控制器发出中断请求，中断CPU上运行的进程，从而引起CPU运行中断处理程序。 中断处理程序确定是哪个设备引起的中断，然后转移到该设备对应的设备处理程序（设备驱动程序的下半部分）执行（唤醒设备驱动程序）。 设备处理程序重新从设备状态表中，找到等待I／O操作的状态信息。 设备处理程序拷贝设备控制器的数据寄存器的内容到用户进程的内存区。 设备处理程序返回给应用进程控制权，从而继续运行。 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#中断处理"},{"categories":[],"content":" 设备驱动程序、设备无关的软件接口和spooling技术； I/O子系统层次结构 用户层I/O软件 实现与用户交互的接口 设备独立性软件 实现用户程序与设备驱动器的统一接口,设备命令,设备保护,设备分配与释放 设备无关软件接口 这类设备无关性软件面向应用层并提供一个统一的应用编程接口(API)，它提供了一组功能函数，应用程序员能够通过调用它们管理设备。这个接口是设备硬件的一个大大简化了的简单抽象的接口，提供的是对具有逻辑性质的逻辑设备上的逻辑操作。由文件系统和设备管理功能接受、翻译、转换为相应的物理设备、物理性质、物理操作。与设备无关的系统软件实现的功能有：设备驱动程序的统一接口，设备命名，设备保护，提供一个与设备无关的逻辑块，缓冲，存储设备的块分配，独占设备的分配和释放，错误处理等。 设备驱动程序 与硬件直接相关,负责具体实现系统对设备放出的操作指令. 主要功能将来自上层软件的与设备无关的的抽象请求转为具体请求，向有关的输入输出设备的各种控制器的寄存器发出控制命令，并监督它们的正确执行，进行必要的错误处理。还要对各种可能的有关设备排队、挂起、唤醒等操作进行处理，执行确定的缓冲区策略等 中断处理程序 用于处理中断相关事项. 硬件 包括一个机械部件和一个电子部件(控制器) spooling 就是把磁盘当做缓冲区. 当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正 立即把打印机分配给该用户进程，而只为它做两件事： 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中.输出进程再为用户进程申请一张空白的用户请求打印表 将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#设备驱动程序设备无关的软件接口和spooling技术"},{"categories":[],"content":" 设备驱动程序、设备无关的软件接口和spooling技术； I/O子系统层次结构 用户层I/O软件 实现与用户交互的接口 设备独立性软件 实现用户程序与设备驱动器的统一接口,设备命令,设备保护,设备分配与释放 设备无关软件接口 这类设备无关性软件面向应用层并提供一个统一的应用编程接口(API)，它提供了一组功能函数，应用程序员能够通过调用它们管理设备。这个接口是设备硬件的一个大大简化了的简单抽象的接口，提供的是对具有逻辑性质的逻辑设备上的逻辑操作。由文件系统和设备管理功能接受、翻译、转换为相应的物理设备、物理性质、物理操作。与设备无关的系统软件实现的功能有：设备驱动程序的统一接口，设备命名，设备保护，提供一个与设备无关的逻辑块，缓冲，存储设备的块分配，独占设备的分配和释放，错误处理等。 设备驱动程序 与硬件直接相关,负责具体实现系统对设备放出的操作指令. 主要功能将来自上层软件的与设备无关的的抽象请求转为具体请求，向有关的输入输出设备的各种控制器的寄存器发出控制命令，并监督它们的正确执行，进行必要的错误处理。还要对各种可能的有关设备排队、挂起、唤醒等操作进行处理，执行确定的缓冲区策略等 中断处理程序 用于处理中断相关事项. 硬件 包括一个机械部件和一个电子部件(控制器) spooling 就是把磁盘当做缓冲区. 当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正 立即把打印机分配给该用户进程，而只为它做两件事： 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中.输出进程再为用户进程申请一张空白的用户请求打印表 将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#io子系统层次结构"},{"categories":[],"content":" 设备驱动程序、设备无关的软件接口和spooling技术； I/O子系统层次结构 用户层I/O软件 实现与用户交互的接口 设备独立性软件 实现用户程序与设备驱动器的统一接口,设备命令,设备保护,设备分配与释放 设备无关软件接口 这类设备无关性软件面向应用层并提供一个统一的应用编程接口(API)，它提供了一组功能函数，应用程序员能够通过调用它们管理设备。这个接口是设备硬件的一个大大简化了的简单抽象的接口，提供的是对具有逻辑性质的逻辑设备上的逻辑操作。由文件系统和设备管理功能接受、翻译、转换为相应的物理设备、物理性质、物理操作。与设备无关的系统软件实现的功能有：设备驱动程序的统一接口，设备命名，设备保护，提供一个与设备无关的逻辑块，缓冲，存储设备的块分配，独占设备的分配和释放，错误处理等。 设备驱动程序 与硬件直接相关,负责具体实现系统对设备放出的操作指令. 主要功能将来自上层软件的与设备无关的的抽象请求转为具体请求，向有关的输入输出设备的各种控制器的寄存器发出控制命令，并监督它们的正确执行，进行必要的错误处理。还要对各种可能的有关设备排队、挂起、唤醒等操作进行处理，执行确定的缓冲区策略等 中断处理程序 用于处理中断相关事项. 硬件 包括一个机械部件和一个电子部件(控制器) spooling 就是把磁盘当做缓冲区. 当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正 立即把打印机分配给该用户进程，而只为它做两件事： 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中.输出进程再为用户进程申请一张空白的用户请求打印表 将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#spooling"},{"categories":[],"content":" 缓冲策略； 单缓冲 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为 C。由于T和C是可以并行的，当T\u003eC时，系统对每一块数据的处理时间为M+T，反之则为M+C，故可把系统对每一块数据的处理时间表示为Max(C, T)+M. 双缓冲 据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。 I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。双缓冲机制提高了处理机和输入设备的并行操作的程度。 处理用时 MAX(C+M,T) 循环缓冲 包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。（类似于循环队列） 循环缓冲用于输入/输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反。 缓冲池 由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列： 空缓冲队列 装满输入数据的缓冲队列（输入队列） 装满输出数据的缓沖队列（输出队列）。 还应具有四种缓冲区： 用于收容输入数据的工作缓冲区 用于提取输入数据的工作缓冲区 用于收容输出数据的工作缓冲区 用于提取输出数据的工作缓冲区。 当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。 当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。 当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。 当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#缓冲策略"},{"categories":[],"content":" 磁盘调度算法；假设当前磁头在67号，要求访问的磁道号顺序为98,25,63,97,56,51,55,55,6 (电脑随机产生的,设定最外层磁道号为100号) FIFO：先来先服务算法； 假设当前磁道在某一位置，依次处理服务队列里的每一个磁道，这样做的优点是处理起来比较简单，但缺点是磁头移动的距离和平均移动距离会很大。 FIFO算法的服务序列是：98,25,63,97,56,51,55,55,6 磁头移动的总距离distance = (98-67)+(98-25)+(63-25)+(97-63)+(97-56)+(56-51)+(55-51)+(55-55)+(55-6) SSTF： 最短寻道时间算法； 假设当前磁道在某一位置，接下来处理的是距离当前磁道最近的磁道号，处理完成之后再处理离这个磁道号最近的磁道号，直到所有的磁道号都服务完了程序结束. 这样做的优点是性能会优于FIFO算法，但是会产生距离当前磁道较远的磁道号长期得不到服务，也就是“饥饿”现象，因为要求访问的服务的序列号是动态产生的，即各个应用程序可能不断地提出访问不同的磁道号的请求。 SSTF算法的服务序列是: 63,56,55,55,51,25,6,97,98 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97) SCAN：电梯调度算法；(这样命名很形象) 先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描，这里要注意，假设最里层为0号磁道，最里面的一个要求服务的序列是5号，访问完5号之后，就反向了，不需要再往里扫。结合电梯过程更好理解，在电梯往下接人的时候，明知道最下面一层是没有人的，它是不会再往下走的。(LOOK调度才是如此) SCAN算法的服务序列是：63,56,55,55,51,25,6,97,98 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97) CSCAN： 循环扫描算法 (C-LOOK) 由于上边的算法在磁头折返回去的时候,会导致很长一段时间可能没有服务.因为最近已经访问过了. 访问完最里面一个要求服务的序列之后，立即回到最外层欲访问磁道。也就是始终保持一个方向。故也称之为单向扫描调度算法。从最里面的一个磁道立即回到最外层欲访问的磁道，这步的距离是两者磁道号差的绝对值。 CSCAN算法的服务序列是：63,56,55,55,51,25,6,98,97 distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+|6-98|+(98-97 FSCAN：分步电梯调度算法(分两个队列) 在扫描的过程中所有新产生的序列放在另外的一个队列中，当访问完当前队列之后，再访问新产生的一个队列。这种算法可以有效防止磁壁粘着现象。 https://blog.csdn.net/Jaster_wisdom/article/details/52345674 ","date":"2018-11-30","objectID":"/posts/operating-system/:8:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#磁盘调度算法"},{"categories":[],"content":" 磁盘阵列(Redundant Array of Independent Disks) RAID 0 没有冗余 RAID 1 原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件 RAID 2 差错纠正码 每个字节都有相关的奇偶位,存在其他磁盘上,损坏一位的时候可以恢复. RAID 3 交叉奇偶结构 按扇区为单位来计算奇偶值. RAID 4 块交织奇偶结构 按磁盘来计算奇偶值,计算结果存在一个磁盘上 RAID 5 按磁盘来计算奇偶值,结果保存在不同的磁盘上. RAID 6 类似 RAID 5 但是加入了差错纠正码等. ","date":"2018-11-30","objectID":"/posts/operating-system/:8:6","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#磁盘阵列redundant-array-of-independent-disks"},{"categories":[],"content":" （九）文件系统","date":"2018-11-30","objectID":"/posts/operating-system/:9:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#九文件系统"},{"categories":[],"content":" 文件系统特点与文件组织方式； 文件系统管理文件的软件,被管理的文件及数据结构 文件则是指具有文件名的若干相关元素的集合。元素通常是记录,而记录又是一组有意义的数据项的集合。 文件组织方式 无结构文件(流式文件): 以字节为单位,顺序存储.只能通过穷举搜索方式,来查找文件中的数据 有结构文件(记录式文件) 顺序文件: 记录一个接一个顺序排列 串结构: 记录之间的顺序与关键字无关,由时间决定 顺序结构: 按关键字排序 索引文件: 未变长文件建立索引表,提高查找速度 索引顺序文件: 索引文件与顺序文件相结合 直接文件: 通过hash函数直接决定记录的地址 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#文件系统特点与文件组织方式"},{"categories":[],"content":" 文件系统特点与文件组织方式； 文件系统管理文件的软件,被管理的文件及数据结构 文件则是指具有文件名的若干相关元素的集合。元素通常是记录,而记录又是一组有意义的数据项的集合。 文件组织方式 无结构文件(流式文件): 以字节为单位,顺序存储.只能通过穷举搜索方式,来查找文件中的数据 有结构文件(记录式文件) 顺序文件: 记录一个接一个顺序排列 串结构: 记录之间的顺序与关键字无关,由时间决定 顺序结构: 按关键字排序 索引文件: 未变长文件建立索引表,提高查找速度 索引顺序文件: 索引文件与顺序文件相结合 直接文件: 通过hash函数直接决定记录的地址 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#文件系统"},{"categories":[],"content":" 文件系统特点与文件组织方式； 文件系统管理文件的软件,被管理的文件及数据结构 文件则是指具有文件名的若干相关元素的集合。元素通常是记录,而记录又是一组有意义的数据项的集合。 文件组织方式 无结构文件(流式文件): 以字节为单位,顺序存储.只能通过穷举搜索方式,来查找文件中的数据 有结构文件(记录式文件) 顺序文件: 记录一个接一个顺序排列 串结构: 记录之间的顺序与关键字无关,由时间决定 顺序结构: 按关键字排序 索引文件: 未变长文件建立索引表,提高查找速度 索引顺序文件: 索引文件与顺序文件相结合 直接文件: 通过hash函数直接决定记录的地址 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#文件组织方式"},{"categories":[],"content":" 文件系统的数据结构； 链式文件系统 文件的块是分布在各个零散的空间中，这样对空间的利用率有极大的提升。但是想要放到到某个指定的块就必须从第一个块开始向下寻找，访问的速度较慢。 索引文件系统 为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。 索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。 间接索引表 每个索引表中有15个索引项，前12个索引项对应文件的12个块，他们是文件的直接块。若文件大于12块，就再建立一个新的块索引表，新索引表称为一级间接索引表，表中可容纳256个块地址，这个索引表也会占用一个物理块，老的索引表的第13个索引项就会指向这个索引表所在的物理块。通过一级间接索引表，文件最大可达到 12 + 256 = 268块。 超级块 在文件系统中，一个文件用一个inode表示，所有的inode组成了inode数组，这个inode数组存储在哪里，如何对其进行管理。文件系统中，哪些块被使用了，哪些块是空闲的，这些信息都需要记录，对这些数据进行统一管理和记录的数据结构叫做超级块 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#文件系统的数据结构"},{"categories":[],"content":" 目录的基本性质及其实现方法； 目录的结构 单级: 所有文件都放在一个目录下 两级: 在目录下分出用户目录 多级: 树形结构 无环图: 在树形结构上加入一些有向边 文件共享 基于索引节点(硬链接): 共享文件指向同一个索引节点,当索引节点的count==0是删除该节点 基于符号链(软链接): 保存共享文件的路径,类似快捷方式 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#目录的基本性质及其实现方法"},{"categories":[],"content":" 目录的基本性质及其实现方法； 目录的结构 单级: 所有文件都放在一个目录下 两级: 在目录下分出用户目录 多级: 树形结构 无环图: 在树形结构上加入一些有向边 文件共享 基于索引节点(硬链接): 共享文件指向同一个索引节点,当索引节点的count==0是删除该节点 基于符号链(软链接): 保存共享文件的路径,类似快捷方式 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#目录的结构"},{"categories":[],"content":" 目录的基本性质及其实现方法； 目录的结构 单级: 所有文件都放在一个目录下 两级: 在目录下分出用户目录 多级: 树形结构 无环图: 在树形结构上加入一些有向边 文件共享 基于索引节点(硬链接): 共享文件指向同一个索引节点,当索引节点的count==0是删除该节点 基于符号链(软链接): 保存共享文件的路径,类似快捷方式 ","date":"2018-11-30","objectID":"/posts/operating-system/:9:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#文件共享"},{"categories":[],"content":" 磁盘空间的管理。维护一个空闲空间链表. ","date":"2018-11-30","objectID":"/posts/operating-system/:9:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#磁盘空间的管理"},{"categories":[],"content":" （十）分布式系统","date":"2018-11-30","objectID":"/posts/operating-system/:10:0","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#十分布式系统"},{"categories":[],"content":" 分布式操作系统的类型 网络操作系统 ssh 分布式操作系统 ","date":"2018-11-30","objectID":"/posts/operating-system/:10:1","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#分布式操作系统的类型"},{"categories":[],"content":" 分布式处理的特点、类型； ","date":"2018-11-30","objectID":"/posts/operating-system/:10:2","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#分布式处理的特点类型"},{"categories":[],"content":" 多层体系结构、中间件技术； ","date":"2018-11-30","objectID":"/posts/operating-system/:10:3","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#多层体系结构中间件技术"},{"categories":[],"content":" 机群系统；分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上 ","date":"2018-11-30","objectID":"/posts/operating-system/:10:4","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#机群系统"},{"categories":[],"content":" 分布式进程管理相关的操作系统设计问题。 透明性: 对于用户来说很多事情无法知道 可伸缩性: 可多可少 可靠性 ","date":"2018-11-30","objectID":"/posts/operating-system/:10:5","series":null,"tags":["基础知识","考研","操作系统"],"title":"考研807操作系统复习笔记 - 旧笔记","uri":"/posts/operating-system/#分布式进程管理相关的操作系统设计问题"},{"categories":[],"content":"考研807数据结构复习笔记","date":"2018-11-19","objectID":"/posts/data-structure/","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/"},{"categories":[],"content":" （一）绪论","date":"2018-11-19","objectID":"/posts/data-structure/:1:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#一绪论"},{"categories":[],"content":" 数据结构的基本概念，数据的逻辑结构、存储结构； 逻辑结构: 线性结构 非线性结构 树 图 集合 存储结构 顺序存储 链接存储 索引存储 在存储的同时,还建立附加的索引表 散列存储 ","date":"2018-11-19","objectID":"/posts/data-structure/:1:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#数据结构的基本概念数据的逻辑结构存储结构"},{"categories":[],"content":" 数据结构的基本概念，数据的逻辑结构、存储结构； 逻辑结构: 线性结构 非线性结构 树 图 集合 存储结构 顺序存储 链接存储 索引存储 在存储的同时,还建立附加的索引表 散列存储 ","date":"2018-11-19","objectID":"/posts/data-structure/:1:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#逻辑结构"},{"categories":[],"content":" 数据结构的基本概念，数据的逻辑结构、存储结构； 逻辑结构: 线性结构 非线性结构 树 图 集合 存储结构 顺序存储 链接存储 索引存储 在存储的同时,还建立附加的索引表 散列存储 ","date":"2018-11-19","objectID":"/posts/data-structure/:1:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#存储结构"},{"categories":[],"content":" 算法的定义和应具有的特性，算法设计的要求，算法的时间复杂度分析和算法的空间复杂度分析。","date":"2018-11-19","objectID":"/posts/data-structure/:1:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#算法的定义和应具有的特性算法设计的要求算法的时间复杂度分析和算法的空间复杂度分析"},{"categories":[],"content":" （二）线性表","date":"2018-11-19","objectID":"/posts/data-structure/:2:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#二线性表"},{"categories":[],"content":" 线性结构的特点、线性表的定义，线性表的基本操作；list定义 线性表的顺序存储结构是一种随机存取的存储结构,线性表的链式存储结构是一种顺序存取的存储结构. ","date":"2018-11-19","objectID":"/posts/data-structure/:2:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#线性结构的特点线性表的定义线性表的基本操作"},{"categories":[],"content":" 线性表的顺序存储结构，对其进行检索、插入和删除等操作；","date":"2018-11-19","objectID":"/posts/data-structure/:2:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#线性表的顺序存储结构对其进行检索插入和删除等操作"},{"categories":[],"content":" 线性表的链式存储结构，单链表、双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作。","date":"2018-11-19","objectID":"/posts/data-structure/:2:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#线性表的链式存储结构单链表双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作"},{"categories":[],"content":" （三）栈和队列，递归算法","date":"2018-11-19","objectID":"/posts/data-structure/:3:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#三栈和队列递归算法"},{"categories":[],"content":" 栈的定义、结构特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法；","date":"2018-11-19","objectID":"/posts/data-structure/:3:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#栈的定义结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法"},{"categories":[],"content":" 队列的结构、特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法。循环队列实现 c // 初始化 Q.rear=Q.front=0; // 判断空 Q.rear==Q.front; // 判断队满 (Q.rear+1)%MAXSIZE==Q.front; // 队列长度 (Q.rear+MAXSIZE-Q.front)%MAXSIZE; ","date":"2018-11-19","objectID":"/posts/data-structure/:3:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#队列的结构特点及其存储方式顺序存储与链接存储和基本操作的实现算法"},{"categories":[],"content":" 递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法；","date":"2018-11-19","objectID":"/posts/data-structure/:3:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法"},{"categories":[],"content":" 用栈实现递归问题的非递归解法。","date":"2018-11-19","objectID":"/posts/data-structure/:3:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#用栈实现递归问题的非递归解法"},{"categories":[],"content":" （四）数组和串","date":"2018-11-19","objectID":"/posts/data-structure/:4:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#四数组和串"},{"categories":[],"content":" 串的基本概念、串的存储结构和相关的操作算法；","date":"2018-11-19","objectID":"/posts/data-structure/:4:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#串的基本概念串的存储结构和相关的操作算法"},{"categories":[],"content":" 数组的存储结构，在顺序存储的情况下，数组元素与存储单元的对应关系；","date":"2018-11-19","objectID":"/posts/data-structure/:4:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#数组的存储结构在顺序存储的情况下数组元素与存储单元的对应关系"},{"categories":[],"content":" 稀疏矩阵的存储结构和特点以及基本操作。对于矩阵中实际存储的元素\u003c\u003c矩阵大小时,可以只存取三元组(行标,列标,值)的list. ","date":"2018-11-19","objectID":"/posts/data-structure/:4:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#稀疏矩阵的存储结构和特点以及基本操作"},{"categories":[],"content":" 字符串匹配算法(例如KMP算法)。","date":"2018-11-19","objectID":"/posts/data-structure/:4:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#字符串匹配算法例如kmp算法"},{"categories":[],"content":" （五）树和森林","date":"2018-11-19","objectID":"/posts/data-structure/:5:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#五树和森林"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#树的结构和主要概念各种二叉树的结构及其特点"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#树的基本术语"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#二叉树的特点"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#二叉树的数组表示方法"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#二叉树与度为2的树的区别"},{"categories":[],"content":" 树的结构和主要概念，各种二叉树的结构及其特点； 树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#各种二叉树"},{"categories":[],"content":" 二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法； 遍历方法 先序遍历(PreOrder) 顺序:根节点,先序遍历左子树,先序遍历右子树 实现: 递归实现 非递归实现 c void PreOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ visit(p); Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); p=p-\u003erchild; } } } 中序遍历(InOrder) 顺序:中序遍历左子树,根节点,中序遍历右子树 实现: 递归实现 非递归实现 c void InOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); visit(p); p=p-\u003erchild; } } } 后序遍历(PostOrder) 顺序:后序遍历左子树,后序遍历右子树,根节点 实现: 递归实现 非递归实现: c void PostOrder(BiTree T){ InitStack(S); BiTree p = T; BiTree r = NULL: while(p||!IsEmpty(S)){ if(p){ push(S,p); p = p-\u003elchild; } else{ GetTop(S,p); if(p-\u003erchild\u0026\u0026p-\u003erchild!=r){ p=p-\u003erchild; push(S,p); p=p-\u003elchild; } else{ pop(S,p); visit(p-\u003edata); r=p; p=NULL; } } } } 根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而先序和后序则不能确定一颗二叉树 层次遍历 c void LevelOrder(BiTree T){ InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)){ Dequeue(Q,p); visit(p); if(p-\u003elchild!=NULL){ EnQueue(Q,p-\u003elchild); } if(p-\u003erchild!=NULL){ EnQueue(Q,p-\u003erchild); } } } 计算树的深度 c int BitDepth(BiTree T){ if (T==NULL) return 0; else{ ldep = Btdepth(T-\u003elchild); rdep = Btdepth(T-\u003erchild); if(ldep\u003erdep) return ldep+1; else return rdep+1; } } ","date":"2018-11-19","objectID":"/posts/data-structure/:5:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#二叉树的三种遍历方法的实现原理和性质能将二叉树的遍历方法应用于求解二叉树的叶子结点个数二叉树计数等问题遍历的非递归实现方法"},{"categories":[],"content":" 二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法； 遍历方法 先序遍历(PreOrder) 顺序:根节点,先序遍历左子树,先序遍历右子树 实现: 递归实现 非递归实现 c void PreOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ visit(p); Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); p=p-\u003erchild; } } } 中序遍历(InOrder) 顺序:中序遍历左子树,根节点,中序遍历右子树 实现: 递归实现 非递归实现 c void InOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); visit(p); p=p-\u003erchild; } } } 后序遍历(PostOrder) 顺序:后序遍历左子树,后序遍历右子树,根节点 实现: 递归实现 非递归实现: c void PostOrder(BiTree T){ InitStack(S); BiTree p = T; BiTree r = NULL: while(p||!IsEmpty(S)){ if(p){ push(S,p); p = p-\u003elchild; } else{ GetTop(S,p); if(p-\u003erchild\u0026\u0026p-\u003erchild!=r){ p=p-\u003erchild; push(S,p); p=p-\u003elchild; } else{ pop(S,p); visit(p-\u003edata); r=p; p=NULL; } } } } 根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而先序和后序则不能确定一颗二叉树 层次遍历 c void LevelOrder(BiTree T){ InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)){ Dequeue(Q,p); visit(p); if(p-\u003elchild!=NULL){ EnQueue(Q,p-\u003elchild); } if(p-\u003erchild!=NULL){ EnQueue(Q,p-\u003erchild); } } } 计算树的深度 c int BitDepth(BiTree T){ if (T==NULL) return 0; else{ ldep = Btdepth(T-\u003elchild); rdep = Btdepth(T-\u003erchild); if(ldep\u003erdep) return ldep+1; else return rdep+1; } } ","date":"2018-11-19","objectID":"/posts/data-structure/:5:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#遍历方法"},{"categories":[],"content":" 二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法； 遍历方法 先序遍历(PreOrder) 顺序:根节点,先序遍历左子树,先序遍历右子树 实现: 递归实现 非递归实现 c void PreOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ visit(p); Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); p=p-\u003erchild; } } } 中序遍历(InOrder) 顺序:中序遍历左子树,根节点,中序遍历右子树 实现: 递归实现 非递归实现 c void InOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); visit(p); p=p-\u003erchild; } } } 后序遍历(PostOrder) 顺序:后序遍历左子树,后序遍历右子树,根节点 实现: 递归实现 非递归实现: c void PostOrder(BiTree T){ InitStack(S); BiTree p = T; BiTree r = NULL: while(p||!IsEmpty(S)){ if(p){ push(S,p); p = p-\u003elchild; } else{ GetTop(S,p); if(p-\u003erchild\u0026\u0026p-\u003erchild!=r){ p=p-\u003erchild; push(S,p); p=p-\u003elchild; } else{ pop(S,p); visit(p-\u003edata); r=p; p=NULL; } } } } 根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而先序和后序则不能确定一颗二叉树 层次遍历 c void LevelOrder(BiTree T){ InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)){ Dequeue(Q,p); visit(p); if(p-\u003elchild!=NULL){ EnQueue(Q,p-\u003elchild); } if(p-\u003erchild!=NULL){ EnQueue(Q,p-\u003erchild); } } } 计算树的深度 c int BitDepth(BiTree T){ if (T==NULL) return 0; else{ ldep = Btdepth(T-\u003elchild); rdep = Btdepth(T-\u003erchild); if(ldep\u003erdep) return ldep+1; else return rdep+1; } } ","date":"2018-11-19","objectID":"/posts/data-structure/:5:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#层次遍历"},{"categories":[],"content":" 二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法； 遍历方法 先序遍历(PreOrder) 顺序:根节点,先序遍历左子树,先序遍历右子树 实现: 递归实现 非递归实现 c void PreOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ visit(p); Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); p=p-\u003erchild; } } } 中序遍历(InOrder) 顺序:中序遍历左子树,根节点,中序遍历右子树 实现: 递归实现 非递归实现 c void InOrder2(BiTree t){ InitStack(S); BiTree p = t; while(p||!IsEmpty(S)){ if(p){ Push(S,p); p = p-\u003elchild; } else{ Pop(S,p); visit(p); p=p-\u003erchild; } } } 后序遍历(PostOrder) 顺序:后序遍历左子树,后序遍历右子树,根节点 实现: 递归实现 非递归实现: c void PostOrder(BiTree T){ InitStack(S); BiTree p = T; BiTree r = NULL: while(p||!IsEmpty(S)){ if(p){ push(S,p); p = p-\u003elchild; } else{ GetTop(S,p); if(p-\u003erchild\u0026\u0026p-\u003erchild!=r){ p=p-\u003erchild; push(S,p); p=p-\u003elchild; } else{ pop(S,p); visit(p-\u003edata); r=p; p=NULL; } } } } 根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而先序和后序则不能确定一颗二叉树 层次遍历 c void LevelOrder(BiTree T){ InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q)){ Dequeue(Q,p); visit(p); if(p-\u003elchild!=NULL){ EnQueue(Q,p-\u003elchild); } if(p-\u003erchild!=NULL){ EnQueue(Q,p-\u003erchild); } } } 计算树的深度 c int BitDepth(BiTree T){ if (T==NULL) return 0; else{ ldep = Btdepth(T-\u003elchild); rdep = Btdepth(T-\u003erchild); if(ldep\u003erdep) return ldep+1; else return rdep+1; } } ","date":"2018-11-19","objectID":"/posts/data-structure/:5:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#计算树的深度"},{"categories":[],"content":" 线索化二叉树的结构和基本操作；格式: ltag lchild data rchild rtag 1:指向节点的前驱 1:指向节点的后继 中序线索二叉树示例 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#线索化二叉树的结构和基本操作"},{"categories":[],"content":" 森林的定义和存储结构，森林的遍历等方法的实现； 森林存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 森林=\u003e二叉树用孩子兄弟表示法将树=\u003e二叉树(由于根节点没有兄弟所以没有右子树)=\u003e将森林的多颗树连在一起 例: 森林遍历方法树和森林遍历与二叉树遍历的对应关系 树 森林 二叉树(将森林或树转换成的二叉树) 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#森林的定义和存储结构森林的遍历等方法的实现"},{"categories":[],"content":" 森林的定义和存储结构，森林的遍历等方法的实现； 森林存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 森林=\u003e二叉树用孩子兄弟表示法将树=\u003e二叉树(由于根节点没有兄弟所以没有右子树)=\u003e将森林的多颗树连在一起 例: 森林遍历方法树和森林遍历与二叉树遍历的对应关系 树 森林 二叉树(将森林或树转换成的二叉树) 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#森林存储结构"},{"categories":[],"content":" 森林的定义和存储结构，森林的遍历等方法的实现； 森林存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 森林=\u003e二叉树用孩子兄弟表示法将树=\u003e二叉树(由于根节点没有兄弟所以没有右子树)=\u003e将森林的多颗树连在一起 例: 森林遍历方法树和森林遍历与二叉树遍历的对应关系 树 森林 二叉树(将森林或树转换成的二叉树) 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#森林二叉树"},{"categories":[],"content":" 森林的定义和存储结构，森林的遍历等方法的实现； 森林存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 森林=\u003e二叉树用孩子兄弟表示法将树=\u003e二叉树(由于根节点没有兄弟所以没有右子树)=\u003e将森林的多颗树连在一起 例: 森林遍历方法树和森林遍历与二叉树遍历的对应关系 树 森林 二叉树(将森林或树转换成的二叉树) 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#森林遍历方法"},{"categories":[],"content":" 基于霍夫曼树生成霍夫曼编码的方法； 13+9=22 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:5","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#基于霍夫曼树生成霍夫曼编码的方法"},{"categories":[],"content":" AVL树的定义和特点以及AVL树调整操作的实现原理； AVL树的定义节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。 调整操作 LR型 LL型 RR型 RL型 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:6","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#avl树的定义和特点以及avl树调整操作的实现原理"},{"categories":[],"content":" AVL树的定义和特点以及AVL树调整操作的实现原理； AVL树的定义节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。 调整操作 LR型 LL型 RR型 RL型 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:6","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#avl树的定义"},{"categories":[],"content":" AVL树的定义和特点以及AVL树调整操作的实现原理； AVL树的定义节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。 调整操作 LR型 LL型 RR型 RL型 ","date":"2018-11-19","objectID":"/posts/data-structure/:5:6","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#调整操作"},{"categories":[],"content":" 最优二叉树的构造原理和相关算法。 c treenode *huffmanTree(int n) { //n为叶子个数 int index = 0; for (int i = 0; i \u003c n; ++i) { //将每一个叶子节点建成一棵树，放入数组tree[]中 treenode *p = new treenode; p-\u003edata = arr[i]; //arr[]中放着叶子节点的权值 p-\u003elch = NULL; p-\u003erch = NULL; tree[index++] = p; } treenode *root = NULL; //定义最优二叉树的根 for (int i = 0; i \u003c n - 1; ++i) { //每次取arr[]中未使用的最小两个值 sort(arr + i, arr + n); treenode *ch1 = NULL, *ch2 = NULL; for (int j = 0; j \u003c index; ++j) {//在数组tree[]中找到这两个值，建立新的节点 if(tree[j]-\u003edata == arr[i]) ch1 = tree[j]; if(tree[j]-\u003edata == arr[i + 1]) ch2 = tree[j]; if(ch1 \u0026\u0026 ch2) break; } treenode *p = new treenode;//建立新的节点，存入数组tree[]中 p-\u003edata = ch1-\u003edata + ch2-\u003edata; p-\u003elch = ch1; p-\u003erch = ch2; root = p;//更新根，直到建立完成 tree[index++] = p; arr[i + 1] = p-\u003edata;//并将这个节点的权值传入数组arr[]中 } return root; } ","date":"2018-11-19","objectID":"/posts/data-structure/:5:7","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#最优二叉树的构造原理和相关算法"},{"categories":[],"content":" （六）图","date":"2018-11-19","objectID":"/posts/data-structure/:6:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#六图"},{"categories":[],"content":" 图的各种基本概念和各种存储方式； 图的基本概念 有向图 表示法: V(G3)={0,1,2} E(G3)={\u003c0,1\u003e,\u003c1,0\u003e,\u003c1,2\u003e} 强连通: 节点v到w和w到v都有路径 强连通分量: 极大强连通子图 入度,出度: 入度和=出度和=边数 无向图 表示法 V(G1)={0,1,2,3} E(G1)={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)} 连通: 从v到w的路径存在,则v和w是连通的. 连通图: 图G的任意两个顶点都是连通的. 连通分量: 极大连通子图; 连通图只有一个连通分量; 非连通图有多个连通分量 极大连通子图: 要求连通子图包含其所有的边 极小连通子图: 保持连通又使得边数最少(生成树) 完全图 任意两个顶点都存在边. n个顶点的有向图=\u003en(n-1)条边 n个顶点的无向图=\u003en(n-1)/2条边 稀疏图|E|\u003c|V|*log|V|和稠密图 各种存储方式 邻接矩阵法 邻接表法 定义: c ＃define MaxVerNum 100 /*最大顶点数为100*/ // 邻接表类型 ： typedef struct ArcNode { int adjvex; /*邻接点域*/ InfoType *Info; /*表示边上信息的域info*/ struct ArcNode * next; /*指向下一个邻接点的指针域*/ } ArcNode ; // 表头结点类型 ： typedef struct Vnode { VertexType vertex; /*顶点域*/ ArcNode * firstedge; /*边表头指针*/ } Vnode, AdjList [MaxVertexNum]; // 图的类型 ： typedef struct { AdjList vertices; /*邻接表*/ int vexnum, arcnum; /*顶点数和边数*/ } ALGraph; /*ALGraph是以邻接表方式存储的图类型*/ ","date":"2018-11-19","objectID":"/posts/data-structure/:6:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#图的各种基本概念和各种存储方式"},{"categories":[],"content":" 图的各种基本概念和各种存储方式； 图的基本概念 有向图 表示法: V(G3)={0,1,2} E(G3)={\u003c0,1\u003e,\u003c1,0\u003e,\u003c1,2\u003e} 强连通: 节点v到w和w到v都有路径 强连通分量: 极大强连通子图 入度,出度: 入度和=出度和=边数 无向图 表示法 V(G1)={0,1,2,3} E(G1)={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)} 连通: 从v到w的路径存在,则v和w是连通的. 连通图: 图G的任意两个顶点都是连通的. 连通分量: 极大连通子图; 连通图只有一个连通分量; 非连通图有多个连通分量 极大连通子图: 要求连通子图包含其所有的边 极小连通子图: 保持连通又使得边数最少(生成树) 完全图 任意两个顶点都存在边. n个顶点的有向图=\u003en(n-1)条边 n个顶点的无向图=\u003en(n-1)/2条边 稀疏图|E|\u003c|V|*log|V|和稠密图 各种存储方式 邻接矩阵法 邻接表法 定义: c ＃define MaxVerNum 100 /*最大顶点数为100*/ // 邻接表类型 ： typedef struct ArcNode { int adjvex; /*邻接点域*/ InfoType *Info; /*表示边上信息的域info*/ struct ArcNode * next; /*指向下一个邻接点的指针域*/ } ArcNode ; // 表头结点类型 ： typedef struct Vnode { VertexType vertex; /*顶点域*/ ArcNode * firstedge; /*边表头指针*/ } Vnode, AdjList [MaxVertexNum]; // 图的类型 ： typedef struct { AdjList vertices; /*邻接表*/ int vexnum, arcnum; /*顶点数和边数*/ } ALGraph; /*ALGraph是以邻接表方式存储的图类型*/ ","date":"2018-11-19","objectID":"/posts/data-structure/:6:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#图的基本概念"},{"categories":[],"content":" 图的各种基本概念和各种存储方式； 图的基本概念 有向图 表示法: V(G3)={0,1,2} E(G3)={\u003c0,1\u003e,\u003c1,0\u003e,\u003c1,2\u003e} 强连通: 节点v到w和w到v都有路径 强连通分量: 极大强连通子图 入度,出度: 入度和=出度和=边数 无向图 表示法 V(G1)={0,1,2,3} E(G1)={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)} 连通: 从v到w的路径存在,则v和w是连通的. 连通图: 图G的任意两个顶点都是连通的. 连通分量: 极大连通子图; 连通图只有一个连通分量; 非连通图有多个连通分量 极大连通子图: 要求连通子图包含其所有的边 极小连通子图: 保持连通又使得边数最少(生成树) 完全图 任意两个顶点都存在边. n个顶点的有向图=\u003en(n-1)条边 n个顶点的无向图=\u003en(n-1)/2条边 稀疏图|E|\u003c|V|*log|V|和稠密图 各种存储方式 邻接矩阵法 邻接表法 定义: c ＃define MaxVerNum 100 /*最大顶点数为100*/ // 邻接表类型 ： typedef struct ArcNode { int adjvex; /*邻接点域*/ InfoType *Info; /*表示边上信息的域info*/ struct ArcNode * next; /*指向下一个邻接点的指针域*/ } ArcNode ; // 表头结点类型 ： typedef struct Vnode { VertexType vertex; /*顶点域*/ ArcNode * firstedge; /*边表头指针*/ } Vnode, AdjList [MaxVertexNum]; // 图的类型 ： typedef struct { AdjList vertices; /*邻接表*/ int vexnum, arcnum; /*顶点数和边数*/ } ALGraph; /*ALGraph是以邻接表方式存储的图类型*/ ","date":"2018-11-19","objectID":"/posts/data-structure/:6:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#各种存储方式"},{"categories":[],"content":" 图的两种搜索方法和图连的连通性； 图的两种搜索方法 两个基本函数 c int FirstAdjVex(ALGraph G, int v) { // 返回G中第v个顶点的第1个邻接点的序号。如果v无邻接点，返回0。 if(!G.vertices[v].firstarc) return(0); else return(G.vertices[v].firstarc-\u003eadjvex); } int NextAdjVex(ALGraph G, int v, int w) { // 返回G中第v个顶点的相对于顶点w的下一个邻接点的序号。 // 如果v无相对于顶点w的下一个邻接点，返回0。 ArcNode *p; p=G.vetrices[v].firstarc; while( p \u0026\u0026 p-\u003eadjvex!=w) p=p-\u003enextarc; if(p-\u003eadjvex==w \u0026\u0026 p-\u003enextarc) return(p-\u003enextarc-\u003eadjvex); else return(0); } DFS(深度优先) c void DFSTraverse( Graph G ) { bool visited[MAX] ; //用于标识结点是否已被访问过 for ( k=1; k\u003c=G.vexnum; ++k ) visited[k] = FALSE; for ( k=1; k\u003c=G.vexnum; ++k ) if ( !visited[ k ] ) DFS(G, k); } void DFS( Graph G, int v ) { visited[v] = TRUE; VISIT( v ); // 访问图G中第v个顶点 for (w=FirstAdjVex(G, v); w\u003e0; w=NextAdjVex(G, v, w)) if ( !visited[ w ] ) DFS(G, w); } BFS(广度优先) c void BFSTraverse( Graph G ) { bool visited[MAX] ; //用于标识结点是否已被访问过 for (v=1; v\u003c=G.vexnum; ++v) visited[v] = FALSE; InitQueue(Q); for(v=1; v\u003c=G.vexnum; ++v) if ( !visited[v] ) { visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) { DeQueue(Q,u); for(w=FirstAdjVex(G, u); w\u003e0; w=NextAdjVex(G, u, w)) if( !visited[w] ) { visited[w]=TRUE; VISIT(w); EnQueue(Q, w); } } // end while } // end if } ","date":"2018-11-19","objectID":"/posts/data-structure/:6:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#图的两种搜索方法和图连的连通性"},{"categories":[],"content":" 图的两种搜索方法和图连的连通性； 图的两种搜索方法 两个基本函数 c int FirstAdjVex(ALGraph G, int v) { // 返回G中第v个顶点的第1个邻接点的序号。如果v无邻接点，返回0。 if(!G.vertices[v].firstarc) return(0); else return(G.vertices[v].firstarc-\u003eadjvex); } int NextAdjVex(ALGraph G, int v, int w) { // 返回G中第v个顶点的相对于顶点w的下一个邻接点的序号。 // 如果v无相对于顶点w的下一个邻接点，返回0。 ArcNode *p; p=G.vetrices[v].firstarc; while( p \u0026\u0026 p-\u003eadjvex!=w) p=p-\u003enextarc; if(p-\u003eadjvex==w \u0026\u0026 p-\u003enextarc) return(p-\u003enextarc-\u003eadjvex); else return(0); } DFS(深度优先) c void DFSTraverse( Graph G ) { bool visited[MAX] ; //用于标识结点是否已被访问过 for ( k=1; k\u003c=G.vexnum; ++k ) visited[k] = FALSE; for ( k=1; k\u003c=G.vexnum; ++k ) if ( !visited[ k ] ) DFS(G, k); } void DFS( Graph G, int v ) { visited[v] = TRUE; VISIT( v ); // 访问图G中第v个顶点 for (w=FirstAdjVex(G, v); w\u003e0; w=NextAdjVex(G, v, w)) if ( !visited[ w ] ) DFS(G, w); } BFS(广度优先) c void BFSTraverse( Graph G ) { bool visited[MAX] ; //用于标识结点是否已被访问过 for (v=1; v\u003c=G.vexnum; ++v) visited[v] = FALSE; InitQueue(Q); for(v=1; v\u003c=G.vexnum; ++v) if ( !visited[v] ) { visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) { DeQueue(Q,u); for(w=FirstAdjVex(G, u); w\u003e0; w=NextAdjVex(G, u, w)) if( !visited[w] ) { visited[w]=TRUE; VISIT(w); EnQueue(Q, w); } } // end while } // end if } ","date":"2018-11-19","objectID":"/posts/data-structure/:6:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#图的两种搜索方法"},{"categories":[],"content":" 两种最小生成树的生成方法； Prim 算法 Kruskal 算法 ","date":"2018-11-19","objectID":"/posts/data-structure/:6:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#两种最小生成树的生成方法"},{"categories":[],"content":" 各种求最短路径的方法； Dijkstra 算法 Floyed 算法 ","date":"2018-11-19","objectID":"/posts/data-structure/:6:4","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#各种求最短路径的方法"},{"categories":[],"content":" 用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法。 AOV-Network (Activity on Vertex) 顶点表示活动,边\u003cv1,v2\u003e表示活动v1先于活动v2,必须是有向无环图.(依赖关系) 拓扑排序: 1. 从图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和以它为起点的有向边 3. 重复步骤1,2 AOE-Network (Activity on Edge) 顶点表示事件,有向边表示活动,边上的权重表示完成该活动的开销.(软件项目安排) 关键路径: 从起点到终点的所有路径中,具有最大的路径长度的路径 1. 求AOE中所有事件的最早发生时间ve():从前往后计算 2. 求AOE中所有事件的最晚发生时间vl():从后往前计算 3. 求AOE中所有活动的最早开始时间e():边的起点的顶点的最早发生时间 4. 求AOE中所有活动的最晚开始时间l():边的终点的顶点的最晚发生时间-边的权重 5. 求AOE中所有活动的差额d(),找出d()=0构成关键路径 ","date":"2018-11-19","objectID":"/posts/data-structure/:6:5","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法"},{"categories":[],"content":" （七）排序","date":"2018-11-19","objectID":"/posts/data-structure/:7:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#七排序"},{"categories":[],"content":" 插入排序法(含折半插入排序法)、选择排序法、冒泡排序法、快速排序法、堆积排序法、归并排序、基数排序等排序方法排序的原理、规律和特点； 插入排序 c // 直接插入排序 void InsertSort(int a[], int length){ /* * 插入排序 * 从头开始保证走过的路有序,每加入一个元素就将其插入到正确的位置 */ int j,i; for(i=2;i\u003clength;i++){ if (a[i]\u003ca[i-1]){ a[0] = a[i]; for(j=i-1;a[0]\u003ca[j]; j--) a[j+1] = a[j]; a[j+1] = a[0]; } } } // 折半插入排序 void InsertSort(ElemType A[], int n){ int i,j,low,high,mid; for(i=2;i\u003c=n;i++){ A[0]=A[i]; low=1; high=i-1; while(low\u003c=high){ mid=(low+high)/2 if(A[mid].key\u003eA[0].key) high = mid-1; // 查找左半子树 else low=mid+1 // 查找右半子树 } for(j=i-1;j\u003e=high+1;--j) A[j+1]=A[j]; A[high+1]=A[0]; } } // 希尔排序 void ShellSort(SqList \u0026L,int dlta[],int t) { // 按增量序列dlta[0..t-1]对顺序表L作希尔排序。算法.5 int k; for(k=0;k\u003ct;++k){ ShellInsert(L,dlta[k]); // 一趟增量为dlta[k]的插入排序 printf(\"第%d趟排序结果: \",k+1); print(L); } } void ShellInsert(SqList \u0026L,int dk){ // 对顺序表L作一趟希尔插入排//序。本算法是和一趟直接插入排序相比， // 作了以下修改： // 1.前后记录位置的增量是dk，而不是1; // 2.r[0]只是暂存单元，不是哨兵。当j\u003c=0时，插入位置已找到。 int i,j; for(i=dk+1;i\u003c=L.length;++i){ if LT(L.r[i].key,L.r[i-dk].key){ // 需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; // 暂存在L.r[0] for(j=i-dk;j\u003e0\u0026\u0026LT(L.r[0].key,L.r[j].key);j-=dk) L.r[j+dk]=L.r[j]; // 记录后移，查找插入位置 L.r[j+dk]=L.r[0]; // 插入 } } } 选择排序 c void SelectSort(ElemType A[], int n){ for (i=0;i\u003cn-1;i++){ int min = i; for(j=i+1; j\u003cn; j++){ if(A[j]\u003cA[min]) min = j; } if (min!=i) swap(A[i], A[min]); } } 冒泡排序 c void bubble_sort(int a[],int n) { // 将a中整数序列重新排列成自小至大有序的整数序列(起泡排序) int i,j,t; Status change = TRUE; for(i=n-1;i\u003e1\u0026\u0026change;--i){ change=FALSE; for(j=0;j\u003ci;++j) if(a[j]\u003ea[j+1]){ t=a[j]; a[j]=a[j+1]; a[j+1]=t; change=TRUE; } } } 快速排序 c void QuickSort(int a[], int low, int high){ if (low\u003chigh){ int mid = partition(a, low,high); QuickSort(a, low, mid-1); QuickSort(a, mid+1, high); } } int partition(int a[],int low,int high){ int pivot = a[low]; while(low\u003chigh){ while(a[high]\u003e=pivot \u0026\u0026 low\u003chigh) high--; a[low] = a[high]; while(a[low]\u003c=pivot \u0026\u0026 low\u003chigh) low++; a[high] = a[low]; } a[low] = pivot; return low; } 堆排序 算法步骤: 构造初始堆 假设给定无序序列结构如下 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。 找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6 调整堆 将堆顶元素9和末尾元素4进行交换 重新调整结构，使其继续满足堆定义 再将堆顶元素8与末尾元素5进行交换，得到第二大元素8. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 https://www.cnblogs.com/chengxiao/p/6129630.html c void AdjustDown(int a[], int k, int len){ a[0] = a[k]; for (int i=k*2; i\u003c=len; i*=2){ if(i\u003clen\u0026\u0026a[i]\u003ca[i+1]) i++; if(a[0]\u003e=a[i]) break; else{ a[k] = a[i]; k=i; } } a[k] = a[0]; } void HeapSort(int a[], int length){ // build max heap for (int i=length/2; i\u003e0; i--) AdjustDown(a, i, length); for (int i=length;i\u003e1; i--){ int t=a[1]; a[1] = a[i]; a[i] = t; AdjustDown(a,1, i-1); } } 归并排序 c void merge(int a[], int low, int mid, int high, int b[]){ for(int i=low; i\u003c=high; i++) b[i] = a[i]; int l,h,k; for (k=low,l=low,h=mid+1; l\u003c=mid\u0026\u0026h\u003c=high;k++){ if(b[l]\u003c=b[h]) a[k] = b[l++]; else a[k] = b[h++]; } while(l\u003c=mid) a[k++]=b[l++]; while(h\u003c=high) a[k++]=b[h++]; } void MergeSort(int a[], int low, int high, int b[]){ if (low\u003chigh){ int mid = (low+high)/2; MergeSort(a, low, mid,b); MergeSort(a,mid+1, high, b); merge(a, low, mid , high, b); } } void MergeSort(int a[], int len){ int *b = new int[len]; MergeSort(a, 1, len, b); delete []b; } 基数排序 将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 时间复杂度:O(d(n+r)) 其中d:d趟分配与收集;一趟分配:O(n);一趟收集:O(r) ","date":"2018-11-19","objectID":"/posts/data-structure/:7:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#插入排序法含折半插入排序法选择排序法冒泡排序法快速排序法堆积排序法归并排序基数排序等排序方法排序的原理规律和特点"},{"categories":[],"content":" 各种排序算法的时空复杂度的简单分析。 排序名称 类别 稳定性 时间复杂度 空间复杂度 最少比较次数 最多比较次数 最少移动次数 最多移动次数 插入排序 插入排序 稳定 O(n2) O(1) n-1 (n+2)(n-1)/2 0 (n+4)(n-1)/2 希尔排序 插入排序 不稳定 O(n1.5) o(1) / / / / 冒泡排序 交换排序 稳定 O(n2) o(1) n-1 n(n-1)/2 0 n(n-1)/2 快速排序 交换排序 不稳定 O(n*log2n) o(log2n) O(n*log2n) n(n-1)/2 O(n*log2n) / 选择排序 选择排序 不稳定 O(n2) O(1) n-1 n(n-1)/2 0 3(n-1) 堆排序 选择排序 不稳定 O(n*log2n) O(1) O(n*log2n) O(n*log2n) / / 归并排序 归并排序 稳定 O(n*log2n) O(n) O(n*log2n) O(n*log2n) / / 基数排序 基数排序 稳定 O(d(n+rd)) O(rd) 0 0 0 0 排序名称 平均情况 最好情况 最坏情况 直接插入排序 O(n2) O(n) o(n2) 希尔排序 O(n1.5) 冒泡排序 O(n2) O(n) O(n2) 快速排序 O(n*log2n) O(n*log2n) O(n2) 简单选择排序 O(n2) O(n2) O(n2) 堆排序 O(n*log2n) O(n*log2n) O(n*log2n) 归并排序 O(n*log2n) O(n*log2n) O(n*log2n) 基数排序 O(d(n+rd)) O(d(n+rd)) O(d(n+rd)) ","date":"2018-11-19","objectID":"/posts/data-structure/:7:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#各种排序算法的时空复杂度的简单分析"},{"categories":[],"content":" （八）索引结构与散列","date":"2018-11-19","objectID":"/posts/data-structure/:8:0","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#八索引结构与散列"},{"categories":[],"content":" 线性索引结构、倒排表、静态搜索树的结构和特点； 线性索引结构 稠密索引 分块索引 倒排索引 正排索引 静态搜索树 查找表中各关键字被查找的概率是不同的 含有 9 个关键字的查找表及其相应权值如下表所示： 求出查找表中所有的 △P 的值，找出整棵查找表的根结点： 例如，关键字 F 的 △P 的计算方式为：从 G 到 I 的权值和 - 从 A 到 E 的权值和 = 4+3+5-1-1-2-5-3 = 0。 通过上图左侧表格得知，根结点为 F，以 F 为分界线，左侧子表为 F 结点的左子树，右侧子表为 F 结点的右子树（如上图右侧所示），继续查找左右子树的根结点: 通过重新分别计算左右两查找子表的 △P 的值，得知左子树的根结点为 D，右子树的根结点为 H （如上图右侧所示），以两结点为分界线，继续判断两根结点的左右子树: 注意：在建立次优查找树的过程中，由于只根据的各关键字的 P 的值进行构建，没有考虑单个关键字的相应权值的大小，有时会出现根结点的权值比孩子结点的权值还小，此时就需要适当调整两者的位置。 http://www.cnblogs.com/ciyeer/p/9067098.html ","date":"2018-11-19","objectID":"/posts/data-structure/:8:1","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#线性索引结构倒排表静态搜索树的结构和特点"},{"categories":[],"content":" B树的结构m阶: 1\u003c子节点数量\u003c=M ,M\u003e=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）； 插入 (m=5, 每个节点含有[2,4]个value) 插入6 删除 case 1 删除6 case 2 删除3 ","date":"2018-11-19","objectID":"/posts/data-structure/:8:2","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#b树的结构"},{"categories":[],"content":" 散列的实现原理和各种操作的实现算法。 Hash 函数 直接地址法 H(key)=a*key+b 适合于关键字分布基本连续 除留余数法 H(key)=key%p 假定散列表长为m,取一个不大于m但接近或等于m的质数P 数字分析法 适用于已知关键字数字集合 平方取中法 取关键字的平方值的中间几位作为散列地址 折叠法 将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址 冲突处理 开放地址法 递推式: Hi=(H(key) + di) % m di是增量 删除时不能随便物理删除表中已有的元素,若删除将会截断其他具有相同的散列地址的元素的查找地址,所以要进行逻辑删除,打一个标记,定期维护,将删除标记的元素物理删除. 线性探索法 往下一个一个找 平方探索法 当di = 1^2,-1^2,2^2,-2^2,…,k^2,-k^2,其中$k \\leq m/2$, m必须为可以表示成4k+3的质数 可以避免出现堆积的问题,但是不能探测到所有单元 再散列法 di=Hash2(key) 伪随机法 di=伪随机序列 拉链法 往后拉链表 装填因子 a = 表中记录数n/散列表长度m ","date":"2018-11-19","objectID":"/posts/data-structure/:8:3","series":null,"tags":["基础知识","考研","算法与数据结构"],"title":"考研807数据结构复习笔记 - 旧笔记","uri":"/posts/data-structure/#散列的实现原理和各种操作的实现算法"},{"categories":[],"content":" 函数","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#函数"},{"categories":[],"content":" 默认参数 默认参数必须指向不变对象！(如若可变多次调用会产生不确定的结果) 在调用函数时普通参数和默认参数都可以用: python3 fun(参数名=参数值,参数名=参数值....) // 顺序可以调换. ","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:1","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#默认参数"},{"categories":[],"content":" 可变参数 python3 def fun(*args): // 定义,args is tuple pass fun(1,2,3) // 直接传参调用 fun(*l) // l is list or tuple ","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:2","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#可变参数"},{"categories":[],"content":" 关键字参数 python3 def fun(**kw): // 定义,kw is dict pass fun(key_name1=value1,ke_name2=value2) fun(**dic) // dic is dict,传入的参数只是dic的拷贝 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:3","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#关键字参数"},{"categories":[],"content":" 命名关键词参数 python3 def fun(arg1,*,city,job): pass fun('arg1',city='beijing',job='无') // 必须传入参数名,顺序可以调换 def fun2(arg1,*args,city,job) // 此时不需要*了,原因可想而知. ","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:4","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#命名关键词参数"},{"categories":[],"content":" 参数定义顺序必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:1:5","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#参数定义顺序"},{"categories":[],"content":" 尾递归在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。(Python不优化…) ","date":"2017-08-08","objectID":"/posts/python_study_notes/:2:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#尾递归"},{"categories":[],"content":" 循环 判断一个对象是否可迭代 python3 from collections import Iterable isinstance('abc', Iterable) # str是否可迭代 迭代索引+value python3 for i, value in enumerate(['A', 'B', 'C']): print(i, value) 列表生成器 python3 l1 = list(range(1, 11)) l2 = [x * x for x in range(1, 11)] l3 = [x * x for x in range(1, 11) if x % 2 == 0] l4 = [m + n for m in 'ABC' for n in 'XYZ'] generator 通过算法生成下一个迭代值,省内存. python3 g = (x * x for x in range(10)) # 生成generator next(g) # 通过next函数获取g的下一个元素,当没有元素时会抛出异常 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.每次调用next()函数执行,遇到yield返回,再次执行从上一次yield之后执行. Iterator:可以调用next()的对象成为Iterator对象. python3 i = iter([1, 2, 3, 4, 5]) # 取得Iterator对象. ","date":"2017-08-08","objectID":"/posts/python_study_notes/:3:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#循环"},{"categories":[],"content":" 函数式编程 map python3 r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # r is Iterator l = list(r) # 转换为list reduce 效果: python3 reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 应用: python3 from functools import reduce def fn(x, y): return x * 10 + y reduce(fn, [1, 3, 5, 7, 9]) # 生成13579 filter sorted python3 sorted([36, 5, -12, 9, -21], key=abs) # abs函数作用于每个元素 闭包:返回函数不要引用任何循环变量，或者后续会发生变化的变量。 python3 def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() #9,9,9 def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs lambda 参数名,参数名 : 表达式返回值 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:4:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#函数式编程"},{"categories":[],"content":" decorator python3 # 两层调用 def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper @log #相当于now = log(now) def now(): print('2015-3-25') # 三层调用 def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log('execute') #相当于now = log('execute')(now) def now(): print('2015-3-25') ","date":"2017-08-08","objectID":"/posts/python_study_notes/:5:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#decorator"},{"categories":[],"content":" 偏函数 python3 import functools int2 = functools.partial(int, base=2) # 返回的函数base=2 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:6:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#偏函数"},{"categories":[],"content":" 模块1. 一个py文件就是一个模块. 2. 一个目录里面包含__init__.py,这个目录就是一个包(package). 3. 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； ","date":"2017-08-08","objectID":"/posts/python_study_notes/:7:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#模块"},{"categories":[],"content":" class 实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问. 实的变量名如果以_开头,外部可以访问,但是视为private. 鸭子类型 type() python3 \u003e\u003e\u003e import types \u003e\u003e\u003e def fn(): ... pass ... \u003e\u003e\u003e type(fn)==types.FunctionType True \u003e\u003e\u003e type(abs)==types.BuiltinFunctionType True \u003e\u003e\u003e type(lambda x: x)==types.LambdaType True \u003e\u003e\u003e type((x for x in range(10)))==types.GeneratorType True isinstance() python3 \u003e\u003e\u003e isinstance([1, 2, 3], (list, tuple)) True \u003e\u003e\u003e isinstance((1, 2, 3), (list, tuple)) True 测试对象属性和方法 python3 dir('ABC') #获取对象的属性和方法 \u003e\u003e\u003e hasattr(obj, 'x') # 有属性'x'吗？ True \u003e\u003e\u003e obj.x 9 \u003e\u003e\u003e hasattr(obj, 'y') # 有属性'y'吗？ False \u003e\u003e\u003e setattr(obj, 'y', 19) # 设置一个属性'y' \u003e\u003e\u003e hasattr(obj, 'y') # 有属性'y'吗？ True \u003e\u003e\u003e getattr(obj, 'y') # 获取属性'y' 19 \u003e\u003e\u003e obj.y # 获取属性'y' 19 \u003e\u003e\u003e getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404 404 __slots__:限制属性 python3 class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 @property:把一个方法变成属性的调用 python3 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value __XXX__ __len__():调用len()时调用 __str__():类似toString __repr__():为调试服务的toString __iter__():该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值 python3 class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a \u003e 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 __getitem__(n): python3 # 实现切片 class Fib(object): def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x \u003e= start: L.append(a) a, b = b, a + b return L 此外，如果把对象看成dict，getitem()的参数也可能是一个可以作key的object，例如str。与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。 __getattr__(self, attr):当获取属性时没有找到,就调用它. __call__():可以实现实例本身调用. python3 # 判断对象是否可以实例调用 \u003e\u003e\u003e callable(Student()) True \u003e\u003e\u003e callable(max) True \u003e\u003e\u003e callable([1, 2, 3]) False \u003e\u003e\u003e callable(None) False \u003e\u003e\u003e callable('str') False ","date":"2017-08-08","objectID":"/posts/python_study_notes/:8:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#class"},{"categories":[],"content":" 枚举类 定义 python3 from enum import Enum Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) 遍历 python3 for name, member in Month.__members__.items(): print(name, '=\u003e', member, ',', member.value) # value属性则是自动赋给成员的int常量，默认从1开始计数。 自定义枚举类 python3 from enum import Enum, unique @unique class Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型 python3 \u003e\u003e\u003e day1 = Weekday.Mon \u003e\u003e\u003e print(day1) Weekday.Mon \u003e\u003e\u003e print(Weekday.Tue) Weekday.Tue \u003e\u003e\u003e print(Weekday['Tue']) Weekday.Tue \u003e\u003e\u003e print(Weekday.Tue.value) 2 \u003e\u003e\u003e print(day1 == Weekday.Mon) True \u003e\u003e\u003e print(day1 == Weekday.Tue) False \u003e\u003e\u003e print(Weekday(1)) Weekday.Mon \u003e\u003e\u003e print(day1 == Weekday(1)) True \u003e\u003e\u003e Weekday(7) Traceback (most recent call last): ... ValueError: 7 is not a valid Weekday \u003e\u003e\u003e for name, member in Weekday.__members__.items(): ... print(name, '=\u003e', member) ... Sun =\u003e Weekday.Sun Mon =\u003e Weekday.Mon Tue =\u003e Weekday.Tue Wed =\u003e Weekday.Wed Thu =\u003e Weekday.Thu Fri =\u003e Weekday.Fri Sat =\u003e Weekday.Sat ","date":"2017-08-08","objectID":"/posts/python_study_notes/:9:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#枚举类"},{"categories":[],"content":" type():动态创建类 python3 \u003e\u003e\u003e def fn(self, name='world'): # 先定义函数 ... print('Hello, %s.' % name) ... \u003e\u003e\u003e Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class \u003e\u003e\u003e h = Hello() \u003e\u003e\u003e h.hello() Hello, world. \u003e\u003e\u003e print(type(Hello)) \u003cclass 'type'\u003e \u003e\u003e\u003e print(type(h)) \u003cclass '__main__.Hello'\u003e 要创建一个class对象，type()函数依次传入3个参数： 1. class的名称； 2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； 3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:10:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#type动态创建类"},{"categories":[],"content":" metaclass metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass. 示例: python3 # metaclass是类的模板，所以必须从`type`类型派生： class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list, metaclass=ListMetaclass): pass __new__()方法接收到的参数依次是： 1. 当前准备创建的类的对象； 2. 类的名字； 3. 类继承的父类集合； 4. 类的方法集合; ","date":"2017-08-08","objectID":"/posts/python_study_notes/:11:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#metaclass"},{"categories":[],"content":" 调试 异常处理: python3 try: print('try...') r = 10 / int('2') print('result:', r) except ValueError as e: print('ValueError:', e) except ZeroDivisionError as e: print('ZeroDivisionError:', e) else: print('no error!') finally: print('finally...') print('END') assert(启动Python解释器时可以用-O参数来关闭assert): python3 def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / n def main(): foo('0') unittest python3 import unittest from mydict import Dict class TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b='test') self.assertEqual(d.a, 1) self.assertEqual(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEqual(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'], 'value') def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty setUp()和tearDown()方法会分别在每调用一个测试方法的前后分别被执行。 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:12:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#调试"},{"categories":[],"content":" IO 简单示例: python3 # 编码和忽略错误 f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') StringIO(在内存中读写str): python3 \u003e\u003e\u003e from io import StringIO \u003e\u003e\u003e f = StringIO('Hello!\\nHi!\\nGoodbye!') \u003e\u003e\u003e while True: ... s = f.readline() ... if s == '': ... break ... print(s.strip()) ... Hello! Hi! Goodbye! BytesIO python3 \u003e\u003e from io import BytesIO \u003e\u003e\u003e f = BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87') \u003e\u003e\u003e f.read() b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 操作文件和目录 目录 python3 # 查看当前目录的绝对路径: \u003e\u003e\u003e os.path.abspath('.') '/Users/michael' # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来: \u003e\u003e\u003e os.path.join('/Users/michael', 'testdir') '/Users/michael/testdir' # 然后创建一个目录: \u003e\u003e\u003e os.mkdir('/Users/michael/testdir') # 删掉一个目录: \u003e\u003e\u003e os.rmdir('/Users/michael/testdir') # 拆分路径 \u003e\u003e\u003e os.path.split('/Users/michael/testdir/file.txt') ('/Users/michael/testdir', 'file.txt') # 文件扩展名 \u003e\u003e\u003e os.path.splitext('/path/to/file.txt') ('/path/to/file', '.txt') 文件 python3 # 对文件重命名: \u003e\u003e\u003e os.rename('test.txt', 'test.py') # 删掉文件: \u003e\u003e\u003e os.remove('test.py') ''' 制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。 幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。 ''' # 列出文件 \u003e\u003e\u003e [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py'] ['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] 序列化 python3 # 序列化 \u003e\u003e\u003e import pickle \u003e\u003e\u003e d = dict(name='Bob', age=20, score=88) \u003e\u003e\u003e pickle.dumps(d) b'\\x80\\x03}q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.' # 保存到文件 \u003e\u003e\u003e f = open('dump.txt', 'wb') \u003e\u003e\u003e pickle.dump(d, f) \u003e\u003e\u003e f.close() # 从文件读取 \u003e\u003e\u003e f = open('dump.txt', 'rb') \u003e\u003e\u003e d = pickle.load(f) \u003e\u003e\u003e f.close() \u003e\u003e\u003e d {'age': 20, 'score': 88, 'name': 'Bob'} # JSON print(json.dumps(s, default=lambda obj: obj.__dict__)) # __dict__用来存储实例变量 ","date":"2017-08-08","objectID":"/posts/python_study_notes/:13:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#io"},{"categories":[],"content":" 多进程 linux python3 import os print('Process (%s) start...' % os.getpid()) # Only works on Unix/Linux/Mac: pid = os.fork() if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())) else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 通用 python3 from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid())) if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 进程池 python3 from multiprocessing import Pool import os, time, random def long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start))) if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All subprocesses done.') 子进程 python3 import subprocess print('$ nslookup www.python.org') r = subprocess.call(['nslookup', 'www.python.org']) print('Exit code:', r) ","date":"2017-08-08","objectID":"/posts/python_study_notes/:14:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#多进程"},{"categories":[],"content":" 多线程 创建线程: python3 import time, threading # 新线程执行的代码: def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n \u003c 5: n = n + 1 print('thread %s \u003e\u003e\u003e %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name) print('thread %s is running...' % threading.current_thread().name) t = threading.Thread(target=loop, name='LoopThread') t.start() t.join() print('thread %s ended.' % threading.current_thread().name) 互斥锁 python3 balance = 0 lock = threading.Lock() def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() Global Interpreter Lock: 任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 ThreadLocal:线程之间传递参数,每个线程都有一副本,互不干扰. python3 import threading # 创建全局ThreadLocal对象: local_school = threading.local() def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name)) def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student() t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A') t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B') t1.start() t2.start() t1.join() t2.join() ","date":"2017-08-08","objectID":"/posts/python_study_notes/:15:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#多线程"},{"categories":[],"content":" 常用模块 collections namedtuple python3 \u003e\u003e\u003e from collections import namedtuple \u003e\u003e\u003e Point = namedtuple('Point', ['x', 'y']) \u003e\u003e\u003e p = Point(1, 2) \u003e\u003e\u003e p.x 1 \u003e\u003e\u003e p.y 2 deque python3 # 双向列表 \u003e\u003e\u003e from collections import deque \u003e\u003e\u003e q = deque(['a', 'b', 'c']) \u003e\u003e\u003e q.append('x') \u003e\u003e\u003e q.appendleft('y') \u003e\u003e\u003e q deque(['y', 'a', 'b', 'c', 'x']) defaultdict python3 \u003e\u003e\u003e from collections import defaultdict \u003e\u003e\u003e dd = defaultdict(lambda: 'N/A') \u003e\u003e\u003e dd['key1'] = 'abc' \u003e\u003e\u003e dd['key1'] # key1存在 'abc' \u003e\u003e\u003e dd['key2'] # key2不存在，返回默认值 'N/A' OrderedDict python3 \u003e\u003e\u003e from collections import OrderedDict \u003e\u003e\u003e d = dict([('a', 1), ('b', 2), ('c', 3)]) \u003e\u003e\u003e d # dict的Key是无序的 {'a': 1, 'c': 3, 'b': 2} \u003e\u003e\u003e od = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) \u003e\u003e\u003e od # OrderedDict的Key是有序的 OrderedDict([('a', 1), ('b', 2), ('c', 3)]) # 根据插入顺序 Counter python3 \u003e\u003e\u003e from collections import Counter \u003e\u003e\u003e c = Counter() \u003e\u003e\u003e for ch in 'programming': ... c[ch] = c[ch] + 1 ... \u003e\u003e\u003e c Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1}) base64:将3个字节的二进制编码成四字节对应的字符 python3 \u003e\u003e\u003e import base64 \u003e\u003e\u003e base64.b64encode(b'binary\\x00string') b'YmluYXJ5AHN0cmluZw==' \u003e\u003e\u003e base64.b64decode(b'YmluYXJ5AHN0cmluZw==') b'binary\\x00string' # url safe \u003e\u003e\u003e base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') b'abcd++//' \u003e\u003e\u003e base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') b'abcd--__' \u003e\u003e\u003e base64.urlsafe_b64decode('abcd--__') b'i\\xb7\\x1d\\xfb\\xef\\xff' struct python3 \u003e\u003e\u003e import struct \u003e\u003e\u003e struct.pack('\u003eI', 10240099) # \u003e表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。 b'\\x00\\x9c@c' \u003e\u003e\u003e struct.unpack('\u003eIH', b'\\xf0\\xf0\\xf0\\xf0\\x80\\x80') # I：4字节无符号整数和H：2字节无符号整数。 (4042322160, 32896) hashlib python3 import hashlib md5 = hashlib.md5() md5.update('how to use md5 in python hashlib?'.encode('utf-8')) print(md5.hexdigest()) # 如果数据量过大,可以分块调用update import hashlib md5 = hashlib.md5() md5.update('how to use md5 in '.encode('utf-8')) md5.update('python hashlib?'.encode('utf-8')) print(md5.hexdigest()) itertools python3 \u003e\u003e\u003e import itertools # 无限迭代 \u003e\u003e\u003e natuals = itertools.count(1) # 重复无限迭代 \u003e\u003e\u003e cs = itertools.cycle('ABC') # 注意字符串也是序列的一种 # 单一元素迭代,可以指定次数 ns = itertools.repeat('A', 3) # 合并迭代 \u003e\u003e\u003e for c in itertools.chain('ABC', 'XYZ'): ... print(c) # groupby()把迭代器中相邻的重复元素挑出来放在一起 \u003e\u003e\u003e for key, group in itertools.groupby('AAABBBCCAAA'): ... print(key, list(group)) ... A ['A', 'A', 'A'] B ['B', 'B', 'B'] C ['C', 'C'] A ['A', 'A', 'A'] contextlib:任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过__enter__和__exit__这两个方法实现的。 python3 from contextlib import contextmanager class Query(object): def __init__(self, name): self.name = name def query(self): print('Query info about %s...' % self.name) @contextmanager def create_query(name): print('Begin') q = Query(name) yield q print('End') # 用contextmanager实现前后自动执行代码 @contextmanager def tag(name): print(\"\u003c%s\u003e\" % name) yield print(\"\u003c/%s\u003e\" % name) with tag(\"h1\"): print(\"hello\") print(\"world\") # 如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。 from contextlib import closing from urllib.request import urlopen with closing(urlopen('https://www.python.org')) as page: for line in page: print(line) urllib python3 from urllib import request with request.urlopen('https://api.douban.com/v2/book/2129650') as f: data = f.read() print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', data.decode('utf-8')) # 加请求头 from urllib import request req = request.Request('http://www.douban.com/') req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25') with request.urlopen(req) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) # post登录 from urllib import request, parse print('Login to weibo.cn...') email = input('Email: ') passwd = input('Password: ') login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec'","date":"2017-08-08","objectID":"/posts/python_study_notes/:16:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#常用模块"},{"categories":[],"content":" 异步IO 协程(Coroutine): python3 def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK' def produce(c): c.send(None) n = 0 while n \u003c 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close() c = consumer() produce(c) 首先调用c.send(None)启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 asyncio python3 import asyncio @asyncio.coroutine def wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host writer.write(header.encode('utf-8')) yield from writer.drain() while True: line = yield from reader.readline() if line == b'\\r\\n': break print('%s header \u003e %s' % (host, line.decode('utf-8').rstrip())) # Ignore the body, close the socket writer.close() loop = asyncio.get_event_loop() tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']] loop.run_until_complete(asyncio.wait(tasks)) loop.close() Python从3.5版开始为asyncio提供了async和await的新语法； aiohttp: python3 import asyncio from aiohttp import web async def index(request): await asyncio.sleep(0.5) return web.Response(body=b'\u003ch1\u003eIndex\u003c/h1\u003e') async def hello(request): await asyncio.sleep(0.5) text = '\u003ch1\u003ehello, %s!\u003c/h1\u003e' % request.match_info['name'] return web.Response(body=text.encode('utf-8')) async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/{name}', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000...') return srv loop = asyncio.get_event_loop() loop.run_until_complete(init(loop)) loop.run_forever() 廖雪峰python教程 https://www.liaoxuefeng.com/ ","date":"2017-08-08","objectID":"/posts/python_study_notes/:17:0","series":null,"tags":["python"],"title":"Python学习笔记 - 旧笔记","uri":"/posts/python_study_notes/#异步io"},{"categories":[],"content":"java字节流总结","date":"2017-03-02","objectID":"/posts/java_byte_stream/","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#字节流常用的继承关系"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#1inputstream和outputstream--抽象类所以以下都是对它的子类"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#2bytearrayinputstream和bytearrayoutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#2fileinputstream和fileoutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#2filterinputstream和filteroutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#2objectinputstream和objectoutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#3bufferedinputstream和bufferedoutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#3datainputstream和dataoutputstream"},{"categories":[],"content":" 字节流(常用)的继承关系 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: java int bytesAvailable = in.avaliable(); if(bytesAvailable \u003e 0){ byte[] data = new byte[bytesAvailable]; in.read(data); } ``` OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: java ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array. ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: java ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长 ByteArrayOutputStream(int size); reset()可将内部buffer的\"指针\"指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): java FileInputStream(File file); FileInputStream(String name); FileOutputStream: 构造方法(常用): java FileOutputStream(File file); FileOutputStream(File file, boolean append); FileOutputStream(String name); FileOutputStream(String name, boolean append); ``` 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: java protected ObjectInputStream(); //提供给子类用的... ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: java protected ObjectOutputStream(); //提供给子类用的... ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个\"包装\". BufferedInputStream: 构造方法: java BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 BufferedOutputStream: 构造方法: java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 ``` 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个\"包装\". DataInputStream: 构造方法: java DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版). DataOutputStream: 构造方法: java DataOutputStream(OutputStream out); 可以写出基本类型,chars和String(UTF-8修订版). 3.PrintStream PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 ) 不会抛出IO异常,用 checkError()检查是否发生错误. 构造方法: java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:1","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#3printstream"},{"categories":[],"content":" 在实际应用时可能会经常用到嵌套的方式创建一个流对象,举个例子 java DataInputStream dis=new DataInputStream( new BufferedInputStream( new FileInputStream(\"1.dat\")));//这样就可以用DataInputStream的很多方法,而且还有缓冲区. 《java核心技术》卷二. Java Platform Standard Edition 8 Documentation. ","date":"2017-03-02","objectID":"/posts/java_byte_stream/:0:2","series":null,"tags":["java"],"title":"java的字节流 - 旧笔记","uri":"/posts/java_byte_stream/#在实际应用时可能会经常用到嵌套的方式创建一个流对象举个例子"},{"categories":null,"content":" 你没有连接至互联网, 只有缓存的页面可用. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]