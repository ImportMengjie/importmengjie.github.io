<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>操作系统 | Mengjie's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">操作系统</h1><a id="logo" href="/.">Mengjie's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">操作系统</h1><div class="post-meta">Jan 3, 2019</div><div class="post-content"><h2 id="（一）基本概念"><a href="#（一）基本概念" class="headerlink" title="（一）基本概念"></a>（一）基本概念</h2><h3 id="计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE；"><a href="#计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE；" class="headerlink" title="计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE；"></a>计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE；</h3><h4 id="计算机的基本构成"><a href="#计算机的基本构成" class="headerlink" title="计算机的基本构成"></a>计算机的基本构成</h4><p>存储器、控制器、运算器、输入设备、输出设备</p>
<h4 id="处理器的内部结构"><a href="#处理器的内部结构" class="headerlink" title="处理器的内部结构"></a>处理器的内部结构</h4><p>CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。</p>
<h3 id="操作系统的概念、演变历程、特性、分类、运行环境、功能；"><a href="#操作系统的概念、演变历程、特性、分类、运行环境、功能；" class="headerlink" title="操作系统的概念、演变历程、特性、分类、运行环境、功能；"></a>操作系统的概念、演变历程、特性、分类、运行环境、功能；</h3><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><p>操作系统是一种系统软件</p>
<h4 id="演变历程"><a href="#演变历程" class="headerlink" title="演变历程"></a>演变历程</h4><ol>
<li><p>手工操作阶段</p>
<p> 无操作系统</p>
</li>
<li><p>批处理阶段</p>
<ol>
<li><p>单道批处理系统</p>
<p> 内存中始终保持一道作业</p>
</li>
<li><p>多道批处理系统</p>
<p> 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序</p>
</li>
</ol>
</li>
<li><p>分时操作系统</p>
<p> 时间片</p>
</li>
<li><p>实时操作系统</p>
<p> 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性.</p>
<ol>
<li><p>硬实时系统</p>
<p> 必须绝对地再规定的时刻发生, 如导弹发射系统</p>
</li>
<li><p>软实时系统</p>
<p> 允许偶尔违反时间规定, 如飞机订票系统.</p>
</li>
</ol>
</li>
</ol>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li><p>并发</p>
<p> 宏观上多个程序在运行,通过分时得以实现</p>
</li>
<li><p>共享</p>
<p> 系统中的资源可供内存中多个并发执行的进程共同使用</p>
</li>
<li><p>虚拟</p>
</li>
<li><p>异步</p>
<p> 可能导致进程产生与时间有关的错误</p>
</li>
</ol>
<h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li><p>时钟管理</p>
<p> 计时,通过时钟中断实现进程切换.</p>
</li>
<li><p>中断机制</p>
<ul>
<li>外中断: 如设备发出I/O结束中断;时钟中断</li>
<li>内中断(异常): 如程序的非法操作码,地址越界…</li>
</ul>
</li>
<li><p>原语</p>
<p> 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作.</p>
</li>
<li><p>系统控制的数据结构及处理</p>
<ol>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol>
</li>
</ol>
<h3 id="存储器的层次结构。"><a href="#存储器的层次结构。" class="headerlink" title="存储器的层次结构。"></a>存储器的层次结构。</h3><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/存储器的架构.png" alt="存储器的层次结构"></p>
<h2 id="（二）进程"><a href="#（二）进程" class="headerlink" title="（二）进程"></a>（二）进程</h2><h3 id="进程的概念和特点；"><a href="#进程的概念和特点；" class="headerlink" title="进程的概念和特点；"></a>进程的概念和特点；</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。</p>
<p>组成:</p>
<ol>
<li><p>PCB: 保存进程运行期间相关数据,是进程存在的唯一标识</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/PCB.png" alt="PCB"></p>
</li>
<li><p>程序段: 能被进程调度程序调度到CPU运行的程序的代码段</p>
</li>
<li>数据段: 存储程序运行期间的相关数据 </li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。动态性是进程最基本的特征。</p>
</li>
<li><p>并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与其他进程的程序并发执行，以提高资源利用率。</p>
</li>
<li><p>独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。</p>
</li>
<li><p>异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。 </p>
</li>
<li><p>结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。</p>
</li>
</ol>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><p>进程状态</p>
<ol>
<li>运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。</li>
<li>就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。</li>
<li>阻塞状态：又称为等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。及时处理器空闲，该进程也不能运行。</li>
<li>创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。</li>
<li><p>结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。</p>
<p> 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要获得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，即使处理器空闲也不能运行。</p>
</li>
</ol>
<p>状态转换</p>
<ul>
<li>就绪状态=&gt;运行状态: 通过处理器调度,就绪进程得到处理器资源</li>
<li>运行状态=&gt;就绪状态: 时间片用完或有更高优先级的进程进入</li>
<li>运行状态=&gt;阻塞状态: 进程所需要的某一资源还未准备好</li>
<li>阻塞状态=&gt;就绪状态: 进程需要的资源已经准备好</li>
</ul>
<h2 id="（三）线程、对称多处理SMP和微内核"><a href="#（三）线程、对称多处理SMP和微内核" class="headerlink" title="（三）线程、对称多处理SMP和微内核"></a>（三）线程、对称多处理SMP和微内核</h2><h3 id="线程的概念，定义线程的必要性和可能性；"><a href="#线程的概念，定义线程的必要性和可能性；" class="headerlink" title="线程的概念，定义线程的必要性和可能性；"></a>线程的概念，定义线程的必要性和可能性；</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成.</p>
<h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性.</p>
<h4 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h4><p>当然可能,废话</p>
<h3 id="线程的功能特性与实现方式；"><a href="#线程的功能特性与实现方式；" class="headerlink" title="线程的功能特性与实现方式；"></a>线程的功能特性与实现方式；</h3><h4 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h4><p>线程状态</p>
<ol>
<li><p>阻塞: 当线程需要等待一个事件,它将被阻塞(保存它的用户寄存器,程序计数器,栈指针),此时处理器执行同一进程中或不同进程的就绪线程</p>
<p> 注:程序计数器是用于存放下一条指令所在单元的地址的地方。</p>
</li>
<li><p>解除阻塞</p>
</li>
<li>结束</li>
</ol>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>用户级线程&amp;内核级线程</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/用户_内核线程.png" alt="线程"></p>
<p>用户级线程(多对一)</p>
<ul>
<li>优点: 效率比较高</li>
<li>缺点: 当一个线程在使用内核服务时被阻塞了,那么整个进程都会被阻塞</li>
</ul>
<p>内核级线程(一对一)</p>
<ul>
<li>优点: 当一个线程在被阻塞时,完全不慌</li>
<li>缺点: 效率低</li>
</ul>
<p>多对多模型: 将n个用户级线程映射到m个内核级线程上,要求m小于等于n</p>
<ul>
<li>缺点&amp;优点: 集大成者</li>
</ul>
<h3 id="线程vs进程"><a href="#线程vs进程" class="headerlink" title="线程vs进程"></a>线程vs进程</h3><ol>
<li><p>调度</p>
<p> 线程时<strong>独立调度</strong>的基本单位,进程时<strong>拥有资源</strong>的基本单位</p>
</li>
<li><p>拥有资源</p>
<p> 进程拥有系统资源,线程也有一点必不可少的资源.</p>
</li>
<li><p>并发性</p>
<p> 拥有线程的操作系统并发性更好.</p>
</li>
<li><p>系统开销</p>
<p> 进程的创建,切换,撤销的效率低于线程</p>
</li>
<li><p>地址空间和其他资源</p>
<p> 进程之间的地址空间相互独立</p>
</li>
<li><p>通信资源</p>
<p> 进程间的通信(IPC)需要进行进程同步和互斥手段的辅助</p>
</li>
</ol>
<h3 id="对称多处理SMP体系结构；"><a href="#对称多处理SMP体系结构；" class="headerlink" title="对称多处理SMP体系结构；"></a>对称多处理SMP体系结构；</h3><h4 id="SMP-Symmetric-multiprocessing"><a href="#SMP-Symmetric-multiprocessing" class="headerlink" title="SMP (Symmetric multiprocessing)"></a>SMP (Symmetric multiprocessing)</h4><p>SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统））</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/SMP.png" alt="SMP"></p>
<h4 id="对称多处理系统"><a href="#对称多处理系统" class="headerlink" title="对称多处理系统"></a>对称多处理系统</h4><p>即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。</p>
<h4 id="非对称处理系统"><a href="#非对称处理系统" class="headerlink" title="非对称处理系统"></a>非对称处理系统</h4><p>让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统</p>
<h4 id="SMP体系结构"><a href="#SMP体系结构" class="headerlink" title="SMP体系结构"></a>SMP体系结构</h4><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/SMP组织结构.png" alt="SMP体系结构"></p>
<ol>
<li><p>并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作；</p>
</li>
<li><p>调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况；</p>
</li>
<li><p>同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制；</p>
</li>
<li><p>存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略；</p>
</li>
<li><p>可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表；</p>
</li>
</ol>
<h3 id="操作系统的体系结构（微内核与单内核）及其性能分析。"><a href="#操作系统的体系结构（微内核与单内核）及其性能分析。" class="headerlink" title="操作系统的体系结构（微内核与单内核）及其性能分析。"></a>操作系统的体系结构（微内核与单内核）及其性能分析。</h3><h4 id="单内核"><a href="#单内核" class="headerlink" title="单内核"></a>单内核</h4><p>单内核就是把os从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。性能好,Unix系统就是单内核.Linux也是单内核,但它加入了很多高级的东西</p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。各个服务器通信需要IPC机制,模块化安全且省地方.windows等</p>
<h2 id="（四）并发"><a href="#（四）并发" class="headerlink" title="（四）并发"></a>（四）并发</h2><h3 id="并发性问题及相关概念，如临界区、互斥、信号量和管程等；"><a href="#并发性问题及相关概念，如临界区、互斥、信号量和管程等；" class="headerlink" title="并发性问题及相关概念，如临界区、互斥、信号量和管程等；"></a>并发性问题及相关概念，如临界区、互斥、信号量和管程等；</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>每个<strong>进程</strong>有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来.</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/临界区问题.png" alt="临界区"></p>
<ol>
<li><p>抢占内核</p>
<p>允许处于内核模式的进程被抢占</p>
</li>
<li><p>非抢占内核</p>
<p>不允许处于内核模式的进程被抢占</p>
</li>
</ol>
<h4 id="互斥-间接制约关系"><a href="#互斥-间接制约关系" class="headerlink" title="互斥(间接制约关系)"></a>互斥(间接制约关系)</h4><p>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<h4 id="同步-直接制约关系"><a href="#同步-直接制约关系" class="headerlink" title="同步(直接制约关系)"></a>同步(直接制约关系)</h4><p>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量S是整数变量,除了初始化,它的值表示<strong>还可以有几个线程进入临界区</strong>,只能通过两个原子操作访问:</p>
<p>wait(S)=&gt;P操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signal(S)=&gt;V操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制的信号量又称为<strong>同步锁</strong></p>
<p>上述的信号量的缺点时<strong>忙等待</strong>,这类型的信号量称为自旋锁(spinlock)</p>
<p>在多处理器的情况下,必须禁止每个处理器的中断.</p>
<p>为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=&gt;就绪状态,等系统调度执行. 定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span> <span class="comment">//PCB链表</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// add this process to list</span></span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">        remove a process P from <span class="built_in">list</span></span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管程-互斥锁-条件变量"><a href="#管程-互斥锁-条件变量" class="headerlink" title="管程 = 互斥锁 + 条件变量"></a>管程 = 互斥锁 + 条件变量</h4><p>管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。</p>
<p>管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行</p>
<p>哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">monitor dp</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">enum</span> &#123;thinking, hungry, eating&#125; state[<span class="number">5</span>];</span><br><span class="line">   condition self[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">pickup</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      state[i] = hungry;</span><br><span class="line">      test(i);</span><br><span class="line">      <span class="keyword">if</span> (state[i] != eating)</span><br><span class="line">         self[i].wait();<span class="comment">//P操作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">putdown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      state[i] = thinking;</span><br><span class="line">      test( (i+<span class="number">4</span>)%<span class="number">5</span> ); <span class="comment">// important</span></span><br><span class="line">      test( (i+<span class="number">1</span>)%<span class="number">5</span> ); <span class="comment">// important</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((state[(i+<span class="number">4</span>)%<span class="number">5</span>] != eating) &amp;&amp;</span><br><span class="line">          (state[i] == hungry) &amp;&amp;</span><br><span class="line">          (state[(i+<span class="number">1</span>)%<span class="number">5</span>] != eating)) &#123;</span><br><span class="line">         state[i] = eating;</span><br><span class="line">         self[i].signal();<span class="comment">//V操作</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">         state[i] = thinking;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程互斥、同步和通信的各种算法；"><a href="#进程互斥、同步和通信的各种算法；" class="headerlink" title="进程互斥、同步和通信的各种算法；"></a>进程互斥、同步和通信的各种算法；</h3><ol>
<li><p>生产者-消费者问题</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce an item in nextp;</span><br><span class="line">        wait(empty) <span class="comment">// P操作,empty--</span></span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        add nextp to buffer;</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">        signal(full); <span class="comment">// V操作,full++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(full);</span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        remove an item from buffer;</span><br><span class="line">        signal(mutex);</span><br><span class="line"></span><br><span class="line">        signal(empty);</span><br><span class="line">        consumer the item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读者-写者问题: 允许多个读者读,但只允许一个写者写</p>
<ul>
<li><p>读者优先</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//保护count</span></span><br><span class="line">semaphore rw=<span class="number">1</span>; <span class="comment">//保证读者和写者互斥地访问文件</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(rw);</span><br><span class="line">        writing;</span><br><span class="line">        singal(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cout</span>==<span class="number">0</span>)</span><br><span class="line">            wait(rw);</span><br><span class="line">        <span class="built_in">cout</span>++;</span><br><span class="line">        singal(mutex);</span><br><span class="line"></span><br><span class="line">        reading;</span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            singal(rw);</span><br><span class="line">        singal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写者优先(公平算法)</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">semaphore rw=<span class="number">1</span>;</span><br><span class="line">semaphore w=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(w);</span><br><span class="line">        wait(rw);</span><br><span class="line">        writing;</span><br><span class="line">        singal(rw);</span><br><span class="line">        singal(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(w); <span class="comment">//无写进程时请求进入</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)</span><br><span class="line">            wait(rw);</span><br><span class="line">        count++;</span><br><span class="line">        singal(mutex);</span><br><span class="line">        singal(w);</span><br><span class="line"></span><br><span class="line">        reading;</span><br><span class="line"></span><br><span class="line">        wait(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)</span><br><span class="line">            singal(rw);</span><br><span class="line">        singal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="死锁的概念、死锁的原因和条件；"><a href="#死锁的概念、死锁的原因和条件；" class="headerlink" title="死锁的概念、死锁的原因和条件；"></a>死锁的概念、死锁的原因和条件；</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>互相等待</p>
<h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><p>产生死锁必须同时满足一下四个条件</p>
<ol>
<li><p>互斥条件</p>
<p> 至少有一个资源处于非共享模式,即一次只能有一个进程使用</p>
</li>
<li><p>非抢占(不可剥夺条件)</p>
<p> 资源不能被抢占,即资源只有在进程完成时后才释放.</p>
</li>
<li><p>占有并等待(请求和保持条件)</p>
<p> 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有</p>
</li>
<li><p>循环等待条件</p>
<p> 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有</p>
</li>
</ol>
<h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/资源分配图.png" alt="资源分配图"></p>
<p>如果分配图有环,则<strong>可能</strong>存在死锁</p>
<p>如果每个资源类型刚好有一个实例,那么有环一定死锁</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/资源分配图例子.png" alt="资源分配图例子"></p>
<h3 id="死锁的预防、避免和检测算法。"><a href="#死锁的预防、避免和检测算法。" class="headerlink" title="死锁的预防、避免和检测算法。"></a>死锁的预防、避免和检测算法。</h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">资源分配策略</th>
<th style="text-align:center">各种可能模式</th>
<th style="text-align:center">主要优点</th>
<th style="text-align:center">主要缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁预防</td>
<td style="text-align:center">保守,宁可资源闲置</td>
<td style="text-align:center">一次请求所有资源,资源剥夺,资源按序分配</td>
<td style="text-align:center">适用与做突发式处理的进程,不必进行剥夺</td>
<td style="text-align:center">效率低;剥夺次数多;不便灵活申请新资源</td>
</tr>
<tr>
<td style="text-align:center">死锁避免</td>
<td style="text-align:center">折中(在运行时判断是否可能死锁)</td>
<td style="text-align:center">寻找可能的安全允许顺序</td>
<td style="text-align:center">不必进行剥夺</td>
<td style="text-align:center">必须知道将来的资源需求;进程不能被长时间阻塞</td>
</tr>
</tbody>
</table>
<p>死锁检测|宽松,只要允许就分配资源|定期检查死锁是否已经发生|不延长进程初始化事件,允许堆死锁进行现场处理|通过剥夺解除死锁,造成损失|</p>
<h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><p>破坏死锁的四个必要条件之一</p>
<ol>
<li><p>破坏互斥条件</p>
<p> 如果允许所有资源都可以共享使用即可.</p>
</li>
<li><p>破坏非抢占</p>
<p> 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源.</p>
<p> 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源.</p>
</li>
<li><p>破坏占有并等待</p>
<p> 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源.</p>
<p> 缺点: 系统资源被严重浪费,而且还会导致饥饿.</p>
</li>
<li><p>破坏循环等待</p>
<p> 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源.</p>
<p> 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦.</p>
</li>
</ol>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><p>在资源动态分配过程中防止系统进入不安全的状态.</p>
<ol>
<li><p>系统安全状态</p>
<p> 对于进程顺序&lt;p1,p2..pn&gt;, pi还需要的资源数 &lt; 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. </p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/安全状态与死锁的关系.png" alt="安全状态与死锁的关系"></p>
<p> 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表</p>
<p> 进程|最大需求|已分配|可用<br> |:—:|:—:|:—:|:—:|<br> |P1|10|5|3<br> P2|4|2<br> P3|9|2</p>
<p> 存在一个安全序列\<p2 p1="" p3\="">，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态.</p2></p>
<p> 如果此时分配1个磁带机给p3,此时就处于不安全状态了.</p>
</li>
<li><p>资源分配图法(每个资源的实例只有一个)</p>
<p> 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/资源分配图法.png" alt="资源分配图法"></p>
<p> 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了.</p>
<p> 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数</p>
</li>
<li><p>银行家算法</p>
<ul>
<li>当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源;</li>
<li><p>进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数.</p>
<p>银行家算法的数据结构</p>
</li>
</ul>
<ol>
<li><p>可利用资源向量Available 　　</p>
<p> 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 　　</p>
</li>
<li><p>最大需求矩阵Max 　　</p>
<p> 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 　　</p>
</li>
<li><p>分配矩阵Allocation 　　</p>
<p> 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 　　</p>
</li>
<li><p>需求矩阵Need。 　　</p>
<p> 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 　　</p>
<p> Need[i,j]=Max[i,j] - Allocation[i,j] </p>
<p>算法过程:</p>
</li>
<li><p>银行家算法</p>
<p> 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<ol>
<li>如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</li>
<li><p>系统试探着把资源分配给进程P i，并修改下面数据结构中的数值：</p>
<p> Available[j]:= Available[j]-Request i[j]；</p>
<p> Allocation[i,j]:= Allocation[i,j]+Request i[j]；</p>
<p> Need[i,j]:= Need[i,j]-Request i[j]；</p>
</li>
<li><p>系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 </p>
</li>
</ol>
</li>
<li><p>安全性检测算法</p>
<ol>
<li><p>设置两个向量：</p>
<ol>
<li>工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。</li>
<li>Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。</li>
</ol>
</li>
<li><p>从进程集合中找到一个能满足下述条件的进程：</p>
<ol>
<li>Finish[i]=false；</li>
<li>Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。</li>
</ol>
</li>
<li><p>当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：</p>
<p> Work[j]:= Work[j]+Allocation[i,j]；<br> Finish[i]:=true；<br> go to step （2）;</p>
</li>
<li><p>如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>
</li>
</ol>
<p>示例</p>
</li>
<li><p>假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号）</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/银行家算法1.png" alt="银行家算法1"></p>
</li>
<li><p>T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/银行家算法2.png" alt="银行家算法2"></p>
</li>
<li><p>P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查：</p>
<ol>
<li>Request1(1，0，2)≤Need1(1，2，2)</li>
<li>Request1(1，0，2)≤Available1(3，3，2)</li>
<li><p>系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/银行家算法3.png" alt="银行家算法3"></p>
</li>
</ol>
</li>
<li><p>再利用安全性算法检查此时系统是否安全。如图所示。</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/银行家算法4.png" alt="银行家算法4"></p>
</li>
<li><p>P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查：</p>
<ol>
<li>Request4(3，3，0)≤Need4(4，3，1)；</li>
<li>Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正）</li>
</ol>
</li>
<li><p>P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查：</p>
<ol>
<li>Request0(0，2，0)≤Need0(7，4，3)；</li>
<li>Request0(0，2，0)≤Available(2，3，0)；</li>
<li><p>系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/银行家算法5.png" alt="银行家算法5"></p>
</li>
</ol>
</li>
<li><p>进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。</p>
<blockquote>
<p><a href="https://blog.csdn.net/cout_sev/article/details/24980627" target="_blank" rel="noopener">https://blog.csdn.net/cout_sev/article/details/24980627</a></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><ol>
<li><p>每种资源都只有单个实例</p>
<p> 创建等待图,如果等待图成环就代表发生了死锁</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/等待图.png" alt="等待图"></p>
</li>
<li><p>多个实例的死锁检测</p>
<p> 数据结构</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/多个实例的死锁检测1.png" alt="数据结构"></p>
<p> 示例</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/多实例的死锁检测2.png" alt="示例"></p>
<p> 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4</p>
<p> 假如p2 又请求了资源C的实例</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/多实例的死锁检测3.png" alt="示例"></p>
<p> 此时就发生了死锁</p>
</li>
<li><p>死锁解除</p>
<p> 一旦检测出死锁,应立即采取相应的措施,如:</p>
<ol>
<li><p>资源剥夺法</p>
<p>  挂起某些死锁进程,并抢占其资源,给其他的死锁进程</p>
</li>
<li><p>撤销进程法</p>
<p>  强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价.</p>
</li>
<li><p>进程回退法</p>
<p>  让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点.</p>
</li>
</ol>
</li>
</ol>
<h2 id="（五）存储器管理"><a href="#（五）存储器管理" class="headerlink" title="（五）存储器管理"></a>（五）存储器管理</h2><h3 id="分区存储管理、覆盖与交换；"><a href="#分区存储管理、覆盖与交换；" class="headerlink" title="分区存储管理、覆盖与交换；"></a>分区存储管理、覆盖与交换；</h3><p>基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。</p>
<h4 id="工作集和驻留集"><a href="#工作集和驻留集" class="headerlink" title="工作集和驻留集"></a>工作集和驻留集</h4><p> 驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间.</p>
<p> 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合.</p>
<h4 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h4><p>为一个用户程序分配一个连续的内存空间.</p>
<p>为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。</p>
<ol>
<li><p>单一连续分配</p>
<p> 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。</p>
</li>
<li><p>固定分区分配</p>
<p> 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。</p>
<p> 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</p>
<p> 优点：易于实现，开销小。</p>
<p> 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。</p>
</li>
<li><p>动态分区分配 </p>
<p> 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</p>
<p> 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区</p>
<p> 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</p>
<p> 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</p>
<p> 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</p>
<p> 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</p>
</li>
</ol>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。</p>
<p>覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。</p>
<p>覆盖的实现方式有两种：以函数库方式实现或操作系统支持。</p>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。</p>
<p>交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。</p>
<h4 id="覆盖与交换比较"><a href="#覆盖与交换比较" class="headerlink" title="覆盖与交换比较"></a>覆盖与交换比较</h4><ol>
<li><p>与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。</p>
</li>
<li><p>交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。</p>
</li>
</ol>
<h3 id="页式管理及段式管理；"><a href="#页式管理及段式管理；" class="headerlink" title="页式管理及段式管理；"></a>页式管理及段式管理；</h3><h4 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h4><p>将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）</p>
<p>页式管理方式的优点是：</p>
<p>没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是:</p>
<ol>
<li><p>一个程序不必连续存放。</p>
</li>
<li><p>便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</p>
</li>
</ol>
<p>缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。</p>
<h4 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h4><p>在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等</p>
<p>每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。</p>
<h4 id="页式和段式区别"><a href="#页式和段式区别" class="headerlink" title="页式和段式区别"></a>页式和段式区别</h4><ol>
<li>需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li>
<li>大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。</li>
<li>逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。</li>
</ol>
<h3 id="段、页式存储管理方法及实现技术；"><a href="#段、页式存储管理方法及实现技术；" class="headerlink" title="段、页式存储管理方法及实现技术；"></a>段、页式存储管理方法及实现技术；</h3><h4 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h4><p>进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/页表.jpg" alt="页表"></p>
<ol>
<li><p>基本地址变换</p>
<p> 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制)</p>
<ol>
<li>计算页号P=A/L,页内偏移W=A%L</li>
<li>比较页号P和页表长度M,若P&gt;=M则产生越界中断</li>
<li>页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号).</li>
<li><p>计算E=b*L+W得结果</p>
<p>页式管理中地址空间是<strong>一维的</strong></p>
<p>页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log<sub>2</sub>1M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小&gt;=20/8向上去整=3B.</p>
</li>
</ol>
</li>
<li><p>具有快表的地址变换</p>
<p> 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项</p>
<p> 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中.</p>
</li>
<li><p>两级页表</p>
<p> 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈；</p>
<p> 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找</p>
<p> 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项</p>
</li>
</ol>
<h4 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h4><p>段式存储更易于信息共享.比说代码段多用户共享.</p>
<p>地址变换</p>
<p>为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S&gt;TL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,<strong>再检查段内地址 d 是否超过该段的段长 SL</strong>。若超过,即 d&gt;SL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。</p>
<h4 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h4><p>段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/段页式系统.png" alt="段页式系统"></p>
<p>在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S&lt;TL,表示未越界,于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置,从中得到该段的页表始址,并利用逻辑地址中的段内页号 P 来获得对应页的页表项位置,从中读出该页所在的物理块号 b,再利用块号 b 和页内地址来构成物理地址。</p>
<blockquote>
<p><a href="https://blog.csdn.net/hguisu/article/details/5713164" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/5713164</a> </p>
</blockquote>
<h3 id="虚存的原理及相关的各种算法和数据结构。"><a href="#虚存的原理及相关的各种算法和数据结构。" class="headerlink" title="虚存的原理及相关的各种算法和数据结构。"></a>虚存的原理及相关的各种算法和数据结构。</h3><h4 id="虚存的概念"><a href="#虚存的概念" class="headerlink" title="虚存的概念"></a>虚存的概念</h4><ol>
<li><p>传统的存储管理方式的特征</p>
<ol>
<li>一次性: 作业必须一次性全部装入内存,才能运行</li>
<li>驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束</li>
</ol>
</li>
<li><p>虚存的定义和特征</p>
<p> 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<ol>
<li>多次性: 无需在作业运行时一次性地全部装入内存.</li>
<li>对换性: 允许作业在运行过程中,进行换进换出</li>
<li><p>虚拟性: 从逻辑上扩充内存的容量</p>
<p>一定要有一下几个方面</p>
</li>
<li><p>一定的内存和外存</p>
</li>
<li>页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构(MMU)</li>
</ol>
</li>
</ol>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ol>
<li><p>最佳置换算法(OPT)  </p>
<p> 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p>
<p> 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：</p>
<p> 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. </p>
</li>
<li><p>先进先出(FIFO)算法</p>
<p> 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/先进先出.png" alt="FIFO"></p>
<p> Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现.</p>
</li>
<li><p>最久未使用(LRU)置换算法</p>
<p> 选择最长时间未访问过的页面予以淘汰.堆栈类算法</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/LRU页面置换算法.png" alt="LRU"></p>
</li>
<li><p>时钟(CLOCK)置换算法,又称最近未用算法(NRU)</p>
<p> 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。</p>
<p> CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p>
<ol>
<li>最近未被访问，也未被修改(u=0, m=0)。</li>
<li>最近被访问，但未被修改(u=1, m=0)。</li>
<li>最近未被访问，但被修改(u=0, m=1)。</li>
<li><p>最近被访问，被修改(u=1, m=1)。</p>
<p>算法执行如下操作步骤：</p>
</li>
<li><p>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</p>
</li>
<li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li>
<li><p>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</p>
<p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间</p>
<p>优先级: u=0,m=0&gt;u=0,m=1</p>
</li>
</ol>
</li>
</ol>
<h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><p>给特定的进程分配多大的主存空间</p>
<ol>
<li>固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换</li>
<li>可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配</li>
<li>可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点.</li>
</ol>
<h2 id="（六）单处理器调度"><a href="#（六）单处理器调度" class="headerlink" title="（六）单处理器调度"></a>（六）单处理器调度</h2><h3 id="处理器的三种调度类型；"><a href="#处理器的三种调度类型；" class="headerlink" title="处理器的三种调度类型；"></a>处理器的三种调度类型；</h3><ol>
<li><p>作业调度(高级调度)</p>
<p> 从外存的后备队列中选择一批作业进入内存，为他们建立进程。这些进程被送入就绪队列。频率最低.多道批处理系统才有.</p>
</li>
<li><p>中级调度</p>
<p> 将暂时不能运行的进程调至外存等待,为了提高内存利用率和系统吞吐量</p>
</li>
<li><p>进程调度(低级调度)</p>
<p> 按照某种方法和策略从就绪队列中选取一个进程执行.</p>
</li>
</ol>
<h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><ol>
<li><p>抢占和非抢占调度</p>
<p> 根据任务运行的过程中能否被中断的情况，把调度算法分为抢占和非抢占两种。在抢占式调度算法中，正在运行的任务可以被其他任务打断。在非抢占式调度算法中，一旦任务开始运行，该任务只有在运行完后而主动放弃CPU资源或者是因为等待其他资源而被阻塞的情况下才可能停止。</p>
</li>
<li><p>静态和动态调度</p>
<p> 根据任务优先级确定的时机，把调度算法分为静态调度和动态调度两种。在静态调度算法中，所有任务的优先级在运行之前已经确定下来，这就要求能够完全把握系统中的所有任务及其时间约束（如截止时间，运行时间，优先顺序等）。在动态调度算法中，任务的优先级在在运行时确定，并且可能不断的发生变化。</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://blog.csdn.net/Stephan14/article/details/46468241" target="_blank" rel="noopener">https://blog.csdn.net/Stephan14/article/details/46468241</a> </p>
</blockquote>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ol>
<li>当一个进程从运行状态切换到等待状态(例如,IO请求,调用wait)</li>
<li>当一个进程从运行状态切换到就绪状态(例如,出现中断)</li>
<li>当一个进程从等待状态切换到就绪状态(例如,IO完成时)</li>
<li>当一个进程终止时</li>
</ol>
<p>当调度只发生在1和4两种情况时,称为非抢断.否则是抢断的.</p>
<h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul>
<li>CPU使用率</li>
<li>吞吐量: 单位事件内完成进程的数量</li>
<li>周转时间: 从某个特定的进程的角度看,从进程提交到进程完成的时间段.包括,等待进入内存,在就绪队列中等待,在cpu执行和IO执行</li>
<li>等待时间: 进程在就绪队列中等待所花费时间之和.</li>
<li>响应时间: 在交互系统中,从提交请求到产生第一响应的事件.就是开始响应所需要的时间</li>
</ul>
<h3 id="进程调度的各种算法及其特点。"><a href="#进程调度的各种算法及其特点。" class="headerlink" title="进程调度的各种算法及其特点。"></a>进程调度的各种算法及其特点。</h3><ul>
<li><p>先到先服务调度(FCFS:first-come,first-served)</p>
<p>  <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/FCFS.png" alt="FCFS"></p>
</li>
<li><p>最短作业优先调度(SJF:shortest-job-first)非抢占式</p>
<p>  <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/SJF.png" alt="SJF"></p>
</li>
<li><p>最短剩余事件优先调度(SRTN:shortest-remaining-time-first) 抢占式的SJF</p>
<p>  <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/抢占式SJF.png" alt="抢占式SJF"></p>
</li>
<li><p>优先级调度（Priority Scheduling）/一般用小数字表示高优先级</p>
<p>  缺陷: 叽饿;无穷阻塞,低优先级的无穷等待</p>
<p>  解决方法: 老化(aging),逐渐增加系统中等待事件长的进程的优先级</p>
</li>
<li><p>轮转法(Round Robin，RR)专门为分时系统设计</p>
<ol>
<li>每个就绪进程获得一小段CPU时间（时间片，time quantum），通常10ms - 100ms</li>
<li><p>时间片用毕，这个进程被迫交出CPU，重新挂回到就绪队列,当然，进程在时间片用毕之前其Burst Cycle结束，也（主动）交出CPU</p>
<p>假设n个就绪进程，时间片q，每个就绪进程得到1/n的CPU时间。任何就绪进程最多等待(n-1)*q单位时间.</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/RR.png" alt="RR"></p>
<p>轮转法还有一个好处，就是他的响应时间一定优于前面的SJF。因为时间片的存在。</p>
</li>
</ol>
</li>
<li><p>多级队列调度</p>
<p>  要求交互的进程，在前台队列。可以批处理的进程，在后台队列。</p>
<p>  每个队列都有其自己的调度算法，例如：</p>
<ol>
<li>前台就绪队列 — RR</li>
<li><p>后台就绪队列 — FCFS</p>
<p>按优先级分别为：</p>
</li>
<li>系统进程队列，要实时响应。</li>
<li>交互进程队列（要求响应非常及时）—— RR</li>
<li>交互编辑队列（人输入键盘，移动鼠标等，响应时间可能半秒也可以，对操作系统来说已经很长了。交互要求不是很高）—— RR</li>
<li><p>批处理进程队列，不需要交互。—— FCFS</p>
<p>CPU怎么在队列间分配？</p>
</li>
<li><p>固定优先权法。例如，先前台队列，再后台队列。</p>
</li>
<li>时间片办法，例如，80%的CPU时间给前台队列，20%CPU时间给后台进程。</li>
</ol>
</li>
<li><p>多层反馈队列调度</p>
<p>  <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/多级反馈队列.png" alt="多级反馈队列调度"></p>
<p>  图上三层队列：</p>
<ol>
<li>Q0 — 用RR算法，时间片8ms</li>
<li>Q1 — 用RR算法，时间片16ms</li>
<li><p>Q2 — 用FCFS算法。</p>
<p>调度场景</p>
</li>
<li><p>一个就绪进程进入Q0层，当它分配到CPU，可执行8ms。如果它8ms后没有执行完毕，则迁移至Q1层。否则，它离开就绪队列该干嘛干嘛。</p>
</li>
<li>在Q1层，当它分配到CPU，可执行16ms。如果它16ms后没有执行完毕，则迁移至Q2层。否则，它离开就绪队列，该干嘛干嘛。</li>
</ol>
</li>
</ul>
<p>总结</p>
<p>忽略HRRN,Feedback</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/cpu调度算法总结.png" alt="cpu调度"></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/65360b500ad9" target="_blank" rel="noopener">https://www.jianshu.com/p/65360b500ad9</a></p>
</blockquote>
<h2 id="（七）多处理器调度和实时调度"><a href="#（七）多处理器调度和实时调度" class="headerlink" title="（七）多处理器调度和实时调度"></a>（七）多处理器调度和实时调度</h2><h3 id="多处理器对进程调度的影响；"><a href="#多处理器对进程调度的影响；" class="headerlink" title="多处理器对进程调度的影响；"></a>多处理器对进程调度的影响；</h3><ol>
<li><p>处理器亲和性</p>
<p>由于使缓存无效或重新构建的代价高,绝大多数SMP系统试图避免将进程从一个处理器移至另一个处理器,而是努力使-个进程在同一个处理器上运行,这被称为处理器亲和性.</p>
<p> 当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略,但不能做任何保证时,则会出现<strong>软亲和性</strong>,有可能在处理器之间移动。,还提供一个支持<strong>硬亲和性</strong>的系统调用,从而允许进程指定它不允许移至其他处理器上。</p>
</li>
<li><p>负载均衡</p>
</li>
</ol>
<h3 id="多处理器环境下的进程和线程调度算法；"><a href="#多处理器环境下的进程和线程调度算法；" class="headerlink" title="多处理器环境下的进程和线程调度算法；"></a>多处理器环境下的进程和线程调度算法；</h3><h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><ol>
<li><p>全局队列调度 </p>
<ol>
<li>操作系统维护一个全局的任务等待队列。</li>
<li>当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。</li>
</ol>
<ul>
<li>这种方法的优点是CPU核心利用率较高。</li>
</ul>
</li>
<li><p>局部队列调度</p>
<ol>
<li>操作系统为每个CPU内核维护一个局部的任务等待队列。</li>
<li>当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行。</li>
</ol>
<ul>
<li>这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。</li>
<li>目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。</li>
</ul>
</li>
</ol>
<h3 id="实时进程的特点；"><a href="#实时进程的特点；" class="headerlink" title="实时进程的特点；"></a>实时进程的特点；</h3><ol>
<li>这些进程往往执行非常重要的操作,要求立即响应并执行</li>
<li>只能被更高优先级的实时进程抢占</li>
<li>比普通进程的优先级都要高</li>
</ol>
<h3 id="限期调度和速率单调调度方法。"><a href="#限期调度和速率单调调度方法。" class="headerlink" title="限期调度和速率单调调度方法。"></a>限期调度和速率单调调度方法。</h3><p>实时系统的可调度条件:</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/实时系统的可调度条件.png" alt="实时系统的可调度"> (有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间来处理事件)</p>
<ol>
<li><p>速率单调调度（实时静态算法）Rate Monotonic Scheduling，RMS</p>
<p> 以用于满足以下条件的进程：</p>
<ul>
<li>每个周期性进程必须在其周期内完成。</li>
<li>没有进程依赖于任何其他进程。</li>
<li>每一个进程在一次突发中需要相同的CPU时间量。</li>
<li>任何非周期进程都没有最终时限。</li>
<li><p>进程抢占时刻发生而没有系统开销。（理想模型）</p>
<p>单调速率算法按照以下规则给进程设立优先级：比如A进程每30ms运行一次，则每秒运行33次，则获得优先级33；B进程每秒运行20次，则获得优先级20，所以优先级与速率成线性关系，这就是这个算法的名字的来历。RMS算法是最优的实时静态算法中。</p>
<p>如果<img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/RMS_条件.png" alt="RMS"> 成立,则其可以正常工作</p>
</li>
</ul>
</li>
<li><p>最早最终时限调度（实时动态算法）Earliest Deadline First，EDF</p>
<p> 列表按最终时限排序，EDF算法运行列表中的第一个进程，也是具有最近最终时限的进程。当一个新的进程就绪时，系统进行检查以了解其最终时限是否发生在当前运行的进程结束之前。如果是这样，那么新的进程就抢占当前正在运行的进程。</p>
</li>
</ol>
<p>对比</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/RMS_EDF_1.png" alt="RMS_EDF_1"></p>
<p>对于RMS来说,前70ms,A以30ms为周期,每秒运行33次故优先级为33,同理得优先级A&gt;B&gt;C(33&gt;25&gt;20),在90ms时,A4的优先级高于B,所以抢占.</p>
<p>对于EDF来说,最终期限就是下一周期的起始时刻.在90ms时A和B的最终期限一样,不进行抢占</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/RMS_EDF_2.png" alt="RMS_EDF_2"></p>
<p>由于RMS的优先级只于速率有关,而与进程运行时间无关,所以在40-50ms时选择了执行B导致C未在下个周期开始前执行,导致失败.</p>
<blockquote>
<p><a href="https://www.cnblogs.com/Philip-Tell-Truth/p/6680529.html" target="_blank" rel="noopener">https://www.cnblogs.com/Philip-Tell-Truth/p/6680529.html</a></p>
</blockquote>
<h2 id="（八）设备管理和磁盘调度"><a href="#（八）设备管理和磁盘调度" class="headerlink" title="（八）设备管理和磁盘调度"></a>（八）设备管理和磁盘调度</h2><h3 id="操作系统中输入-输出功能的组织；"><a href="#操作系统中输入-输出功能的组织；" class="headerlink" title="操作系统中输入/输出功能的组织；"></a>操作系统中输入/输出功能的组织；</h3><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><p>外围设备和内存之间的I/O控制方式:</p>
<ol>
<li><p>程序直接控制法</p>
<p> 无中断机制,cpu对外设状态进行循环检查</p>
</li>
<li><p>中断驱动方式</p>
<p> I/O控制器收到cpu的一个读命令之后cpu就做其他事情,一旦数据读入,I/O控制器给CPU发送中断信号,表示数据已准备好.然后等待CPU请求该数据.</p>
<p> 但由于每个字再存储器与I/O设备之间的传输必须经过cpu,导致了消耗过多的cpu时间</p>
</li>
<li><p>DMA方式 (直接内存访问)</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/DMA步骤.png" alt="DMA过程"></p>
</li>
<li><p>通道控制方式</p>
<p> I/O通道和DMA方式的区别是:DMA方式需要CPU来控制传输的数据块大小,传输的内存位置,而I/O通道方式中这些信息由通道控制.另外,每个DMA控制器对应一台设备与内存传递数据,而一个通道可以控制多台设备与内存的数据交换.</p>
</li>
</ol>
<h3 id="中断处理；"><a href="#中断处理；" class="headerlink" title="中断处理；"></a>中断处理；</h3><ol>
<li><p>应用进程请求读操作。</p>
</li>
<li><p>设备启动程序（设备驱动程序的上半部分）查询设备控制器的状态寄存器，确定设备是否空闲；如果设备忙，则设备启动程序等待，直到它变为空闲为止。</p>
</li>
<li><p>设备启动程序把输入命令存入设备控制器的命令寄存器中，从而启动设备。</p>
</li>
<li><p>设备启动程序将相应信息写入到设备状态表的设备对应表项中，如最初调用的返回地址，以及I／O操作的一些特定参数等。然后CPU就可以分配给其他进程使用了，因此设备管理器调用进程管理器的调度程序执行，原进程的执行就被暂停了。</p>
</li>
<li><p>经过一段时间设备完成了I／O操作后，设备控制器发出中断请求，中断CPU上运行的进程，从而引起CPU运行中断处理程序。</p>
</li>
<li><p>中断处理程序确定是哪个设备引起的中断，然后转移到该设备对应的设备处理程序（设备驱动程序的下半部分）执行（唤醒设备驱动程序）。</p>
</li>
<li><p>设备处理程序重新从设备状态表中，找到等待I／O操作的状态信息。</p>
</li>
<li><p>设备处理程序拷贝设备控制器的数据寄存器的内容到用户进程的内存区。</p>
</li>
<li><p>设备处理程序返回给应用进程控制权，从而继续运行。</p>
</li>
</ol>
<h3 id="设备驱动程序、设备无关的软件接口和spooling技术；"><a href="#设备驱动程序、设备无关的软件接口和spooling技术；" class="headerlink" title="设备驱动程序、设备无关的软件接口和spooling技术；"></a>设备驱动程序、设备无关的软件接口和spooling技术；</h3><h4 id="I-O子系统层次结构"><a href="#I-O子系统层次结构" class="headerlink" title="I/O子系统层次结构"></a>I/O子系统层次结构</h4><ol>
<li><p>用户层I/O软件</p>
<p> 实现与用户交互的接口</p>
</li>
<li><p>设备独立性软件</p>
<p> 实现用户程序与设备驱动器的统一接口,设备命令,设备保护,设备分配与释放</p>
<p> <strong>设备无关软件接口</strong></p>
<p> 这类设备无关性软件面向应用层并提供一个统一的应用编程接口(API)，它提供了一组功能函数，应用程序员能够通过调用它们管理设备。这个接口是设备硬件的一个大大简化了的简单抽象的接口，提供的是对具有逻辑性质的逻辑设备上的逻辑操作。由文件系统和设备管理功能接受、翻译、转换为相应的物理设备、物理性质、物理操作。与设备无关的系统软件实现的功能有：设备驱动程序的统一接口，设备命名，设备保护，提供一个与设备无关的逻辑块，缓冲，存储设备的块分配，独占设备的分配和释放，错误处理等。</p>
</li>
<li><p><strong>设备驱动程序</strong></p>
<p> 与硬件直接相关,负责具体实现系统对设备放出的操作指令.</p>
<p> 主要功能将来自上层软件的与设备无关的的抽象请求转为具体请求，向有关的输入输出设备的各种控制器的寄存器发出控制命令，并监督它们的正确执行，进行必要的错误处理。还要对各种可能的有关设备排队、挂起、唤醒等操作进行处理，执行确定的缓冲区策略等</p>
</li>
<li><p>中断处理程序</p>
<p> 用于处理中断相关事项.</p>
</li>
<li><p>硬件</p>
<p> 包括一个机械部件和一个电子部件(控制器)</p>
</li>
</ol>
<h4 id="spooling"><a href="#spooling" class="headerlink" title="spooling"></a>spooling</h4><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/SPOOLing组成.jpg" alt="组成"></p>
<p>就是把磁盘当做缓冲区.</p>
<p>当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正 立即把打印机分配给该用户进程，而只为它做两件事：</p>
<ul>
<li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中.输出进程再为用户进程申请一张空白的用户请求打印表</li>
<li>将用户的打印要求填入其中，再将该表挂到请求打印队列上。</li>
</ul>
<p>SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。</p>
<h3 id="缓冲策略；"><a href="#缓冲策略；" class="headerlink" title="缓冲策略；"></a>缓冲策略；</h3><ol>
<li><p>单缓冲</p>
<p> 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为 C。由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之则为M+C，故可把系统对每一块数据的处理时间表示为<strong>Max(C, T)+M</strong>.</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/单缓冲.png" alt="单缓冲"></p>
</li>
<li><p>双缓冲</p>
<p> 据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。 I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。双缓冲机制提高了处理机和输入设备的并行操作的程度。</p>
<p> 处理用时 MAX(C+M,T)</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/双缓冲.png" alt="双缓冲"></p>
</li>
<li><p>循环缓冲</p>
<p> 包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。（类似于循环队列）</p>
<p> 循环缓冲用于输入/输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反。</p>
</li>
<li><p>缓冲池</p>
<p> 由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：</p>
<ul>
<li>空缓冲队列</li>
<li>装满输入数据的缓冲队列（输入队列）</li>
<li><p>装满输出数据的缓沖队列（输出队列）。</p>
<p>还应具有四种缓冲区：</p>
</li>
<li><p>用于收容输入数据的工作缓冲区</p>
</li>
<li>用于提取输入数据的工作缓冲区</li>
<li>用于收容输出数据的工作缓冲区</li>
<li><p>用于提取输出数据的工作缓冲区。</p>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/缓冲池.png" alt="缓冲池"></p>
<p>当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。</p>
<p>当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。</p>
<p>当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。</p>
<p>当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。</p>
</li>
</ul>
</li>
</ol>
<h3 id="磁盘调度算法；"><a href="#磁盘调度算法；" class="headerlink" title="磁盘调度算法；"></a>磁盘调度算法；</h3><p>假设当前磁头在67号，要求访问的磁道号顺序为98,25,63,97,56,51,55,55,6  (电脑随机产生的,设定最外层磁道号为100号)</p>
<ol>
<li><p>FIFO：先来先服务算法；</p>
<p> 假设当前磁道在某一位置，依次处理服务队列里的每一个磁道，这样做的优点是处理起来比较简单，但缺点是磁头移动的距离和平均移动距离会很大。</p>
<p> FIFO算法的服务序列是：98,25,63,97,56,51,55,55,6</p>
<p> 磁头移动的总距离distance = (98-67)+(98-25)+(63-25)+(97-63)+(97-56)+(56-51)+(55-51)+(55-55)+(55-6)</p>
</li>
<li><p>SSTF： 最短寻道时间算法；</p>
<p> 假设当前磁道在某一位置，接下来处理的是距离当前磁道最近的磁道号，处理完成之后再处理离这个磁道号最近的磁道号，直到所有的磁道号都服务完了程序结束.</p>
<p> 这样做的优点是性能会优于FIFO算法，但是会产生距离当前磁道较远的磁道号长期得不到服务，也就是“饥饿”现象，因为要求访问的服务的序列号是动态产生的，即各个应用程序可能不断地提出访问不同的磁道号的请求。</p>
<p> SSTF算法的服务序列是: 63,56,55,55,51,25,6,97,98</p>
<p> 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97)</p>
</li>
<li><p>SCAN：电梯调度算法；(这样命名很形象)</p>
<p> 先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描，这里要注意，假设最里层为0号磁道，最里面的一个要求服务的序列是5号，访问完5号之后，就反向了，不需要再往里扫。结合电梯过程更好理解，在电梯往下接人的时候，明知道最下面一层是没有人的，它是不会再往下走的。(LOOK调度才是如此)</p>
<p> SCAN算法的服务序列是：63,56,55,55,51,25,6,97,98</p>
<p> 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97)</p>
</li>
<li><p>CSCAN： 循环扫描算法 (C-LOOK)</p>
<p> 由于上边的算法在磁头折返回去的时候,会导致很长一段时间可能没有服务.因为最近已经访问过了.</p>
<p> 访问完最里面一个要求服务的序列之后，立即回到最外层欲访问磁道。也就是始终保持一个方向。故也称之为单向扫描调度算法。从最里面的一个磁道立即回到最外层欲访问的磁道，这步的距离是两者磁道号差的绝对值。</p>
<p> CSCAN算法的服务序列是：63,56,55,55,51,25,6,98,97</p>
<p> distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+|6-98|+(98-97</p>
</li>
<li><p>FSCAN：分步电梯调度算法(分两个队列)</p>
<p> 在扫描的过程中所有新产生的序列放在另外的一个队列中，当访问完当前队列之后，再访问新产生的一个队列。这种算法可以有效防止磁壁粘着现象。</p>
</li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/Jaster_wisdom/article/details/52345674" target="_blank" rel="noopener">https://blog.csdn.net/Jaster_wisdom/article/details/52345674</a></p>
</blockquote>
<h3 id="磁盘阵列-Redundant-Array-of-Independent-Disks"><a href="#磁盘阵列-Redundant-Array-of-Independent-Disks" class="headerlink" title="磁盘阵列(Redundant Array of Independent Disks)"></a>磁盘阵列(Redundant Array of Independent Disks)</h3><ol>
<li><p>RAID 0</p>
<p> 没有冗余</p>
</li>
<li><p>RAID 1</p>
<p> 原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件</p>
</li>
<li><p>RAID 2 差错纠正码</p>
<p> 每个字节都有相关的奇偶位,存在其他磁盘上,损坏一位的时候可以恢复.</p>
</li>
<li><p>RAID 3 交叉奇偶结构</p>
<p> 按扇区为单位来计算奇偶值.</p>
</li>
<li><p>RAID 4 块交织奇偶结构</p>
<p> 按磁盘来计算奇偶值,计算结果存在一个磁盘上</p>
</li>
<li><p>RAID 5</p>
<p> 按磁盘来计算奇偶值,结果保存在不同的磁盘上.</p>
</li>
<li><p>RAID 6</p>
<p> 类似 RAID 5 但是加入了差错纠正码等.</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/raid的级别.png" alt="RAID"></p>
<h2 id="（九）文件系统"><a href="#（九）文件系统" class="headerlink" title="（九）文件系统"></a>（九）文件系统</h2><h3 id="文件系统特点与文件组织方式；"><a href="#文件系统特点与文件组织方式；" class="headerlink" title="文件系统特点与文件组织方式；"></a>文件系统特点与文件组织方式；</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>管理文件的软件,被管理的文件及数据结构</p>
<p>文件则是指具有文件名的若干相关元素的集合。元素通常是记录,而记录又是一组有意义的数据项的集合。</p>
<h4 id="文件组织方式"><a href="#文件组织方式" class="headerlink" title="文件组织方式"></a>文件组织方式</h4><ol>
<li>无结构文件(流式文件): 以字节为单位,顺序存储.只能通过穷举搜索方式,来查找文件中的数据</li>
<li><p>有结构文件(记录式文件) </p>
<ol>
<li><p>顺序文件: 记录一个接一个顺序排列</p>
<ul>
<li>串结构: 记录之间的顺序与关键字无关,由时间决定</li>
<li>顺序结构: 按关键字排序</li>
</ul>
</li>
<li><p>索引文件: 未变长文件建立索引表,提高查找速度</p>
</li>
<li>索引顺序文件: 索引文件与顺序文件相结合</li>
<li>直接文件: 通过hash函数直接决定记录的地址</li>
</ol>
</li>
</ol>
<h3 id="文件系统的数据结构；"><a href="#文件系统的数据结构；" class="headerlink" title="文件系统的数据结构；"></a>文件系统的数据结构；</h3><ol>
<li><p>链式文件系统</p>
<p> 文件的块是分布在各个零散的空间中，这样对空间的利用率有极大的提升。但是想要放到到某个指定的块就必须从第一个块开始向下寻找，访问的速度较慢。</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/链式文件系统.jpg" alt="img"></p>
</li>
<li><p>索引文件系统</p>
<p> 为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/索引文件系统.jpg" alt="索引文件系统"></p>
<p> 索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。</p>
</li>
<li><p>间接索引表</p>
<p> 每个索引表中有15个索引项，前12个索引项对应文件的12个块，他们是文件的直接块。若文件大于12块，就再建立一个新的块索引表，新索引表称为一级间接索引表，表中可容纳256个块地址，这个索引表也会占用一个物理块，老的索引表的第13个索引项就会指向这个索引表所在的物理块。通过一级间接索引表，文件最大可达到 12 + 256 = 268块。</p>
<p> <img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/innode.jpg" alt="inode"></p>
<p> 超级块</p>
<p> 在文件系统中，一个文件用一个inode表示，所有的inode组成了inode数组，这个inode数组存储在哪里，如何对其进行管理。文件系统中，哪些块被使用了，哪些块是空闲的，这些信息都需要记录，对这些数据进行统一管理和记录的数据结构叫做超级块</p>
</li>
</ol>
<h3 id="目录的基本性质及其实现方法；"><a href="#目录的基本性质及其实现方法；" class="headerlink" title="目录的基本性质及其实现方法；"></a>目录的基本性质及其实现方法；</h3><h4 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h4><ol>
<li>单级: 所有文件都放在一个目录下</li>
<li>两级: 在目录下分出用户目录</li>
<li>多级: 树形结构</li>
<li>无环图: 在树形结构上加入一些有向边</li>
</ol>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ol>
<li>基于索引节点(硬链接): 共享文件指向同一个索引节点,当索引节点的count==0是删除该节点</li>
<li>基于符号链(软链接): 保存共享文件的路径,类似快捷方式</li>
</ol>
<h3 id="磁盘空间的管理。"><a href="#磁盘空间的管理。" class="headerlink" title="磁盘空间的管理。"></a>磁盘空间的管理。</h3><p>维护一个空闲空间链表.</p>
<h2 id="（十）分布式系统"><a href="#（十）分布式系统" class="headerlink" title="（十）分布式系统"></a>（十）分布式系统</h2><h3 id="分布式操作系统的类型"><a href="#分布式操作系统的类型" class="headerlink" title="分布式操作系统的类型"></a>分布式操作系统的类型</h3><ol>
<li>网络操作系统 ssh</li>
<li>分布式操作系统</li>
</ol>
<h3 id="分布式处理的特点、类型；"><a href="#分布式处理的特点、类型；" class="headerlink" title="分布式处理的特点、类型；"></a>分布式处理的特点、类型；</h3><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/三种操作系统比较.png" alt="img"></p>
<h3 id="多层体系结构、中间件技术；"><a href="#多层体系结构、中间件技术；" class="headerlink" title="多层体系结构、中间件技术；"></a>多层体系结构、中间件技术；</h3><p><img src="https://raw.githubusercontent.com/ImportMengjie/KaoYan_807/master/images/中间件.png" alt="中间件"></p>
<h3 id="机群系统；"><a href="#机群系统；" class="headerlink" title="机群系统；"></a>机群系统；</h3><p>分布式：一个业务分拆多个子业务，部署在不同的服务器上</p>
<p>集群：同一个业务，部署在多个服务器上</p>
<h3 id="分布式进程管理相关的操作系统设计问题。"><a href="#分布式进程管理相关的操作系统设计问题。" class="headerlink" title="分布式进程管理相关的操作系统设计问题。"></a>分布式进程管理相关的操作系统设计问题。</h3><ol>
<li>透明性: 对于用户来说很多事情无法知道</li>
<li>可伸缩性: 可多可少</li>
<li>可靠性</li>
</ol>
</div><div class="tags"><a href="/tags/基础知识/">基础知识</a></div><div class="post-nav"><a class="pre" href="/2019/01/03/数据结构/">数据结构</a><a class="next" href="/2018/03/04/Deep-Learning学习笔记/">Deep Learning学习笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/DL/" style="font-size: 15px;">DL</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/Linux高性能服务器编程读书笔记-md/">Linux高性能服务器编程读书笔记.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/24/cpp的坑/">cpp的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/英语音标学习/">英语音标学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/20/golang-奇怪的nil/">golang-奇怪的nil</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/09/golang-slice,map-笔记/">golang slice,map 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/03/数据结构/">数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/03/操作系统/">操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/04/Deep-Learning学习笔记/">Deep Learning学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Linux学习笔记/">Linux学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/Python学习笔记/">Python学习笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Mengjie's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>