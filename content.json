{"meta":{"title":"Mengjie's Blog","subtitle":null,"description":null,"author":"Mengjie","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-03T12:23:01.857Z","updated":"2018-08-21T12:21:57.795Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Search","date":"2018-02-27T05:40:44.000Z","updated":"2018-08-21T12:21:57.790Z","comments":true,"path":"Search/index.html","permalink":"http://yoursite.com/Search/index.html","excerpt":"","text":""}],"posts":[{"title":"golang slice,map 笔记","slug":"golang-slice,map-笔记","date":"2019-01-09T04:44:38.000Z","updated":"2019-01-09T08:02:09.343Z","comments":true,"path":"2019/01/09/golang-slice,map-笔记/","link":"","permalink":"http://yoursite.com/2019/01/09/golang-slice,map-笔记/","excerpt":"","text":"禁止slice之间的比较, 原因如下: slice元素是间接引用,一个slice甚至可以包含自身.虽然有很多方法可以处理这种情形,但是没有一个时简单有效的. 因为slice的元素是间接引用的,一个固定值的slice在不同的时间可能包含不同的元素,因为底层数组的元素可能会被修改。针对slice的浅相等==(即判断是否引用相同的对象)可能有点卵用,也能临时解决map中key的问题,但是与数组不同的相等测试会让我很困惑. 所以要禁止slice之间的比较. 不可对map中的value进行取址操作, 因为map可能通过元素数量的增长而重新分配内存,导致之前的地址无效.","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"数据结构","slug":"数据结构","date":"2019-01-03T12:44:04.000Z","updated":"2019-01-03T14:11:12.481Z","comments":true,"path":"2019/01/03/数据结构/","link":"","permalink":"http://yoursite.com/2019/01/03/数据结构/","excerpt":"","text":"（一）绪论数据结构的基本概念，数据的逻辑结构、存储结构；逻辑结构: 线性结构 非线性结构 树 图 集合 存储结构 顺序存储 链接存储 索引存储 在存储的同时,还建立附加的索引表 散列存储 算法的定义和应具有的特性，算法设计的要求，算法的时间复杂度分析和算法的空间复杂度分析。（二）线性表线性结构的特点、线性表的定义，线性表的基本操作；list定义 线性表的顺序存储结构是一种随机存取的存储结构,线性表的链式存储结构是一种顺序存取的存储结构. 线性表的顺序存储结构，对其进行检索、插入和删除等操作；线性表的链式存储结构，单链表、双向链表和循环链表这三种链表形式的存储结构和特点以及基本操作。（三）栈和队列，递归算法栈的定义、结构特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法；队列的结构、特点及其存储方式(顺序存储与链接存储)和基本操作的实现算法。循环队列实现 1234567891011// 初始化Q.rear=Q.front=0;// 判断空Q.rear==Q.front;// 判断队满(Q.rear+1)%MAXSIZE==Q.front;// 队列长度(Q.rear+MAXSIZE-Q.front)%MAXSIZE; 递归的基本概念和实现原理以及用递归的思想描述问题和书写算法的方法；用栈实现递归问题的非递归解法。（四）数组和串串的基本概念、串的存储结构和相关的操作算法；数组的存储结构，在顺序存储的情况下，数组元素与存储单元的对应关系；稀疏矩阵的存储结构和特点以及基本操作。对于矩阵中实际存储的元素&lt;&lt;矩阵大小时,可以只存取三元组(行标,列标,值)的list. 字符串匹配算法(例如KMP算法)。（五）树和森林树的结构和主要概念，各种二叉树的结构及其特点；树的基本术语 度 树中一个节点的子节点个数称为该节点的度,树中最大度数称为树的度 深度 从根节点开始自顶向下逐层累加 高度 从叶节点开始自底向上逐层累加 树的高度(深度) 树中节点最大的层数 二叉树的特点N0表示叶子节点数,N2表示度为2的节点则N0=N2+1 故在有N个节点的二叉树中,有N+1个空指针;空指针数 = 2*N0+N1=N0+N1+N2+1 二叉树的数组表示方法If a complete binary tree with n nodes is represented sequentially, then for any node with index i, $1 \\leq i \\leq n$, we have parent(i) is at int(i/2) if $i \\neq 1$. If i = 1, i is at the root and has no parent. LeftChild(i) is at 2i if $2i \\leq n$. If $2i \\geq n$, then i has no left child. RightChild(i) is at 2i+1 if $2i+1 \\leq n$. If $2i+1 \\geq n$, then i has no right child. 二叉树与度为2的树的区别 度为2的树至少含有三个节点才可以,二叉树则可为空 度为2的树如果某个节点只有一个孩子节点则无需分左右,而二叉树不同 各种二叉树 满二叉树 叶子节点都在二叉树的最下一层,并且除叶节点之外的每个节点的度数都为2 完全二叉树 每个节点都与高度一样的满二叉树编号一一对应.也就是只有最下一层的右边可以缺少元素. 平衡二叉树 树上任意节点的左子树和右子树的深度之差不超过1 二叉树的三种遍历方法的实现原理和性质，能将二叉树的遍历方法应用于求解二叉树的叶子结点个数、二叉树计数等问题，遍历的非递归实现方法；遍历方法 先序遍历(PreOrder) 顺序:根节点,先序遍历左子树,先序遍历右子树 实现: 递归实现 非递归实现 123456789101112131415void PreOrder2(BiTree t)&#123; InitStack(S); BiTree p = t; while(p||!IsEmpty(S))&#123; if(p)&#123; visit(p); Push(S,p); p = p-&gt;lchild; &#125; else&#123; Pop(S,p); p=p-&gt;rchild; &#125; &#125;&#125; 中序遍历(InOrder) 顺序:中序遍历左子树,根节点,中序遍历右子树 实现: 递归实现 非递归实现 123456789101112131415void InOrder2(BiTree t)&#123; InitStack(S); BiTree p = t; while(p||!IsEmpty(S))&#123; if(p)&#123; Push(S,p); p = p-&gt;lchild; &#125; else&#123; Pop(S,p); visit(p); p=p-&gt;rchild; &#125; &#125;&#125; 后序遍历(PostOrder) 顺序:后序遍历左子树,后序遍历右子树,根节点 实现: 递归实现 非递归实现: 1234567891011121314151617181920212223242526void PostOrder(BiTree T)&#123; InitStack(S); BiTree p = T; BiTree r = NULL: while(p||!IsEmpty(S))&#123; if(p)&#123; push(S,p); p = p-&gt;lchild; &#125; else&#123; GetTop(S,p); if(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123; p=p-&gt;rchild; push(S,p); p=p-&gt;lchild; &#125; else&#123; pop(S,p); visit(p-&gt;data); r=p; p=NULL; &#125; &#125; &#125;&#125;` 根据先序遍历和中序遍历或后序遍历和中序遍历可以确定一颗二叉树,而先序和后序则不能确定一颗二叉树 层次遍历123456789101112131415void LevelOrder(BiTree T)&#123; InitQueue(Q); BiTree p; EnQueue(Q,T); while (!IsEmpty(Q))&#123; Dequeue(Q,p); visit(p); if(p-&gt;lchild!=NULL)&#123; EnQueue(Q,p-&gt;lchild); &#125; if(p-&gt;rchild!=NULL)&#123; EnQueue(Q,p-&gt;rchild); &#125; &#125;&#125; 计算树的深度12345678910111213int BitDepth(BiTree T)&#123; if (T==NULL) return 0; else&#123; ldep = Btdepth(T-&gt;lchild); rdep = Btdepth(T-&gt;rchild); if(ldep&gt;rdep) return ldep+1; else return rdep+1; &#125;&#125; 线索化二叉树的结构和基本操作；格式: ltag lchild data rchild rtag 1:指向节点的前驱 1:指向节点的后继 中序线索二叉树示例 森林的定义和存储结构，森林的遍历等方法的实现；森林存储结构 双亲表示法 孩子表示法 孩子兄弟表示法 森林=&gt;二叉树用孩子兄弟表示法将树=&gt;二叉树(由于根节点没有兄弟所以没有右子树)=&gt;将森林的多颗树连在一起 例: 森林遍历方法树和森林遍历与二叉树遍历的对应关系 树 森林 二叉树(将森林或树转换成的二叉树) 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 基于霍夫曼树生成霍夫曼编码的方法； 13+9=22 AVL树的定义和特点以及AVL树调整操作的实现原理；AVL树的定义节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。 调整操作 LR型 LL型 RR型 RL型 最优二叉树的构造原理和相关算法。123456789101112131415161718192021222324252627282930treenode *huffmanTree(int n) &#123; //n为叶子个数 int index = 0; for (int i = 0; i &lt; n; ++i) &#123; //将每一个叶子节点建成一棵树，放入数组tree[]中 treenode *p = new treenode; p-&gt;data = arr[i]; //arr[]中放着叶子节点的权值 p-&gt;lch = NULL; p-&gt;rch = NULL; tree[index++] = p; &#125; treenode *root = NULL; //定义最优二叉树的根 for (int i = 0; i &lt; n - 1; ++i) &#123; //每次取arr[]中未使用的最小两个值 sort(arr + i, arr + n); treenode *ch1 = NULL, *ch2 = NULL; for (int j = 0; j &lt; index; ++j) &#123;//在数组tree[]中找到这两个值，建立新的节点 if(tree[j]-&gt;data == arr[i]) ch1 = tree[j]; if(tree[j]-&gt;data == arr[i + 1]) ch2 = tree[j]; if(ch1 &amp;&amp; ch2) break; &#125; treenode *p = new treenode;//建立新的节点，存入数组tree[]中 p-&gt;data = ch1-&gt;data + ch2-&gt;data; p-&gt;lch = ch1; p-&gt;rch = ch2; root = p;//更新根，直到建立完成 tree[index++] = p; arr[i + 1] = p-&gt;data;//并将这个节点的权值传入数组arr[]中 &#125; return root;&#125; （六）图图的各种基本概念和各种存储方式；图的基本概念 有向图 表示法: V(G3)={0,1,2} E(G3)={&lt;0,1&gt;,&lt;1,0&gt;,&lt;1,2&gt;} 强连通: 节点v到w和w到v都有路径 强连通分量: 极大强连通子图 入度,出度: 入度和=出度和=边数 无向图 表示法 V(G1)={0,1,2,3} E(G1)={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)} 连通: 从v到w的路径存在,则v和w是连通的. 连通图: 图G的任意两个顶点都是连通的. 连通分量: 极大连通子图; 连通图只有一个连通分量; 非连通图有多个连通分量 极大连通子图: 要求连通子图包含其所有的边 极小连通子图: 保持连通又使得边数最少(生成树) 完全图 任意两个顶点都存在边. n个顶点的有向图=&gt;n(n-1)条边 n个顶点的无向图=&gt;n(n-1)/2条边 稀疏图|E|&lt;|V|*log|V|和稠密图 各种存储方式 邻接矩阵法 邻接表法 定义: 12345678910111213141516171819202122＃define MaxVerNum 100 /*最大顶点数为100*/// 邻接表类型 ：typedef struct ArcNode&#123; int adjvex; /*邻接点域*/ InfoType *Info; /*表示边上信息的域info*/ struct ArcNode * next; /*指向下一个邻接点的指针域*/&#125; ArcNode ; // 表头结点类型 ：typedef struct Vnode&#123; VertexType vertex; /*顶点域*/ ArcNode * firstedge; /*边表头指针*/&#125; Vnode, AdjList [MaxVertexNum]; // 图的类型 ： typedef struct&#123; AdjList vertices; /*邻接表*/ int vexnum, arcnum; /*顶点数和边数*/&#125; ALGraph; /*ALGraph是以邻接表方式存储的图类型*/ 图的两种搜索方法和图连的连通性；图的两种搜索方法 两个基本函数 12345678910111213141516171819202122int FirstAdjVex(ALGraph G, int v)&#123; // 返回G中第v个顶点的第1个邻接点的序号。如果v无邻接点，返回0。 if(!G.vertices[v].firstarc) return(0); else return(G.vertices[v].firstarc-&gt;adjvex);&#125;int NextAdjVex(ALGraph G, int v, int w)&#123; // 返回G中第v个顶点的相对于顶点w的下一个邻接点的序号。 // 如果v无相对于顶点w的下一个邻接点，返回0。 ArcNode *p; p=G.vetrices[v].firstarc; while( p &amp;&amp; p-&gt;adjvex!=w) p=p-&gt;nextarc; if(p-&gt;adjvex==w &amp;&amp; p-&gt;nextarc) return(p-&gt;nextarc-&gt;adjvex); else return(0);&#125; DFS(深度优先) 123456789101112131415161718void DFSTraverse( Graph G ) &#123; bool visited[MAX] ; //用于标识结点是否已被访问过 for ( k=1; k&lt;=G.vexnum; ++k ) visited[k] = FALSE; for ( k=1; k&lt;=G.vexnum; ++k ) if ( !visited[ k ] ) DFS(G, k);&#125;void DFS( Graph G, int v )&#123; visited[v] = TRUE; VISIT( v ); // 访问图G中第v个顶点 for (w=FirstAdjVex(G, v); w&gt;0; w=NextAdjVex(G, v, w)) if ( !visited[ w ] ) DFS(G, w);&#125; BFS(广度优先) 12345678910111213141516171819202122232425void BFSTraverse( Graph G ) &#123; bool visited[MAX] ; //用于标识结点是否已被访问过 for (v=1; v&lt;=G.vexnum; ++v) visited[v] = FALSE; InitQueue(Q); for(v=1; v&lt;=G.vexnum; ++v) if ( !visited[v] ) &#123; visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) &#123; DeQueue(Q,u); for(w=FirstAdjVex(G, u); w&gt;0; w=NextAdjVex(G, u, w)) if( !visited[w] ) &#123; visited[w]=TRUE; VISIT(w); EnQueue(Q, w); &#125; &#125; // end while &#125; // end if&#125; 两种最小生成树的生成方法； Prim 算法 Kruskal 算法 各种求最短路径的方法； Dijkstra 算法 Floyed 算法 用顶点表示活动和用边表示活动的两种网络结构特点和相关操作的实现算法。 AOV-Network (Activity on Vertex) 顶点表示活动,边&lt;v1,v2&gt;表示活动v1先于活动v2,必须是有向无环图.(依赖关系) 拓扑排序: 1. 从图中选择一个没有前驱的节点并输出 2. 从图中删除该节点和以它为起点的有向边 3. 重复步骤1,2 AOE-Network (Activity on Edge) 顶点表示事件,有向边表示活动,边上的权重表示完成该活动的开销.(软件项目安排) 关键路径: 从起点到终点的所有路径中,具有最大的路径长度的路径 1. 求AOE中所有事件的最早发生时间ve():从前往后计算 2. 求AOE中所有事件的最晚发生时间vl():从后往前计算 3. 求AOE中所有活动的最早开始时间e():边的起点的顶点的最早发生时间 4. 求AOE中所有活动的最晚开始时间l():边的终点的顶点的最晚发生时间-边的权重 5. 求AOE中所有活动的差额d(),找出d()=0构成关键路径 （七）排序插入排序法(含折半插入排序法)、选择排序法、冒泡排序法、快速排序法、堆积排序法、归并排序、基数排序等排序方法排序的原理、规律和特点； 插入排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 直接插入排序void InsertSort(int a[], int length)&#123; /* * 插入排序 * 从头开始保证走过的路有序,每加入一个元素就将其插入到正确的位置 */ int j,i; for(i=2;i&lt;length;i++)&#123; if (a[i]&lt;a[i-1])&#123; a[0] = a[i]; for(j=i-1;a[0]&lt;a[j]; j--) a[j+1] = a[j]; a[j+1] = a[0]; &#125; &#125;&#125;// 折半插入排序void InsertSort(ElemType A[], int n)&#123; int i,j,low,high,mid; for(i=2;i&lt;=n;i++)&#123; A[0]=A[i]; low=1; high=i-1; while(low&lt;=high)&#123; mid=(low+high)/2 if(A[mid].key&gt;A[0].key) high = mid-1; // 查找左半子树 else low=mid+1 // 查找右半子树 &#125; for(j=i-1;j&gt;=high+1;--j) A[j+1]=A[j]; A[high+1]=A[0]; &#125;&#125;// 希尔排序void ShellSort(SqList &amp;L,int dlta[],int t)&#123; // 按增量序列dlta[0..t-1]对顺序表L作希尔排序。算法.5 int k; for(k=0;k&lt;t;++k)&#123; ShellInsert(L,dlta[k]); // 一趟增量为dlta[k]的插入排序 printf(\"第%d趟排序结果: \",k+1); print(L); &#125;&#125;void ShellInsert(SqList &amp;L,int dk)&#123; // 对顺序表L作一趟希尔插入排//序。本算法是和一趟直接插入排序相比， // 作了以下修改： // 1.前后记录位置的增量是dk，而不是1; // 2.r[0]只是暂存单元，不是哨兵。当j&lt;=0时，插入位置已找到。 int i,j; for(i=dk+1;i&lt;=L.length;++i)&#123; if LT(L.r[i].key,L.r[i-dk].key)&#123; // 需将L.r[i]插入有序增量子表 L.r[0]=L.r[i]; // 暂存在L.r[0] for(j=i-dk;j&gt;0&amp;&amp;LT(L.r[0].key,L.r[j].key);j-=dk) L.r[j+dk]=L.r[j]; // 记录后移，查找插入位置 L.r[j+dk]=L.r[0]; // 插入 &#125; &#125;&#125; 选择排序 1234567891011void SelectSort(ElemType A[], int n)&#123; for (i=0;i&lt;n-1;i++)&#123; int min = i; for(j=i+1; j&lt;n; j++)&#123; if(A[j]&lt;A[min]) min = j; &#125; if (min!=i) swap(A[i], A[min]); &#125;&#125; 冒泡排序 123456789101112131415void bubble_sort(int a[],int n) &#123; // 将a中整数序列重新排列成自小至大有序的整数序列(起泡排序) int i,j,t; Status change = TRUE; for(i=n-1;i&gt;1&amp;&amp;change;--i)&#123; change=FALSE; for(j=0;j&lt;i;++j) if(a[j]&gt;a[j+1])&#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; change=TRUE; &#125; &#125;&#125; 快速排序 123456789101112131415161718192021void QuickSort(int a[], int low, int high)&#123; if (low&lt;high)&#123; int mid = partition(a, low,high); QuickSort(a, low, mid-1); QuickSort(a, mid+1, high); &#125;&#125;int partition(int a[],int low,int high)&#123; int pivot = a[low]; while(low&lt;high)&#123; while(a[high]&gt;=pivot &amp;&amp; low&lt;high) high--; a[low] = a[high]; while(a[low]&lt;=pivot &amp;&amp; low&lt;high) low++; a[high] = a[low]; &#125; a[low] = pivot; return low;&#125; 堆排序 算法步骤: 构造初始堆 假设给定无序序列结构如下 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。 找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6 调整堆 将堆顶元素9和末尾元素4进行交换 重新调整结构，使其继续满足堆定义 再将堆顶元素8与末尾元素5进行交换，得到第二大元素8. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 https://www.cnblogs.com/chengxiao/p/6129630.html 12345678910111213141516171819202122232425262728void AdjustDown(int a[], int k, int len)&#123; a[0] = a[k]; for (int i=k*2; i&lt;=len; i*=2)&#123; if(i&lt;len&amp;&amp;a[i]&lt;a[i+1]) i++; if(a[0]&gt;=a[i]) break; else&#123; a[k] = a[i]; k=i; &#125; &#125; a[k] = a[0];&#125;void HeapSort(int a[], int length)&#123; // build max heap for (int i=length/2; i&gt;0; i--) AdjustDown(a, i, length); for (int i=length;i&gt;1; i--)&#123; int t=a[1]; a[1] = a[i]; a[i] = t; AdjustDown(a,1, i-1); &#125;&#125; 归并排序 123456789101112131415161718192021222324252627282930void merge(int a[], int low, int mid, int high, int b[])&#123; for(int i=low; i&lt;=high; i++) b[i] = a[i]; int l,h,k; for (k=low,l=low,h=mid+1; l&lt;=mid&amp;&amp;h&lt;=high;k++)&#123; if(b[l]&lt;=b[h]) a[k] = b[l++]; else a[k] = b[h++]; &#125; while(l&lt;=mid) a[k++]=b[l++]; while(h&lt;=high) a[k++]=b[h++];&#125;void MergeSort(int a[], int low, int high, int b[])&#123; if (low&lt;high)&#123; int mid = (low+high)/2; MergeSort(a, low, mid,b); MergeSort(a,mid+1, high, b); merge(a, low, mid , high, b); &#125;&#125;void MergeSort(int a[], int len)&#123; int *b = new int[len]; MergeSort(a, 1, len, b); delete []b;&#125; 基数排序 将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 时间复杂度:O(d(n+r)) 其中d:d趟分配与收集;一趟分配:O(n);一趟收集:O(r) 各种排序算法的时空复杂度的简单分析。 排序名称 类别 稳定性 时间复杂度 空间复杂度 最少比较次数 最多比较次数 最少移动次数 最多移动次数 插入排序 插入排序 稳定 O(n2) O(1) n-1 (n+2)(n-1)/2 0 (n+4)(n-1)/2 希尔排序 插入排序 不稳定 O(n1.5) o(1) / / / / 冒泡排序 交换排序 稳定 O(n2) o(1) n-1 n(n-1)/2 0 n(n-1)/2 快速排序 交换排序 不稳定 O(n*log2n) o(log2n) O(n*log2n) n(n-1)/2 O(n*log2n) / / 选择排序 选择排序 不稳定 O(n2) O(1) n-1 n(n-1)/2 0 3(n-1) 堆排序 选择排序 不稳定 O(n*log2n) O(1) O(n*log2n) O(n*log2n) / / 归并排序 归并排序 稳定 O(n*log2n) O(n) O(n*log2n) O(n*log2n) / / 基数排序 基数排序 稳定 O(d(n+rd)) O(rd) 0 0 0 0 排序名称 平均情况 最好情况 最坏情况 直接插入排序 O(n2) O(n) o(n2) 希尔排序 O(n1.5) 冒泡排序 O(n2) O(n) O(n2) 快速排序 O(n*log2n) O(n*log2n) O(n2) 简单选择排序 O(n2) O(n2) O(n2) 堆排序 O(n*log2n) O(n*log2n) O(n*log2n) 归并排序 O(n*log2n) O(n*log2n) O(n*log2n) 基数排序 O(d(n+rd)) O(d(n+rd)) O(d(n+rd)) （八）索引结构与散列线性索引结构、倒排表、静态搜索树的结构和特点； 线性索引结构 稠密索引 分块索引 倒排索引 正排索引 静态搜索树 查找表中各关键字被查找的概率是不同的 含有 9 个关键字的查找表及其相应权值如下表所示： 求出查找表中所有的 △P 的值，找出整棵查找表的根结点： 例如，关键字 F 的 △P 的计算方式为：从 G 到 I 的权值和 - 从 A 到 E 的权值和 = 4+3+5-1-1-2-5-3 = 0。 通过上图左侧表格得知，根结点为 F，以 F 为分界线，左侧子表为 F 结点的左子树，右侧子表为 F 结点的右子树（如上图右侧所示），继续查找左右子树的根结点: 通过重新分别计算左右两查找子表的 △P 的值，得知左子树的根结点为 D，右子树的根结点为 H （如上图右侧所示），以两结点为分界线，继续判断两根结点的左右子树: 注意：在建立次优查找树的过程中，由于只根据的各关键字的 P 的值进行构建，没有考虑单个关键字的相应权值的大小，有时会出现根结点的权值比孩子结点的权值还小，此时就需要适当调整两者的位置。 http://www.cnblogs.com/ciyeer/p/9067098.html B树的结构m阶: 1&lt;子节点数量&lt;=M ,M&gt;=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）； 插入 (m=5, 每个节点含有[2,4]个value) 插入6 删除 case 1 删除6 case 2 删除3 散列的实现原理和各种操作的实现算法。 Hash 函数 直接地址法 H(key)=a*key+b 适合于关键字分布基本连续 除留余数法 H(key)=key%p 假定散列表长为m,取一个不大于m但接近或等于m的质数P 数字分析法 适用于已知关键字数字集合 平方取中法 取关键字的平方值的中间几位作为散列地址 折叠法 将关键字分割成位数相同的几部分,然后取这几部分的叠加和作为散列地址 冲突处理 开放地址法 递推式: Hi=(H(key) + di) % m di是增量 删除时不能随便物理删除表中已有的元素,若删除将会截断其他具有相同的散列地址的元素的查找地址,所以要进行逻辑删除,打一个标记,定期维护,将删除标记的元素物理删除. 线性探索法 往下一个一个找 平方探索法 当di = 1^2,-1^2,2^2,-2^2,…,k^2,-k^2,其中$k \\leq m/2$, m必须为可以表示成4k+3的质数 可以避免出现堆积的问题,但是不能探测到所有单元 再散列法 di=Hash2(key) 伪随机法 di=伪随机序列 拉链法 往后拉链表 装填因子 a = 表中记录数n/散列表长度m","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"}]},{"title":"操作系统","slug":"操作系统","date":"2019-01-03T12:29:55.000Z","updated":"2019-01-03T14:10:51.848Z","comments":true,"path":"2019/01/03/操作系统/","link":"","permalink":"http://yoursite.com/2019/01/03/操作系统/","excerpt":"","text":"（一）基本概念计算机基本构成、处理器的内部结构、高速缓冲存储器CACHE；计算机的基本构成存储器、控制器、运算器、输入设备、输出设备 处理器的内部结构CPU主要有运算器、控制器、寄存器组合内部总线等部件组成。 cache当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。 操作系统的概念、演变历程、特性、分类、运行环境、功能；操作系统的概念操作系统是一种系统软件 演变历程 手工操作阶段 无操作系统 批处理阶段 单道批处理系统 内存中始终保持一道作业 多道批处理系统 允许多个程序同时计入内存并运行,当某个程序因I/O请求而暂停运行时,CPU转去运行另一道程序 分时操作系统 时间片 实时操作系统 为了再某个时间限制内完成某些紧急任务而不需时间片排队, 主要特点是及时性和可靠性. 硬实时系统 必须绝对地再规定的时刻发生, 如导弹发射系统 软实时系统 允许偶尔违反时间规定, 如飞机订票系统. 特征 并发 宏观上多个程序在运行,通过分时得以实现 共享 系统中的资源可供内存中多个并发执行的进程共同使用 虚拟 异步 可能导致进程产生与时间有关的错误 运行环境功能 时钟管理 计时,通过时钟中断实现进程切换. 中断机制 外中断: 如设备发出I/O结束中断;时钟中断 内中断(异常): 如程序的非法操作码,地址越界… 原语 程序的运行需要原子性,如CPU切换,进程通信等功能中的部分操作. 系统控制的数据结构及处理 进程管理 存储器管理 设备管理 存储器的层次结构。 （二）进程进程的概念和特点；概念为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。 组成: PCB: 保存进程运行期间相关数据,是进程存在的唯一标识 程序段: 能被进程调度程序调度到CPU运行的程序的代码段 数据段: 存储程序运行期间的相关数据 特点 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态的产生、变化和消亡的。动态性是进程最基本的特征。 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与其他进程的程序并发执行，以提高资源利用率。 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。 进程状态转换进程状态 运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。 阻塞状态：又称为等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。及时处理器空闲，该进程也不能运行。 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。 结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要获得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，即使处理器空闲也不能运行。 状态转换 就绪状态=&gt;运行状态: 通过处理器调度,就绪进程得到处理器资源 运行状态=&gt;就绪状态: 时间片用完或有更高优先级的进程进入 运行状态=&gt;阻塞状态: 进程所需要的某一资源还未准备好 阻塞状态=&gt;就绪状态: 进程需要的资源已经准备好 （三）线程、对称多处理SMP和微内核线程的概念，定义线程的必要性和可能性；概念程序执行流的最小单元,由线程ID,程序计数器,寄存器集合和堆栈组成. 必要性进程的切换开销很大,而线程的开销较小.而且线程间通讯效率更高.使系统拥有更好的并发性,提高了系统的吞吐性. 可能性当然可能,废话 线程的功能特性与实现方式；功能特性线程状态 阻塞: 当线程需要等待一个事件,它将被阻塞(保存它的用户寄存器,程序计数器,栈指针),此时处理器执行同一进程中或不同进程的就绪线程 注:程序计数器是用于存放下一条指令所在单元的地址的地方。 解除阻塞 结束 实现方式用户级线程&amp;内核级线程 用户级线程(多对一) 优点: 效率比较高 缺点: 当一个线程在使用内核服务时被阻塞了,那么整个进程都会被阻塞 内核级线程(一对一) 优点: 当一个线程在被阻塞时,完全不慌 缺点: 效率低 多对多模型: 将n个用户级线程映射到m个内核级线程上,要求m小于等于n 缺点&amp;优点: 集大成者 线程vs进程 调度 线程时独立调度的基本单位,进程时拥有资源的基本单位 拥有资源 进程拥有系统资源,线程也有一点必不可少的资源. 并发性 拥有线程的操作系统并发性更好. 系统开销 进程的创建,切换,撤销的效率低于线程 地址空间和其他资源 进程之间的地址空间相互独立 通信资源 进程间的通信(IPC)需要进行进程同步和互斥手段的辅助 对称多处理SMP体系结构；SMP (Symmetric multiprocessing)SMP是一种紧耦合、共享存储的系统模型，特点是多个CPU使用共同的系统总线，因此可访问共同的外设和存储器资源。（所有处理器通过一条高速总线或者一个转换器在同一机器中紧密耦合。处理器共享同样的全局内存、磁盘和 I/0 设备。只有一份操作系统的副本跨所有处理器运行，并且操作系统必须设计为能利用这种体系结构（多线程操作系统）） 对称多处理系统即每个处理器自我调度.在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是核心空间，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。 非对称处理系统让一个处理器(主服务器)处理所有的调度,决定,I/O处理以及其他系统活动,其他的处理器只执行用户代码。这种非对称处理系统 SMP体系结构 并发进程或线程：为了允许多个处理器同时执行相同的内核代码，内核例程必须是可重入的。多处理器执行内核的相同部分和不同部分时，必须正确的管理内核表和管理结构，以避免死锁或非法操作； 调度：调度可以由任何处理器执行，因此必须避免冲突。如果使用内核级多线程，则可能出现同一时刻，多个处理器同时从同一个进程中调度多个线程的情况； 同步：因此存在多个进程都可能访问共享地址空间和共享I/O资源的情况，因此需要提供同步机制。同步是指实施互斥和事件排序的机制。锁是一个通用的同步机制； 存储器管理：多处理器系统为了提高性能，尽可能利用硬件的并行性，如多端口存储器，还必须协调不同处理器上的分页机制，以确保多个处理器共享页或段时页面的一致性问题，以及页替换策略； 可靠性和容错：当一个处理器处理失败时，操作系统应该提供功能衰减能力，重新组织管理表； 操作系统的体系结构（微内核与单内核）及其性能分析。单内核单内核就是把os从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。性能好,Unix系统就是单内核.Linux也是单内核,但它加入了很多高级的东西 微内核微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。各个服务器通信需要IPC机制,模块化安全且省地方.windows等 （四）并发并发性问题及相关概念，如临界区、互斥、信号量和管程等；临界区每个进程有一个代码段称为临界区,在该区的进程可能会改变共同的变量等.重要的特征:当一个进程进入到临界区,其他进程不可以进来. 抢占内核 允许处于内核模式的进程被抢占 非抢占内核 不允许处于内核模式的进程被抢占 互斥(间接制约关系)是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步(直接制约关系)是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。 信号量信号量S是整数变量,除了初始化,它的值表示还可以有几个线程进入临界区,只能通过两个原子操作访问: wait(S)=&gt;P操作 12345wait(S)&#123; while(S&lt;=0) ; S--;&#125; signal(S)=&gt;V操作 123signal(S)&#123; S++;&#125; 二进制的信号量又称为同步锁 上述的信号量的缺点时忙等待,这类型的信号量称为自旋锁(spinlock) 在多处理器的情况下,必须禁止每个处理器的中断. 为了克服忙等待,当一个进程调用wait操作时,发现信号量小于0时,则将自己放入等待队列并阻塞自己,当调用signal时,通过wakeup操作,将等待队列中的某进程从等待状态=&gt;就绪状态,等系统调度执行. 定义如下: 1234567891011121314151617181920typedef struct&#123; int value; struct process *list; //PCB链表&#125;semaphore;wait(semaphore *S)&#123; S-&gt;value--; if (S-&gt;value&lt;0)&#123; // add this process to list block(); &#125;&#125;signal(S)&#123; S-&gt;value++; if (S-&gt;value &lt;=0 )&#123; remove a process P from list wakeup(P); &#125;&#125; 管程 = 互斥锁 + 条件变量管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。 管程只允许一个进程执行管程中的代码,但是进入管程的线程可以因为条件未满足,放弃继续执行,并被放入条件队列中,等时机成熟再执行 哲学家吃饭例子:哲学家围成一个圈,当哲学家饿了,并且两边的人没有正在吃饭,则可拿起两根筷子吃饭 1234567891011121314151617181920212223242526272829303132monitor dp&#123; enum &#123;thinking, hungry, eating&#125; state[5]; condition self[5]; void pickup(int i) &#123; state[i] = hungry; test(i); if (state[i] != eating) self[i].wait();//P操作 &#125; void putdown(int i) &#123; state[i] = thinking; test( (i+4)%5 ); // important test( (i+1)%5 ); // important &#125; void test(int i) &#123; if ((state[(i+4)%5] != eating) &amp;&amp; (state[i] == hungry) &amp;&amp; (state[(i+1)%5] != eating)) &#123; state[i] = eating; self[i].signal();//V操作 &#125; &#125; void init() &#123; for (int i = 0; i &lt; 5; i++) state[i] = thinking; &#125;&#125; 进程互斥、同步和通信的各种算法； 生产者-消费者问题 1234567891011121314151617181920212223242526272829semaphore mutex = 1;semaphore empty = n;semaphore full = 0;producer()&#123; while(true)&#123; produce an item in nextp; wait(empty) // P操作,empty-- wait(mutex); add nextp to buffer; signal(mutex); signal(full); // V操作,full++ &#125;&#125;consumer()&#123; while(true)&#123; wait(full); wait(mutex); remove an item from buffer; signal(mutex); signal(empty); consumer the item; &#125;&#125; 读者-写者问题: 允许多个读者读,但只允许一个写者写 读者优先 1234567891011121314151617181920212223242526272829int count=0;semaphore mutex=1; //保护countsemaphore rw=1; //保证读者和写者互斥地访问文件writer()&#123; while(true)&#123; wait(rw); writing; singal(rw); &#125;&#125;reader()&#123; while(true)&#123; wait(mutex); if(cout==0) wait(rw); cout++; singal(mutex); reading; wait(mutex); count--; if(count==0) singal(rw); singal(mutex); &#125;&#125; 写者优先(公平算法) 12345678910111213141516171819202122232425262728293031323334int count=0;semaphore mutex=1;semaphore rw=1;semaphore w=1;writer()&#123; while(true)&#123; wait(w); wait(rw); writing; singal(rw); singal(w); &#125;&#125;reader()&#123; while(true)&#123; wait(w); //无写进程时请求进入 wait(mutex); if (count==0) wait(rw); count++; singal(mutex); singal(w); reading; wait(mutex); count--; if (count==0) singal(rw); singal(mutex); &#125;&#125; 死锁的概念、死锁的原因和条件；概念互相等待 死锁的必要条件产生死锁必须同时满足一下四个条件 互斥条件 至少有一个资源处于非共享模式,即一次只能有一个进程使用 非抢占(不可剥夺条件) 资源不能被抢占,即资源只有在进程完成时后才释放. 占有并等待(请求和保持条件) 一个进程必须占有至少一个资源,并等待另一个资源,而该资源为其他进程所占有 循环等待条件 有一组等待进程{p0,p2,…,pn},p0等待的资源被p1占有,p1等待的资源被p2占有,…,pn的资源被p0占有 资源分配图 如果分配图有环,则可能存在死锁 如果每个资源类型刚好有一个实例,那么有环一定死锁 死锁的预防、避免和检测算法。 资源分配策略 各种可能模式 主要优点 主要缺点 死锁预防 保守,宁可资源闲置 一次请求所有资源,资源剥夺,资源按序分配 适用与做突发式处理的进程,不必进行剥夺 效率低;剥夺次数多;不便灵活申请新资源 死锁避免 折中(在运行时判断是否可能死锁) 寻找可能的安全允许顺序 不必进行剥夺 必须知道将来的资源需求;进程不能被长时间阻塞 死锁检测|宽松,只要允许就分配资源|定期检查死锁是否已经发生|不延长进程初始化事件,允许堆死锁进行现场处理|通过剥夺解除死锁,造成损失| 死锁的预防破坏死锁的四个必要条件之一 破坏互斥条件 如果允许所有资源都可以共享使用即可. 破坏非抢占 当某个进程已经拥有某互斥资源,再去请求新资源不被满总时,应释放已拥有的资源. 缺点: 释放已获得的资源可能导致前一段的工作失效,反复的申请和释放资源会增加系统开销,降低系统吞吐量,所以这种方法适用于易于保存和恢复的资源. 破坏占有并等待 采用预先静态分配方式,即进程再运行前,一次申请完它所需要的全部资源. 缺点: 系统资源被严重浪费,而且还会导致饥饿. 破坏循环等待 采用顺序资源分配法,首先给系统的资源编号,规定每个进程必须按照编号递增的顺序请求资源. 缺点: 编号必须相对稳定,限制了新类型设备的增加.会发生作业使用资源的顺序于系统规定顺序不同的情况;给用户变成带来麻烦. 死锁的避免在资源动态分配过程中防止系统进入不安全的状态. 系统安全状态 对于进程顺序&lt;p1,p2..pn&gt;, pi还需要的资源数 &lt; 系统还剩资源数+所有在他前边的p所拥有的资源数,有次序列系统就处于安全状态. 假设系统中有三个进程P1、P2和P3,共有12 台磁带机。进程P1总共需要10台磁带机，P2和P3 分别需要4台和9台。假设在T0时刻，进程P1、P2 和P3已分别获得5合、2台和2台，尚有3台未分配，见下表 进程|最大需求|已分配|可用 |:—:|:—:|:—:|:—:| |P1|10|5|3 P2|4|2 P3|9|2 存在一个安全序列\\，即只要系统按此进程序列分配资源，则每个进程都能顺利完成,此时系统便是安全状态. 如果此时分配1个磁带机给p3,此时就处于不安全状态了. 资源分配图法(每个资源的实例只有一个) 只有在申请边变成分配边而不会导致资源成环时,才允许分配,如下图 当p2申请r2时,虽然r2空缺,但是不能分配给他,如果分配了就成环了. 另外检测图中是否有环的算法需要n^2级操作,其中n是进程个数 银行家算法 当用户进程首次申请资源时,要确定该进程的资源最大需求量,如果系统现存的资源满足它最大需求量则按当前的申请量分配资源; 进程在执行中申请资源时,先验证它所占用的资源和此次申请资源数有没有超过最大需求量(也就是有没有守诚信),然后再验证系统的现存资源数是否能满足该进程尚需的最大资源数. 银行家算法的数据结构 可利用资源向量Available 是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max 这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation 这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。 需求矩阵Need。 这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。 Need[i,j]=Max[i,j] - Allocation[i,j] 算法过程: 银行家算法 设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： 如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 如果Request i[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。 系统试探着把资源分配给进程P i，并修改下面数据结构中的数值： Available[j]:= Available[j]-Request i[j]； Allocation[i,j]:= Allocation[i,j]+Request i[j]； Need[i,j]:= Need[i,j]-Request i[j]； 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性检测算法 设置两个向量： 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work:=Available。 Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false；当有足够资源分配给进程时，再令Finish[i]:=true。 从进程集合中找到一个能满足下述条件的进程： Finish[i]=false； Need[i,j]≤Work[j]；若找到，执行步骤(3)，否则，执行步骤(4)。 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:= Work[j]+Allocation[i,j]； Finish[i]:=true； go to step （2）; 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 示例 假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图示。 （先忽略P1第二行的括号） T0时刻的安全性：利用安全性算法对T0时刻的资源分配情况进行分析如下图可知，在T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。 P1请求资源：P1发出请求向量Request1(1，0，2)，系统按银行家算法进行检查： Request1(1，0，2)≤Need1(1，2，2) Request1(1，0，2)≤Available1(3，3，2) 系统先假定可为P1分配资源，并修改Available，Allocation1和Need1向量，形成的资源变化情况如下图圆括号所示 再利用安全性算法检查此时系统是否安全。如图所示。 P4请求资源：P4发出请求向量Request4(3，3，0)，系统按银行家算法进行检查： Request4(3，3，0)≤Need4(4，3，1)； Request4(3，3，0)≥Available(2，3，0)，让P4等待。（附：操作系统第三版这里写成了≤符号，需更正） P0请求资源：P0发出请求向量Requst0(0，2，0)，系统按银行家算法进行检查： Request0(0，2，0)≤Need0(7，4，3)； Request0(0，2，0)≤Available(2，3，0)； 系统暂时先假定可为P0分配资源，并修改有关数据，如图所示。 进行安全性检查：可用资源Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 https://blog.csdn.net/cout_sev/article/details/24980627 死锁的检测 每种资源都只有单个实例 创建等待图,如果等待图成环就代表发生了死锁 多个实例的死锁检测 数据结构 示例 此时系统不处于死锁状态,因为存在 p0,p2,p3,p1,p4 假如p2 又请求了资源C的实例 此时就发生了死锁 死锁解除 一旦检测出死锁,应立即采取相应的措施,如: 资源剥夺法 挂起某些死锁进程,并抢占其资源,给其他的死锁进程 撤销进程法 强制撤销部分或者全部死锁进程并剥夺这些进程的资源.撤销的原则可以按优先级和撤销代价. 进程回退法 让一个或多个进程回退到足以回避死锁的地步,进程回退时是资源释放资源而不是被剥夺.要求系统保持进程的历史信息,设置还原点. （五）存储器管理分区存储管理、覆盖与交换；基地址寄存器在这里称为重定位寄存器。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。例如，如果基地址为14000，那么用户对位置346的访问将动态地重定位为位置14346。 工作集和驻留集 驻留集是进程当前分配到物理页框中的所有页构成的集合，它受操作系统的页分配策略和内存可用状态的影响。进程分配的主存空间. 工作集是研究进程执行过程中访问页的规律的理论模型中的一个概念，是指进程在其过去的 t 个虚拟执行时间中访问的页的集合。在某个时间间隔内,进程要访问的页面集合. 连续分配方式为一个用户程序分配一个连续的内存空间. 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 单一连续分配 这是最简单的一种存储管理方式,但只能用于单用户、单任务的操作系统中。采用这种存储管理方式时,可把内存分为系统区和用户区两部分,系统区仅提供给 OS 使用,通常是放在内存的低址部分;用户区是指除系统区以外的全部内存空间,提供给用户使用。 固定分区分配 固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空间划分为若干个固定大小的区域,在每个分区中只装入一道作业,这样,把用户空间划分为几个分区,便允许有几道作业并发运行。当有一空闲分区时,便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区,当该作业结束时,又可再从后备作业队列中找出另一作业调入该分区。 固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。 优点：易于实现，开销小。 缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区分配 动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区 最先适配法(first-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 覆盖一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 覆盖的实现方式有两种：以函数库方式实现或操作系统支持。 交换暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 交换技术优点之一是增加并发运行的程序数目，并给用户提供适当的响应时间；与覆盖技术相比交换技术另一个显著的优点是不影响程序结构。交换技术本身也存在着不足，例如：对换人和换出的控制增加处理器开销；程序整个地址空间都进行对换，没有考虑执行过程中地址访问的统计特性。 覆盖与交换比较 与覆盖技术相比，交换不要求程序员给出程序段之间的覆盖结构。 交换主要是在进程与作业之间进行，而覆盖则主要在同一作业或进程内进行。 另外覆盖只能覆盖那些与覆盖程序段无关的程序段。 页式管理及段式管理；页式管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 页式管理方式的优点是： 没有外碎片，每个内碎片不超过页大小比前面所讨论的几种管理方式的最大进步是: 一个程序不必连续存放。 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行。 段式管理在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等 每个段都有自己的名字。为了实现简单起见,通常可用一个段号来代替段名,每个段都从 0开始编址,并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定,因而各段长度不等。整个作业的地址空间由于是分成多个段,因而是二维的,亦即,其逻辑地址由段号(段名)和段内地址所组成。 页式和段式区别 需求: 页是信息的物理单位,分页是为实现离散分配方式,以消减内存的外零头,提高内存的利用率。或者说,分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 大小: 页的大小固定且由系统决定,由系统把逻辑地址划分为页号和页内地址两部分,是由机器硬件实现的,因而在系统中只能有一种大小的页面;而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时,根据信息的性质来划分。 逻辑地址: 分页的作业地址空间是一维的,即单一的线性地址空间,程序员只需利用一个记忆符,即可表示一个地址;而分段的作业地址空间则是二维的,程序员在标识一个地址时,既需给出段名,又需给出段内地址。 段、页式存储管理方法及实现技术；页式存储进程页表：完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射。 基本地址变换 在系统中设置一个页表寄存器(PTR),存放页表在内存的开始地址F和页表长度M.设页面大小为L,逻辑地址A到物理地址的变换过程如下(十进制) 计算页号P=A/L,页内偏移W=A%L 比较页号P和页表长度M,若P&gt;=M则产生越界中断 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度,取出该页表项内的内容b,即为物理块号(桢号,框号). 计算E=b*L+W得结果 页式管理中地址空间是一维的 页表项的大小设置:以32位逻辑地址空间,字节位编址单位,一页4KB为例,则一共有2^32B/4KB=1M页,则需要log21M = 20位才能保证表示范围能容纳所有页面,又因字节为编址单位,则页表项的大小&gt;=20/8向上去整=3B. 具有快表的地址变换 为了提高地址变换速度,可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器,又称为“联想寄存器”(Associative Memory),或称为“快表”,在 IBM 系统中又取名为 TLB(Translation Lookaside Buffer),用以存放当前访问的那些页表项 在 CPU 给出有效地址后,由地址变换机构自动地将页号 P 送入高速缓冲寄存器,并将此页号与高速缓存中的所有页号进行比较,若其中有与此相匹配的页号,便表示所要访问的页表项在快表中。于是,可直接从快表中读出该页所对应的物理块号,并送到物理地址寄存器中. 两级页表 32位逻辑地址空间:当页面大小为 4 KB,页表项大小4B，若采用一级页表结构，应具有log(2^32B/4KB)=20位的页号，即页表项最多有2^20*4B=4MB,占4MB/4KB=1024页,需要1024个连续的页来存储页表,很奢侈； 如果不把页表放在连续的空间上,而是建一张索引表,表示某个页表应该去哪里找 为了查询方便,顶级页表只占一页,也就是可以容纳4KB/4B=1K个页表项,也就是1K个二级表的物理块号,且每个二级表只有log(2^32)-log(4KB)-log1K=10位;2^10个页表项 段式存储段式存储更易于信息共享.比说代码段多用户共享. 地址变换 为了实现从进程的逻辑地址到物理地址的变换功能,在系统中设置了段表寄存器,用于存放段表始址和段表长度 TL。在进行地址变换时,系统将逻辑地址中的段号与段表长度TL 进行比较。若 S&gt;TL,表示段号太大,是访问越界,于是产生越界中断信号;若未越界,则根据段表的始址和该段的段号,计算出该段对应段表项的位置,从中读出该段在内存的起始地址,然后,再检查段内地址 d 是否超过该段的段长 SL。若超过,即 d&gt;SL,同样发出越界中断信号;若未越界,则将该段的基址 d 与段内地址相加,即可得到要访问的内存物理地址。 段页式存储管理方式段页式系统的基本原理,是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。 在段页式系统中,为了便于实现地址变换,须配置一个段表寄存器,其中存放段表始址和段表长 TL。进行地址变换时,首先利用段号 S,将它与段表长 TL 进行比较。若 S&lt;TL,表示未越界,于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置,从中得到该段的页表始址,并利用逻辑地址中的段内页号 P 来获得对应页的页表项位置,从中读出该页所在的物理块号 b,再利用块号 b 和页内地址来构成物理地址。 https://blog.csdn.net/hguisu/article/details/5713164 虚存的原理及相关的各种算法和数据结构。虚存的概念 传统的存储管理方式的特征 一次性: 作业必须一次性全部装入内存,才能运行 驻留性: 作业装入内存后,就一直驻留字内存中.直到运行结束 虚存的定义和特征 是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储器系统。 多次性: 无需在作业运行时一次性地全部装入内存. 对换性: 允许作业在运行过程中,进行换进换出 虚拟性: 从逻辑上扩充内存的容量 一定要有一下几个方面 一定的内存和外存 页表机制 缺页中断机构 地址变换机构(MMU) 页面置换算法 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1, 2. 先进先出(FIFO)算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。基于队列实现 Belady异常: 当物理块数增加而缺页发生的次数反而更多的异常情况.只有FIFO会出现. 最久未使用(LRU)置换算法 选择最长时间未访问过的页面予以淘汰.堆栈类算法 时钟(CLOCK)置换算法,又称最近未用算法(NRU) 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间 优先级: u=0,m=0&gt;u=0,m=1 页面分配策略给特定的进程分配多大的主存空间 固定分配局部置换: 每个进程都固定数目的物理块,缺页就和自己换 可变分配全局置换: 先给每个进程分配固定的物理块,缺页了就全局找一个空闲页分配 可变分配局部置换: 如果频繁缺页则给他加点,很少缺页则给他减点. （六）单处理器调度处理器的三种调度类型； 作业调度(高级调度) 从外存的后备队列中选择一批作业进入内存，为他们建立进程。这些进程被送入就绪队列。频率最低.多道批处理系统才有. 中级调度 将暂时不能运行的进程调至外存等待,为了提高内存利用率和系统吞吐量 进程调度(低级调度) 按照某种方法和策略从就绪队列中选取一个进程执行. 调度算法的分类 抢占和非抢占调度 根据任务运行的过程中能否被中断的情况，把调度算法分为抢占和非抢占两种。在抢占式调度算法中，正在运行的任务可以被其他任务打断。在非抢占式调度算法中，一旦任务开始运行，该任务只有在运行完后而主动放弃CPU资源或者是因为等待其他资源而被阻塞的情况下才可能停止。 静态和动态调度 根据任务优先级确定的时机，把调度算法分为静态调度和动态调度两种。在静态调度算法中，所有任务的优先级在运行之前已经确定下来，这就要求能够完全把握系统中的所有任务及其时间约束（如截止时间，运行时间，优先顺序等）。在动态调度算法中，任务的优先级在在运行时确定，并且可能不断的发生变化。 原文：https://blog.csdn.net/Stephan14/article/details/46468241 进程调度方式 当一个进程从运行状态切换到等待状态(例如,IO请求,调用wait) 当一个进程从运行状态切换到就绪状态(例如,出现中断) 当一个进程从等待状态切换到就绪状态(例如,IO完成时) 当一个进程终止时 当调度只发生在1和4两种情况时,称为非抢断.否则是抢断的. 调度准则 CPU使用率 吞吐量: 单位事件内完成进程的数量 周转时间: 从某个特定的进程的角度看,从进程提交到进程完成的时间段.包括,等待进入内存,在就绪队列中等待,在cpu执行和IO执行 等待时间: 进程在就绪队列中等待所花费时间之和. 响应时间: 在交互系统中,从提交请求到产生第一响应的事件.就是开始响应所需要的时间 进程调度的各种算法及其特点。 先到先服务调度(FCFS:first-come,first-served) 最短作业优先调度(SJF:shortest-job-first)非抢占式 最短剩余事件优先调度(SRTN:shortest-remaining-time-first) 抢占式的SJF 优先级调度（Priority Scheduling）/一般用小数字表示高优先级 缺陷: 叽饿;无穷阻塞,低优先级的无穷等待 解决方法: 老化(aging),逐渐增加系统中等待事件长的进程的优先级 轮转法(Round Robin，RR)专门为分时系统设计 每个就绪进程获得一小段CPU时间（时间片，time quantum），通常10ms - 100ms 时间片用毕，这个进程被迫交出CPU，重新挂回到就绪队列,当然，进程在时间片用毕之前其Burst Cycle结束，也（主动）交出CPU 假设n个就绪进程，时间片q，每个就绪进程得到1/n的CPU时间。任何就绪进程最多等待(n-1)*q单位时间. 轮转法还有一个好处，就是他的响应时间一定优于前面的SJF。因为时间片的存在。 多级队列调度 要求交互的进程，在前台队列。可以批处理的进程，在后台队列。 每个队列都有其自己的调度算法，例如： 前台就绪队列 — RR 后台就绪队列 — FCFS 按优先级分别为： 系统进程队列，要实时响应。 交互进程队列（要求响应非常及时）—— RR 交互编辑队列（人输入键盘，移动鼠标等，响应时间可能半秒也可以，对操作系统来说已经很长了。交互要求不是很高）—— RR 批处理进程队列，不需要交互。—— FCFS CPU怎么在队列间分配？ 固定优先权法。例如，先前台队列，再后台队列。 时间片办法，例如，80%的CPU时间给前台队列，20%CPU时间给后台进程。 多层反馈队列调度 图上三层队列： Q0 — 用RR算法，时间片8ms Q1 — 用RR算法，时间片16ms Q2 — 用FCFS算法。 调度场景 一个就绪进程进入Q0层，当它分配到CPU，可执行8ms。如果它8ms后没有执行完毕，则迁移至Q1层。否则，它离开就绪队列该干嘛干嘛。 在Q1层，当它分配到CPU，可执行16ms。如果它16ms后没有执行完毕，则迁移至Q2层。否则，它离开就绪队列，该干嘛干嘛。 总结 忽略HRRN,Feedback https://www.jianshu.com/p/65360b500ad9 （七）多处理器调度和实时调度多处理器对进程调度的影响； 处理器亲和性 由于使缓存无效或重新构建的代价高,绝大多数SMP系统试图避免将进程从一个处理器移至另一个处理器,而是努力使-个进程在同一个处理器上运行,这被称为处理器亲和性. 当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略,但不能做任何保证时,则会出现软亲和性,有可能在处理器之间移动。,还提供一个支持硬亲和性的系统调用,从而允许进程指定它不允许移至其他处理器上。 负载均衡 多处理器环境下的进程和线程调度算法；CPU调度 全局队列调度 操作系统维护一个全局的任务等待队列。 当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。 这种方法的优点是CPU核心利用率较高。 局部队列调度 操作系统为每个CPU内核维护一个局部的任务等待队列。 当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行。 这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。 目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。 实时进程的特点； 这些进程往往执行非常重要的操作,要求立即响应并执行 只能被更高优先级的实时进程抢占 比普通进程的优先级都要高 限期调度和速率单调调度方法。实时系统的可调度条件: (有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间来处理事件) 速率单调调度（实时静态算法）Rate Monotonic Scheduling，RMS 以用于满足以下条件的进程： 每个周期性进程必须在其周期内完成。 没有进程依赖于任何其他进程。 每一个进程在一次突发中需要相同的CPU时间量。 任何非周期进程都没有最终时限。 进程抢占时刻发生而没有系统开销。（理想模型） 单调速率算法按照以下规则给进程设立优先级：比如A进程每30ms运行一次，则每秒运行33次，则获得优先级33；B进程每秒运行20次，则获得优先级20，所以优先级与速率成线性关系，这就是这个算法的名字的来历。RMS算法是最优的实时静态算法中。 如果 成立,则其可以正常工作 最早最终时限调度（实时动态算法）Earliest Deadline First，EDF 列表按最终时限排序，EDF算法运行列表中的第一个进程，也是具有最近最终时限的进程。当一个新的进程就绪时，系统进行检查以了解其最终时限是否发生在当前运行的进程结束之前。如果是这样，那么新的进程就抢占当前正在运行的进程。 对比 对于RMS来说,前70ms,A以30ms为周期,每秒运行33次故优先级为33,同理得优先级A&gt;B&gt;C(33&gt;25&gt;20),在90ms时,A4的优先级高于B,所以抢占. 对于EDF来说,最终期限就是下一周期的起始时刻.在90ms时A和B的最终期限一样,不进行抢占 由于RMS的优先级只于速率有关,而与进程运行时间无关,所以在40-50ms时选择了执行B导致C未在下个周期开始前执行,导致失败. https://www.cnblogs.com/Philip-Tell-Truth/p/6680529.html （八）设备管理和磁盘调度操作系统中输入/输出功能的组织；I/O控制方式外围设备和内存之间的I/O控制方式: 程序直接控制法 无中断机制,cpu对外设状态进行循环检查 中断驱动方式 I/O控制器收到cpu的一个读命令之后cpu就做其他事情,一旦数据读入,I/O控制器给CPU发送中断信号,表示数据已准备好.然后等待CPU请求该数据. 但由于每个字再存储器与I/O设备之间的传输必须经过cpu,导致了消耗过多的cpu时间 DMA方式 (直接内存访问) 通道控制方式 I/O通道和DMA方式的区别是:DMA方式需要CPU来控制传输的数据块大小,传输的内存位置,而I/O通道方式中这些信息由通道控制.另外,每个DMA控制器对应一台设备与内存传递数据,而一个通道可以控制多台设备与内存的数据交换. 中断处理； 应用进程请求读操作。 设备启动程序（设备驱动程序的上半部分）查询设备控制器的状态寄存器，确定设备是否空闲；如果设备忙，则设备启动程序等待，直到它变为空闲为止。 设备启动程序把输入命令存入设备控制器的命令寄存器中，从而启动设备。 设备启动程序将相应信息写入到设备状态表的设备对应表项中，如最初调用的返回地址，以及I／O操作的一些特定参数等。然后CPU就可以分配给其他进程使用了，因此设备管理器调用进程管理器的调度程序执行，原进程的执行就被暂停了。 经过一段时间设备完成了I／O操作后，设备控制器发出中断请求，中断CPU上运行的进程，从而引起CPU运行中断处理程序。 中断处理程序确定是哪个设备引起的中断，然后转移到该设备对应的设备处理程序（设备驱动程序的下半部分）执行（唤醒设备驱动程序）。 设备处理程序重新从设备状态表中，找到等待I／O操作的状态信息。 设备处理程序拷贝设备控制器的数据寄存器的内容到用户进程的内存区。 设备处理程序返回给应用进程控制权，从而继续运行。 设备驱动程序、设备无关的软件接口和spooling技术；I/O子系统层次结构 用户层I/O软件 实现与用户交互的接口 设备独立性软件 实现用户程序与设备驱动器的统一接口,设备命令,设备保护,设备分配与释放 设备无关软件接口 这类设备无关性软件面向应用层并提供一个统一的应用编程接口(API)，它提供了一组功能函数，应用程序员能够通过调用它们管理设备。这个接口是设备硬件的一个大大简化了的简单抽象的接口，提供的是对具有逻辑性质的逻辑设备上的逻辑操作。由文件系统和设备管理功能接受、翻译、转换为相应的物理设备、物理性质、物理操作。与设备无关的系统软件实现的功能有：设备驱动程序的统一接口，设备命名，设备保护，提供一个与设备无关的逻辑块，缓冲，存储设备的块分配，独占设备的分配和释放，错误处理等。 设备驱动程序 与硬件直接相关,负责具体实现系统对设备放出的操作指令. 主要功能将来自上层软件的与设备无关的的抽象请求转为具体请求，向有关的输入输出设备的各种控制器的寄存器发出控制命令，并监督它们的正确执行，进行必要的错误处理。还要对各种可能的有关设备排队、挂起、唤醒等操作进行处理，执行确定的缓冲区策略等 中断处理程序 用于处理中断相关事项. 硬件 包括一个机械部件和一个电子部件(控制器) spooling 就是把磁盘当做缓冲区. 当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正 立即把打印机分配给该用户进程，而只为它做两件事： 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中.输出进程再为用户进程申请一张空白的用户请求打印表 将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能。 缓冲策略； 单缓冲 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为 C。由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之则为M+C，故可把系统对每一块数据的处理时间表示为Max(C, T)+M. 双缓冲 据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。 I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，与此同时处理机可以从缓冲区1中取出数据放入用户进程处理，当缓冲区1中的数据处理完后，若缓冲区2已填满，则处理机又从缓冲区2中取出数据放入用户进程处理，而I/O设备又可以装填缓冲区1。双缓冲机制提高了处理机和输入设备的并行操作的程度。 处理用时 MAX(C+M,T) 循环缓冲 包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。（类似于循环队列） 循环缓冲用于输入/输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出则正好相反。 缓冲池 由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列： 空缓冲队列 装满输入数据的缓冲队列（输入队列） 装满输出数据的缓沖队列（输出队列）。 还应具有四种缓冲区： 用于收容输入数据的工作缓冲区 用于提取输入数据的工作缓冲区 用于收容输出数据的工作缓冲区 用于提取输出数据的工作缓冲区。 当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。 当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。 当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。 当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。 磁盘调度算法；假设当前磁头在67号，要求访问的磁道号顺序为98,25,63,97,56,51,55,55,6 (电脑随机产生的,设定最外层磁道号为100号) FIFO：先来先服务算法； 假设当前磁道在某一位置，依次处理服务队列里的每一个磁道，这样做的优点是处理起来比较简单，但缺点是磁头移动的距离和平均移动距离会很大。 FIFO算法的服务序列是：98,25,63,97,56,51,55,55,6 磁头移动的总距离distance = (98-67)+(98-25)+(63-25)+(97-63)+(97-56)+(56-51)+(55-51)+(55-55)+(55-6) SSTF： 最短寻道时间算法； 假设当前磁道在某一位置，接下来处理的是距离当前磁道最近的磁道号，处理完成之后再处理离这个磁道号最近的磁道号，直到所有的磁道号都服务完了程序结束. 这样做的优点是性能会优于FIFO算法，但是会产生距离当前磁道较远的磁道号长期得不到服务，也就是“饥饿”现象，因为要求访问的服务的序列号是动态产生的，即各个应用程序可能不断地提出访问不同的磁道号的请求。 SSTF算法的服务序列是: 63,56,55,55,51,25,6,97,98 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97) SCAN：电梯调度算法；(这样命名很形象) 先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描，这里要注意，假设最里层为0号磁道，最里面的一个要求服务的序列是5号，访问完5号之后，就反向了，不需要再往里扫。结合电梯过程更好理解，在电梯往下接人的时候，明知道最下面一层是没有人的，它是不会再往下走的。(LOOK调度才是如此) SCAN算法的服务序列是：63,56,55,55,51,25,6,97,98 磁头移动的总距离distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+(97-6)+(98-97) CSCAN： 循环扫描算法 (C-LOOK) 由于上边的算法在磁头折返回去的时候,会导致很长一段时间可能没有服务.因为最近已经访问过了. 访问完最里面一个要求服务的序列之后，立即回到最外层欲访问磁道。也就是始终保持一个方向。故也称之为单向扫描调度算法。从最里面的一个磁道立即回到最外层欲访问的磁道，这步的距离是两者磁道号差的绝对值。 CSCAN算法的服务序列是：63,56,55,55,51,25,6,98,97 distance = (67-63)+(63-56)+(56-55)+(55-55)+(55-51)+(51-25)+(25-6)+|6-98|+(98-97 FSCAN：分步电梯调度算法(分两个队列) 在扫描的过程中所有新产生的序列放在另外的一个队列中，当访问完当前队列之后，再访问新产生的一个队列。这种算法可以有效防止磁壁粘着现象。 https://blog.csdn.net/Jaster_wisdom/article/details/52345674 磁盘阵列(Redundant Array of Independent Disks) RAID 0 没有冗余 RAID 1 原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件 RAID 2 差错纠正码 每个字节都有相关的奇偶位,存在其他磁盘上,损坏一位的时候可以恢复. RAID 3 交叉奇偶结构 按扇区为单位来计算奇偶值. RAID 4 块交织奇偶结构 按磁盘来计算奇偶值,计算结果存在一个磁盘上 RAID 5 按磁盘来计算奇偶值,结果保存在不同的磁盘上. RAID 6 类似 RAID 5 但是加入了差错纠正码等. （九）文件系统文件系统特点与文件组织方式；文件系统管理文件的软件,被管理的文件及数据结构 文件则是指具有文件名的若干相关元素的集合。元素通常是记录,而记录又是一组有意义的数据项的集合。 文件组织方式 无结构文件(流式文件): 以字节为单位,顺序存储.只能通过穷举搜索方式,来查找文件中的数据 有结构文件(记录式文件) 顺序文件: 记录一个接一个顺序排列 串结构: 记录之间的顺序与关键字无关,由时间决定 顺序结构: 按关键字排序 索引文件: 未变长文件建立索引表,提高查找速度 索引顺序文件: 索引文件与顺序文件相结合 直接文件: 通过hash函数直接决定记录的地址 文件系统的数据结构； 链式文件系统 文件的块是分布在各个零散的空间中，这样对空间的利用率有极大的提升。但是想要放到到某个指定的块就必须从第一个块开始向下寻找，访问的速度较慢。 索引文件系统 为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。 索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。 间接索引表 每个索引表中有15个索引项，前12个索引项对应文件的12个块，他们是文件的直接块。若文件大于12块，就再建立一个新的块索引表，新索引表称为一级间接索引表，表中可容纳256个块地址，这个索引表也会占用一个物理块，老的索引表的第13个索引项就会指向这个索引表所在的物理块。通过一级间接索引表，文件最大可达到 12 + 256 = 268块。 超级块 在文件系统中，一个文件用一个inode表示，所有的inode组成了inode数组，这个inode数组存储在哪里，如何对其进行管理。文件系统中，哪些块被使用了，哪些块是空闲的，这些信息都需要记录，对这些数据进行统一管理和记录的数据结构叫做超级块 目录的基本性质及其实现方法；目录的结构 单级: 所有文件都放在一个目录下 两级: 在目录下分出用户目录 多级: 树形结构 无环图: 在树形结构上加入一些有向边 文件共享 基于索引节点(硬链接): 共享文件指向同一个索引节点,当索引节点的count==0是删除该节点 基于符号链(软链接): 保存共享文件的路径,类似快捷方式 磁盘空间的管理。维护一个空闲空间链表. （十）分布式系统分布式操作系统的类型 网络操作系统 ssh 分布式操作系统 分布式处理的特点、类型； 多层体系结构、中间件技术； 机群系统；分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上 分布式进程管理相关的操作系统设计问题。 透明性: 对于用户来说很多事情无法知道 可伸缩性: 可多可少 可靠性","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"}]},{"title":"Deep Learning学习笔记","slug":"Deep-Learning学习笔记","date":"2018-03-04T02:31:20.000Z","updated":"2019-01-03T14:08:50.662Z","comments":true,"path":"2018/03/04/Deep-Learning学习笔记/","link":"","permalink":"http://yoursite.com/2018/03/04/Deep-Learning学习笔记/","excerpt":"","text":"名词解释泛化(generalization)在先前为观测到的输入上表现的能力,用测试集(test set)来度量泛化误差 正则化(regularization) 解决过拟合问题指我们修改学习算法，使其降低泛化误差而非训练误差。 L1 &amp; L2正则化Dropoutearly stopping超参数不是由学习而来的参数 验证集(validation set)用于挑选超参数的数据子集 Bias&amp;Variance 欠拟合(underfitting)==&gt;high bias 过拟合(overfitting)==&gt;high variance 梯度爆炸&amp;梯度消失参数过大或过小,导致梯度非常大或者梯度为零; ReLU","categories":[],"tags":[{"name":"DL","slug":"DL","permalink":"http://yoursite.com/tags/DL/"}]},{"title":"Linux学习笔记","slug":"Linux学习笔记","date":"2018-02-27T11:32:15.000Z","updated":"2019-01-03T14:10:06.614Z","comments":true,"path":"2018/02/27/Linux学习笔记/","link":"","permalink":"http://yoursite.com/2018/02/27/Linux学习笔记/","excerpt":"","text":"配置文件shell配置文件 系统级 /etc/profile :该文件是用户登录时，操作系统定制用户环境时使用的第一个文件，应用于登录到系统的每一个用户 /etc/bash.bashrc /etc/environment :在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。 用户级 ~/.bashrc ~/.bash_logout:logout时执行login shell 和 nologin shell login shell 载入全部的配置文件 nologin shell 载入不完全 su - username 是login shell;避免用su username. 快捷键及特殊符号快捷键 ^l 清屏 ^p 重复上一条命令 ^d 退出 ^a 将光标移到最前 ^e 将光标移到最后 特殊符号 历史命令 !number :以前的第num条(history表中的num) !-number：重复执行前第number条指令 !string :最近的以string开头的命令 !$ :上一个命令的最后一个参数 !! :上一个命令(sudo !!) ^R :搜索命令 别名功能 alias 查看当前shell别名 unalias 取消别名 命令前加\\屏蔽别名 前台后台 &amp; 挂起后可能会停止 nohub 不会停止 ^c结束前台,","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Python学习笔记","slug":"Python学习笔记","date":"2017-08-08T03:45:20.000Z","updated":"2019-01-03T15:45:48.793Z","comments":true,"path":"2017/08/08/Python学习笔记/","link":"","permalink":"http://yoursite.com/2017/08/08/Python学习笔记/","excerpt":"","text":"函数默认参数: 默认参数必须指向不变对象！(如若可变多次调用会产生不确定的结果) 在调用函数时普通参数和默认参数都可以用: 1fun(参数名=参数值,参数名=参数值....) // 顺序可以调换. 可变参数:12345def fun(*args): // 定义,args is tuple passfun(1,2,3) // 直接传参调用fun(*l) // l is list or tuple 关键字参数:12345def fun(**kw): // 定义,kw is dict pass fun(key_name1=value1,ke_name2=value2)fun(**dic) // dic is dict,传入的参数只是dic的拷贝 命名关键词参数:123456def fun(arg1,*,city,job): passfun(&apos;arg1&apos;,city=&apos;beijing&apos;,job=&apos;无&apos;) // 必须传入参数名,顺序可以调换def fun2(arg1,*args,city,job) // 此时不需要*了,原因可想而知. 参数定义顺序必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 尾递归在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。(Python不优化…) 循环 判断一个对象是否可迭代 12from collections import Iterableisinstance(&apos;abc&apos;, Iterable) # str是否可迭代 迭代索引+value 12for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): print(i, value) 列表生成器 1234l1 = list(range(1, 11))l2 = [x * x for x in range(1, 11)]l3 = [x * x for x in range(1, 11) if x % 2 == 0]l4 = [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] generator 通过算法生成下一个迭代值,省内存. 12g = (x * x for x in range(10)) # 生成generatornext(g) # 通过next函数获取g的下一个元素,当没有元素时会抛出异常 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.每次调用next()函数执行,遇到yield返回,再次执行从上一次yield之后执行. Iterator:可以调用next()的对象成为Iterator对象. 1i = iter([1, 2, 3, 4, 5]) # 取得Iterator对象. 函数式编程 map 12r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # r is Iteratorl = list(r) # 转换为list reduce 效果: 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 应用: 12345from functools import reduce def fn(x, y): return x * 10 + yreduce(fn, [1, 3, 5, 7, 9]) # 生成13579 filter sorted 1sorted([36, 5, -12, 9, -21], key=abs) # abs函数作用于每个元素 闭包:返回函数不要引用任何循环变量，或者后续会发生变化的变量。 123456789101112131415161718def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() #9,9,9 def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs lambda 参数名,参数名 : 表达式返回值 decorator1234567891011121314151617181920212223# 两层调用def log(func): def wrapper(*args, **kw): print(&apos;call %s():&apos; % func.__name__) return func(*args, **kw) return wrapper @log #相当于now = log(now) def now(): print(&apos;2015-3-25&apos;) # 三层调用def log(text): def decorator(func): def wrapper(*args, **kw): print(&apos;%s %s():&apos; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log(&apos;execute&apos;) #相当于now = log(&apos;execute&apos;)(now) def now(): print(&apos;2015-3-25&apos;) 偏函数12import functoolsint2 = functools.partial(int, base=2) # 返回的函数base=2 模块1. 一个py文件就是一个模块. 2. 一个目录里面包含__init__.py,这个目录就是一个包(package). 3. 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； class 实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问. 实的变量名如果以_开头,外部可以访问,但是视为private. 鸭子类型 type() 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue isinstance() 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 测试对象属性和方法 123456789101112131415161718 dir(&apos;ABC&apos;) #获取对象的属性和方法 &gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 &gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404404 __slots__:限制属性 12class Student(object): __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 @property:把一个方法变成属性的调用 12345678910111213class Student(object):@propertydef score(self): return self._score@score.setterdef score(self, value): if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value __XXX__ __len__():调用len()时调用 __str__():类似toString __repr__():为调试服务的toString __iter__():该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值 123456789101112class Fib(object):def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 5. \\_\\_getitem__(n): 1234567891011121314151617181920# 实现切片class Fib(object):def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a, b = b, a + b return L 此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。 6. \\_\\_getattr__(self, attr):当获取属性时没有找到,就调用它. 7. \\_\\_call__():可以实现实例本身调用. 1234567891011# 判断对象是否可以实例调用&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable(&apos;str&apos;)False 枚举类 定义 123from enum import EnumMonth = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;)) 遍历 123for name, member in Month.__members__.items(): print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)# value属性则是自动赋给成员的int常量，默认从1开始计数。 自定义枚举类 1234567891011from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; print(day1 == Weekday(1))True&gt;&gt;&gt; Weekday(7)Traceback (most recent call last):...ValueError: 7 is not a valid Weekday&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, &apos;=&gt;&apos;, member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat type():动态创建类1234567891011&gt;&gt;&gt; def fn(self, name=&apos;world&apos;): # 先定义函数... print(&apos;Hello, %s.&apos; % name)...&gt;&gt;&gt; Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class &apos;type&apos;&gt;&gt;&gt;&gt; print(type(h))&lt;class &apos;__main__.Hello&apos;&gt; 要创建一个class对象，type()函数依次传入3个参数： 1. class的名称； 2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； 3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。 metaclass metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass. 示例: 12345678# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&apos;add&apos;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list, metaclass=ListMetaclass): pass __new__()方法接收到的参数依次是： 1. 当前准备创建的类的对象； 2. 类的名字； 3. 类继承的父类集合； 4. 类的方法集合; 调试 异常处理: 12345678910111213try: print(&apos;try...&apos;) r = 10 / int(&apos;2&apos;) print(&apos;result:&apos;, r)except ValueError as e: print(&apos;ValueError:&apos;, e)except ZeroDivisionError as e: print(&apos;ZeroDivisionError:&apos;, e)else: print(&apos;no error!&apos;)finally: print(&apos;finally...&apos;)print(&apos;END&apos;) assert(启动Python解释器时可以用-O参数来关闭assert): 1234567def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / ndef main(): foo(&apos;0&apos;) unittest 1234567891011121314151617181920212223242526272829303132import unittestfrom mydict import Dictclass TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b=&apos;test&apos;) self.assertEqual(d.a, 1) self.assertEqual(d.b, &apos;test&apos;) self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d[&apos;key&apos;] = &apos;value&apos; self.assertEqual(d.key, &apos;value&apos;) def test_attr(self): d = Dict() d.key = &apos;value&apos; self.assertTrue(&apos;key&apos; in d) self.assertEqual(d[&apos;key&apos;], &apos;value&apos;) def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d[&apos;empty&apos;] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty setUp()和tearDown()方法会分别在每调用一个测试方法的前后分别被执行。 IO 简单示例: 12# 编码和忽略错误f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) StringIO(在内存中读写str): 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&apos;Hello!\\nHi!\\nGoodbye!&apos;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &apos;&apos;:... break... print(s.strip())...Hello!Hi!Goodbye! BytesIO 1234&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;)&gt;&gt;&gt; f.read()b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos; 操作文件和目录 目录 1234567891011121314151617# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)&apos;/Users/michael&apos;# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)&apos;/Users/michael/testdir&apos;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)# 拆分路径&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)# 文件扩展名&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)(&apos;/path/to/file&apos;, &apos;.txt&apos;) 2. 文件 12345678910111213# 对文件重命名:&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)# 删掉文件:&gt;&gt;&gt; os.remove(&apos;test.py&apos;)&apos;&apos;&apos; 制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。&apos;&apos;&apos;# 列出文件&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;][&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;] 序列化 1234567891011121314151617181920# 序列化&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b&apos;\\x80\\x03&#125;q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.&apos;# 保存到文件&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close()# 从文件读取&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;# JSONprint(json.dumps(s, default=lambda obj: obj.__dict__)) # __dict__用来存储实例变量 多进程 linux 123456789import osprint(&apos;Process (%s) start...&apos; % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print(&apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid()))else: print(&apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid)) 通用 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))if __name__==&apos;__main__&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Process(target=run_proc, args=(&apos;test&apos;,)) print(&apos;Child process will start.&apos;) p.start() p.join() print(&apos;Child process end.&apos;) 进程池 12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print(&apos;Run task %s (%s)...&apos; % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))if __name__==&apos;__main__&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print(&apos;Waiting for all subprocesses done...&apos;) p.close() p.join() print(&apos;All subprocesses done.&apos;) 子进程 12345import subprocessprint(&apos;$ nslookup www.python.org&apos;)r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])print(&apos;Exit code:&apos;, r) 多线程 创建线程: 1234567891011121314151617import time, threading# 新线程执行的代码:def loop(): print(&apos;thread %s is running...&apos; % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)) time.sleep(1) print(&apos;thread %s ended.&apos; % threading.current_thread().name)print(&apos;thread %s is running...&apos; % threading.current_thread().name)t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)t.start()t.join()print(&apos;thread %s ended.&apos; % threading.current_thread().name) 互斥锁 12345678910111213balance = 0lock = threading.Lock()def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() Global Interpreter Lock: 任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 ThreadLocal:线程之间传递参数,每个线程都有一副本,互不干扰. 123456789101112131415161718192021import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)t1.start()t2.start()t1.join()t2.join() 常用模块 collections namedtuple 1234567&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2 2. deque 1234567# 双向列表&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])&gt;&gt;&gt; q.append(&apos;x&apos;)&gt;&gt;&gt; q.appendleft(&apos;y&apos;)&gt;&gt;&gt; qdeque([&apos;y&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;]) 3. defaultdict 1234567&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; dd = defaultdict(lambda: &apos;N/A&apos;)&gt;&gt;&gt; dd[&apos;key1&apos;] = &apos;abc&apos;&gt;&gt;&gt; dd[&apos;key1&apos;] # key1存在&apos;abc&apos;&gt;&gt;&gt; dd[&apos;key2&apos;] # key2不存在，返回默认值&apos;N/A&apos; 4. OrderedDict 1234567&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])&gt;&gt;&gt; d # dict的Key是无序的&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2&#125;&gt;&gt;&gt; od = OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])&gt;&gt;&gt; od # OrderedDict的Key是有序的OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)]) # 根据插入顺序 5. Counter 1234567&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter()&gt;&gt;&gt; for ch in &apos;programming&apos;:... c[ch] = c[ch] + 1...&gt;&gt;&gt; cCounter(&#123;&apos;g&apos;: 2, &apos;m&apos;: 2, &apos;r&apos;: 2, &apos;a&apos;: 1, &apos;i&apos;: 1, &apos;o&apos;: 1, &apos;n&apos;: 1, &apos;p&apos;: 1&#125;) base64:将3个字节的二进制编码成四字节对应的字符 12345678910111213&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b&apos;binary\\x00string&apos;)b&apos;YmluYXJ5AHN0cmluZw==&apos;&gt;&gt;&gt; base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;)b&apos;binary\\x00string&apos;# url safe&gt;&gt;&gt; base64.b64encode(b&apos;i\\xb7\\x1d\\xfb\\xef\\xff&apos;)b&apos;abcd++//&apos;&gt;&gt;&gt; base64.urlsafe_b64encode(b&apos;i\\xb7\\x1d\\xfb\\xef\\xff&apos;)b&apos;abcd--__&apos;&gt;&gt;&gt; base64.urlsafe_b64decode(&apos;abcd--__&apos;)b&apos;i\\xb7\\x1d\\xfb\\xef\\xff&apos; struct 123456&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&apos;&gt;I&apos;, 10240099) # &gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。b&apos;\\x00\\x9c@c&apos;&gt;&gt;&gt; struct.unpack(&apos;&gt;IH&apos;, b&apos;\\xf0\\xf0\\xf0\\xf0\\x80\\x80&apos;) # I：4字节无符号整数和H：2字节无符号整数。(4042322160, 32896) hashlib 1234567891011import hashlibmd5 = hashlib.md5()md5.update(&apos;how to use md5 in python hashlib?&apos;.encode(&apos;utf-8&apos;))print(md5.hexdigest())# 如果数据量过大,可以分块调用updateimport hashlibmd5 = hashlib.md5()md5.update(&apos;how to use md5 in &apos;.encode(&apos;utf-8&apos;))md5.update(&apos;python hashlib?&apos;.encode(&apos;utf-8&apos;))print(md5.hexdigest()) itertools 1234567891011121314151617181920212223&gt;&gt;&gt; import itertools # 无限迭代&gt;&gt;&gt; natuals = itertools.count(1)# 重复无限迭代 &gt;&gt;&gt; cs = itertools.cycle(&apos;ABC&apos;) # 注意字符串也是序列的一种# 单一元素迭代,可以指定次数ns = itertools.repeat(&apos;A&apos;, 3)# 合并迭代 &gt;&gt;&gt; for c in itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;):... print(c)# groupby()把迭代器中相邻的重复元素挑出来放在一起&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):... print(key, list(group))...A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;]C [&apos;C&apos;, &apos;C&apos;]A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;] contextlib:任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过__enter__和__exit__这两个方法实现的。 1234567891011121314151617181920212223242526272829303132333435from contextlib import contextmanagerclass Query(object): def __init__(self, name): self.name = name def query(self): print(&apos;Query info about %s...&apos; % self.name)@contextmanagerdef create_query(name): print(&apos;Begin&apos;) q = Query(name) yield q print(&apos;End&apos;) # 用contextmanager实现前后自动执行代码@contextmanagerdef tag(name): print(&quot;&lt;%s&gt;&quot; % name) yield print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;): print(&quot;hello&quot;) print(&quot;world&quot;) # 如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&apos;https://www.python.org&apos;)) as page: for line in page: print(line) urllib 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from urllib import requestwith request.urlopen(&apos;https://api.douban.com/v2/book/2129650&apos;) as f: data = f.read() print(&apos;Status:&apos;, f.status, f.reason) for k, v in f.getheaders(): print(&apos;%s: %s&apos; % (k, v)) print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;)) # 加请求头from urllib import requestreq = request.Request(&apos;http://www.douban.com/&apos;)req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)with request.urlopen(req) as f: print(&apos;Status:&apos;, f.status, f.reason) for k, v in f.getheaders(): print(&apos;%s: %s&apos; % (k, v)) print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;)) # post登录from urllib import request, parseprint(&apos;Login to weibo.cn...&apos;)email = input(&apos;Email: &apos;)passwd = input(&apos;Password: &apos;)login_data = parse.urlencode([ (&apos;username&apos;, email), (&apos;password&apos;, passwd), (&apos;entry&apos;, &apos;mweibo&apos;), (&apos;client_id&apos;, &apos;&apos;), (&apos;savestate&apos;, &apos;1&apos;), (&apos;ec&apos;, &apos;&apos;), (&apos;pagerefer&apos;, &apos;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)])req = request.Request(&apos;https://passport.weibo.cn/sso/login&apos;)req.add_header(&apos;Origin&apos;, &apos;https://passport.weibo.cn&apos;)req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)req.add_header(&apos;Referer&apos;, &apos;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)with request.urlopen(req, data=login_data.encode(&apos;utf-8&apos;)) as f: print(&apos;Status:&apos;, f.status, f.reason) for k, v in f.getheaders(): print(&apos;%s: %s&apos; % (k, v)) print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;)) # 代理proxy_handler = urllib.request.ProxyHandler(&#123;&apos;http&apos;: &apos;http://www.example.com:3128/&apos;&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&apos;realm&apos;, &apos;host&apos;, &apos;username&apos;, &apos;password&apos;)opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open(&apos;http://www.example.com/login.html&apos;) as f: pass PIL(Python Imaging Library) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 操作图片from PIL import Image# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&apos;test.jpg&apos;)# 获得图像尺寸:w, h = im.sizeprint(&apos;Original image size: %sx%s&apos; % (w, h))# 缩放到50%:im.thumbnail((w//2, h//2))print(&apos;Resize image to: %sx%s&apos; % (w//2, h//2))# 把缩放后的图像用jpeg格式保存:im.save(&apos;thumbnail.jpg&apos;, &apos;jpeg&apos;)#模糊效果from PIL import Image, ImageFilter# 打开一个jpg图像文件，注意是当前路径:im = Image.open(&apos;test.jpg&apos;)# 应用模糊滤镜:im2 = im.filter(ImageFilter.BLUR)im2.save(&apos;blur.jpg&apos;, &apos;jpeg&apos;)# 生成验证码from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 240 x 60:width = 60 * 4height = 60image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor())# 输出文字:for t in range(4): draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;) 异步IO 协程(Coroutine): 123456789101112131415161718192021def consumer(): r = &apos;&apos; while True: n = yield r if not n: return print(&apos;[CONSUMER] Consuming %s...&apos; % n) r = &apos;200 OK&apos;def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print(&apos;[PRODUCER] Producing %s...&apos; % n) r = c.send(n) print(&apos;[PRODUCER] Consumer return: %s&apos; % r) c.close()c = consumer()produce(c) 1. 首先调用c.send(None)启动生成器； 2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； 3. consumer通过yield拿到消息，处理，又通过yield把结果传回； 4. produce拿到consumer处理的结果，继续生产下一条消息； 5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 asyncio 12345678910111213141516171819202122import asyncio@asyncio.coroutinedef wget(host): print(&apos;wget %s...&apos; % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = &apos;GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n&apos; % host writer.write(header.encode(&apos;utf-8&apos;)) yield from writer.drain() while True: line = yield from reader.readline() if line == b&apos;\\r\\n&apos;: break print(&apos;%s header &gt; %s&apos; % (host, line.decode(&apos;utf-8&apos;).rstrip())) # Ignore the body, close the socket writer.close()loop = asyncio.get_event_loop()tasks = [wget(host) for host in [&apos;www.sina.com.cn&apos;, &apos;www.sohu.com&apos;, &apos;www.163.com&apos;]]loop.run_until_complete(asyncio.wait(tasks))loop.close() Python从3.5版开始为asyncio提供了async和await的新语法； aiohttp: 123456789101112131415161718192021222324import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) return web.Response(body=b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;)async def hello(request): await asyncio.sleep(0.5) text = &apos;&lt;h1&gt;hello, %s!&lt;/h1&gt;&apos; % request.match_info[&apos;name&apos;] return web.Response(body=text.encode(&apos;utf-8&apos;))async def init(loop): app = web.Application(loop=loop) app.router.add_route(&apos;GET&apos;, &apos;/&apos;, index) app.router.add_route(&apos;GET&apos;, &apos;/hello/&#123;name&#125;&apos;, hello) srv = await loop.create_server(app.make_handler(), &apos;127.0.0.1&apos;, 8000) print(&apos;Server started at http://127.0.0.1:8000...&apos;) return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))loop.run_forever() 廖雪峰python教程 https://www.liaoxuefeng.com/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java的字节流","slug":"java的字节流","date":"2017-03-02T03:18:58.000Z","updated":"2019-01-03T14:09:37.765Z","comments":true,"path":"2017/03/02/java的字节流/","link":"","permalink":"http://yoursite.com/2017/03/02/java的字节流/","excerpt":"","text":"字节流(常用)的继承关系: 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: 12345int bytesAvailable = in.avaliable();if(bytesAvailable &gt; 0)&#123; byte[] data = new byte[bytesAvailable]; in.read(data);&#125; OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: 12ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array.ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: 12ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长ByteArrayOutputStream(int size); reset()可将内部buffer的”指针”指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): 12FileInputStream(File file);FileInputStream(String name); FileOutputStream: 构造方法(常用): 1234FileOutputStream(File file);FileOutputStream(File file, boolean append);FileOutputStream(String name);FileOutputStream(String name, boolean append); 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: 12protected ObjectInputStream(); //提供给子类用的...ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: 12protected ObjectOutputStream(); //提供给子类用的...ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个”包装”. BufferedInputStream: 构造方法: 123456789 BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 ``` * BufferedOutputStream: * 构造方法: ```java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个”包装”. DataInputStream: 构造方法: 1234567891011121314151617181920212223 DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版).* DataOutputStream: * 构造方法: ```java DataOutputStream(OutputStream out); ``` * 可以写出基本类型,chars和String(UTF-8修订版).#### 3.PrintStream* PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 )* 不会抛出IO异常,用 checkError()检查是否发生错误.* 构造方法: ```java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. 在实际应用时可能会经常用到嵌套的方式创建一个流对象,举个例子:123DataInputStream dis=new DataInputStream( new BufferedInputStream( new FileInputStream(\"1.dat\")));//这样就可以用DataInputStream的很多方法,而且还有缓冲区. 《java核心技术》卷二. Java Platform Standard Edition 8 Documentation.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-27T00:45:20.000Z","updated":"2019-01-03T14:09:11.455Z","comments":true,"path":"2017/02/27/hello-world/","link":"","permalink":"http://yoursite.com/2017/02/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}