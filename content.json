{"meta":{"title":"Mengjie's Blog","subtitle":null,"description":null,"author":"Mengjie","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-27T07:26:32.947Z","updated":"2018-02-27T07:26:32.947Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Search","date":"2018-02-27T05:40:44.000Z","updated":"2018-02-27T05:40:44.341Z","comments":true,"path":"Search/index.html","permalink":"http://yoursite.com/Search/index.html","excerpt":"","text":""}],"posts":[{"title":"Python学习笔记","slug":"Python学习笔记","date":"2018-02-27T03:45:20.000Z","updated":"2018-02-27T08:23:47.601Z","comments":true,"path":"2018/02/27/Python学习笔记/","link":"","permalink":"http://yoursite.com/2018/02/27/Python学习笔记/","excerpt":"","text":"Python学习笔记函数默认参数: 默认参数必须指向不变对象！(如若可变多次调用会产生不确定的结果) 在调用函数时普通参数和默认参数都可以用: 1fun(参数名=参数值,参数名=参数值....) // 顺序可以调换. 可变参数:12345def fun(*args): // 定义,args is tuple passfun(1,2,3) // 直接传参调用fun(*l) // l is list or tuple 关键字参数:12345def fun(**kw): // 定义,kw is dict pass fun(key_name1=value1,ke_name2=value2)fun(**dic) // dic is dict,传入的参数只是dic的拷贝 命名关键词参数:123456def fun(arg1,*,city,job): passfun('arg1',city='beijing',job='无') // 必须传入参数名,顺序可以调换def fun2(arg1,*args,city,job) // 此时不需要*了,原因可想而知. 参数定义顺序必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 尾递归在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。(Python不优化…) 循环 判断一个对象是否可迭代 12from collections import Iterableisinstance('abc', Iterable) # str是否可迭代 迭代索引+value 12for i, value in enumerate(['A', 'B', 'C']): print(i, value) 列表生成器 1234l1 = list(range(1, 11))l2 = [x * x for x in range(1, 11)]l3 = [x * x for x in range(1, 11) if x % 2 == 0]l4 = [m + n for m in 'ABC' for n in 'XYZ'] generator 通过算法生成下一个迭代值,省内存. 12g = (x * x for x in range(10)) # 生成generatornext(g) # 通过next函数获取g的下一个元素,当没有元素时会抛出异常 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.每次调用next()函数执行,遇到yield返回,再次执行从上一次yield之后执行. Iterator:可以调用next()的对象成为Iterator对象. 1i = iter([1, 2, 3, 4, 5]) # 取得Iterator对象. 函数式编程 map 12r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # r is Iteratorl = list(r) # 转换为list reduce 效果:1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 应用: 12345from functools import reduce def fn(x, y): return x * 10 + yreduce(fn, [1, 3, 5, 7, 9]) # 生成13579 filter sorted 1sorted([36, 5, -12, 9, -21], key=abs) # abs函数作用于每个元素 闭包:返回函数不要引用任何循环变量，或者后续会发生变化的变量。 123456789101112131415161718def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() #9,9,9 def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs lambda 参数名,参数名 : 表达式返回值 decorator1234567891011121314151617181920212223# 两层调用def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper @log #相当于now = log(now) def now(): print('2015-3-25') # 三层调用def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log('execute') #相当于now = log('execute')(now) def now(): print('2015-3-25') 偏函数12import functoolsint2 = functools.partial(int, base=2) # 返回的函数base=2 模块1. 一个py文件就是一个模块. 2. 一个目录里面包含__init__.py,这个目录就是一个包(package). 3. 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； class 实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问. 实的变量名如果以_开头,外部可以访问,但是视为private. 鸭子类型 type() 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue isinstance() 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 测试对象属性和方法 123456789101112131415161718 dir('ABC') #获取对象的属性和方法 &gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19 &gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 __slots__:限制属性 12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 @property:把一个方法变成属性的调用 12345678910111213class Student(object):@propertydef score(self): return self._score@score.setterdef score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value __XXX__ __len__():调用len()时调用 __str__():类似toString __repr__():为调试服务的toString __iter__():该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值 123456789101112class Fib(object):def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 5. \\_\\_getitem__(n): 1234567891011121314151617181920# 实现切片class Fib(object):def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a, b = b, a + b return L 此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。 6. \\_\\_getattr__(self, attr):当获取属性时没有找到,就调用它. 7. \\_\\_call__():可以实现实例本身调用. 1234567891011# 判断对象是否可以实例调用&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable('str')False 枚举类 定义 123from enum import EnumMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) 遍历 123for name, member in Month.__members__.items(): print(name, '=&gt;', member, ',', member.value)# value属性则是自动赋给成员的int常量，默认从1开始计数。 自定义枚举类 1234567891011from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday['Tue'])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; print(day1 == Weekday(1))True&gt;&gt;&gt; Weekday(7)Traceback (most recent call last): ...ValueError: 7 is not a valid Weekday&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, '=&gt;', member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat type():动态创建类1234567891011&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数... print('Hello, %s.' % name)...&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class '__main__.Hello'&gt; 要创建一个class对象，type()函数依次传入3个参数： 1. class的名称； 2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； 3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。 metaclass metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass. 示例: 12345678# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list, metaclass=ListMetaclass): pass __new__()方法接收到的参数依次是： 1. 当前准备创建的类的对象； 2. 类的名字； 3. 类继承的父类集合； 4. 类的方法集合; 调试 异常处理: 12345678910111213try: print('try...') r = 10 / int('2') print('result:', r)except ValueError as e: print('ValueError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)else: print('no error!')finally: print('finally...')print('END') assert(启动Python解释器时可以用-O参数来关闭assert): 1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') unittest 1234567891011121314151617181920212223242526272829303132import unittestfrom mydict import Dictclass TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b='test') self.assertEqual(d.a, 1) self.assertEqual(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEqual(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'], 'value') def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty setUp()和tearDown()方法会分别在每调用一个测试方法的前后分别被执行。 IO 简单示例: 12# 编码和忽略错误f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') StringIO(在内存中读写str): 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO('Hello!\\nHi!\\nGoodbye!')&gt;&gt;&gt; while True:... s = f.readline()... if s == '':... break... print(s.strip())...Hello!Hi!Goodbye! BytesIO 1234&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')&gt;&gt;&gt; f.read()b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 操作文件和目录 目录 1234567891011121314151617# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'/Users/michael'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')# 拆分路径&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')('/Users/michael/testdir', 'file.txt')# 文件扩展名&gt;&gt;&gt; os.path.splitext('/path/to/file.txt')('/path/to/file', '.txt') 2. 文件 12345678910111213# 对文件重命名:&gt;&gt;&gt; os.rename('test.txt', 'test.py')# 删掉文件:&gt;&gt;&gt; os.remove('test.py')''' 制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。'''# 列出文件&gt;&gt;&gt; [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py'] 序列化 1234567891011121314151617181920# 序列化&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b'\\x80\\x03&#125;q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.'# 保存到文件&gt;&gt;&gt; f = open('dump.txt', 'wb')&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close()# 从文件读取&gt;&gt;&gt; f = open('dump.txt', 'rb')&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;'age': 20, 'score': 88, 'name': 'Bob'&#125;# JSONprint(json.dumps(s, default=lambda obj: obj.__dict__)) # __dict__用来存储实例变量 多进程 linux 123456789import osprint('Process (%s) start...' % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 通用 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 进程池 12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All subprocesses done.') 子进程 12345import subprocessprint('$ nslookup www.python.org')r = subprocess.call(['nslookup', 'www.python.org'])print('Exit code:', r) 多线程 创建线程: 1234567891011121314151617import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name) 互斥锁 12345678910111213balance = 0lock = threading.Lock()def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() Global Interpreter Lock: 任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 ThreadLocal:线程之间传递参数,每个线程都有一副本,互不干扰. 123456789101112131415161718192021import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')t1.start()t2.start()t1.join()t2.join() 常用模块 collections namedtuple 1234567&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2 2. deque 1234567# 双向列表&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque(['a', 'b', 'c'])&gt;&gt;&gt; q.append('x')&gt;&gt;&gt; q.appendleft('y')&gt;&gt;&gt; qdeque(['y', 'a', 'b', 'c', 'x']) 3. defaultdict 1234567&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; dd = defaultdict(lambda: 'N/A')&gt;&gt;&gt; dd['key1'] = 'abc'&gt;&gt;&gt; dd['key1'] # key1存在'abc'&gt;&gt;&gt; dd['key2'] # key2不存在，返回默认值'N/A' 4. OrderedDict 1234567&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([('a', 1), ('b', 2), ('c', 3)])&gt;&gt;&gt; d # dict的Key是无序的&#123;'a': 1, 'c': 3, 'b': 2&#125;&gt;&gt;&gt; od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])&gt;&gt;&gt; od # OrderedDict的Key是有序的OrderedDict([('a', 1), ('b', 2), ('c', 3)]) # 根据插入顺序 5. Counter 1234567&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter()&gt;&gt;&gt; for ch in 'programming':... c[ch] = c[ch] + 1...&gt;&gt;&gt; cCounter(&#123;'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1&#125;) base64:将3个字节的二进制编码成四字节对应的字符 12345678910111213&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b'binary\\x00string')b'YmluYXJ5AHN0cmluZw=='&gt;&gt;&gt; base64.b64decode(b'YmluYXJ5AHN0cmluZw==')b'binary\\x00string'# url safe&gt;&gt;&gt; base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff')b'abcd++//'&gt;&gt;&gt; base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff')b'abcd--__'&gt;&gt;&gt; base64.urlsafe_b64decode('abcd--__')b'i\\xb7\\x1d\\xfb\\xef\\xff' struct 123456&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack('&gt;I', 10240099) # &gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。b'\\x00\\x9c@c'&gt;&gt;&gt; struct.unpack('&gt;IH', b'\\xf0\\xf0\\xf0\\xf0\\x80\\x80') # I：4字节无符号整数和H：2字节无符号整数。(4042322160, 32896) hashlib 1234567891011import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest())# 如果数据量过大,可以分块调用updateimport hashlibmd5 = hashlib.md5()md5.update('how to use md5 in '.encode('utf-8'))md5.update('python hashlib?'.encode('utf-8'))print(md5.hexdigest()) itertools 1234567891011121314151617181920212223&gt;&gt;&gt; import itertools # 无限迭代&gt;&gt;&gt; natuals = itertools.count(1)# 重复无限迭代 &gt;&gt;&gt; cs = itertools.cycle('ABC') # 注意字符串也是序列的一种# 单一元素迭代,可以指定次数ns = itertools.repeat('A', 3)# 合并迭代 &gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):... print(c)# groupby()把迭代器中相邻的重复元素挑出来放在一起&gt;&gt;&gt; for key, group in itertools.groupby('AAABBBCCAAA'):... print(key, list(group))...A ['A', 'A', 'A']B ['B', 'B', 'B']C ['C', 'C']A ['A', 'A', 'A'] contextlib:任何对象，只要正确实现了上下文管理，就可以用于with语句。实现上下文管理是通过__enter__和__exit__这两个方法实现的。 1234567891011121314151617181920212223242526272829303132333435from contextlib import contextmanagerclass Query(object): def __init__(self, name): self.name = name def query(self): print('Query info about %s...' % self.name)@contextmanagerdef create_query(name): print('Begin') q = Query(name) yield q print('End') # 用contextmanager实现前后自动执行代码@contextmanagerdef tag(name): print(\"&lt;%s&gt;\" % name) yield print(\"&lt;/%s&gt;\" % name)with tag(\"h1\"): print(\"hello\") print(\"world\") # 如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen('https://www.python.org')) as page: for line in page: print(line) urllib 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from urllib import requestwith request.urlopen('https://api.douban.com/v2/book/2129650') as f: data = f.read() print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', data.decode('utf-8')) # 加请求头from urllib import requestreq = request.Request('http://www.douban.com/')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')with request.urlopen(req) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) # post登录from urllib import request, parseprint('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')with request.urlopen(req, data=login_data.encode('utf-8')) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) # 代理proxy_handler = urllib.request.ProxyHandler(&#123;'http': 'http://www.example.com:3128/'&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password('realm', 'host', 'username', 'password')opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open('http://www.example.com/login.html') as f: pass PIL(Python Imaging Library) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 操作图片from PIL import Image# 打开一个jpg图像文件，注意是当前路径:im = Image.open('test.jpg')# 获得图像尺寸:w, h = im.sizeprint('Original image size: %sx%s' % (w, h))# 缩放到50%:im.thumbnail((w//2, h//2))print('Resize image to: %sx%s' % (w//2, h//2))# 把缩放后的图像用jpeg格式保存:im.save('thumbnail.jpg', 'jpeg')#模糊效果from PIL import Image, ImageFilter# 打开一个jpg图像文件，注意是当前路径:im = Image.open('test.jpg')# 应用模糊滤镜:im2 = im.filter(ImageFilter.BLUR)im2.save('blur.jpg', 'jpeg')# 生成验证码from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rndChar(): return chr(random.randint(65, 90))# 随机颜色1:def rndColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机颜色2:def rndColor2(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 240 x 60:width = 60 * 4height = 60image = Image.new('RGB', (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype('Arial.ttf', 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width): for y in range(height): draw.point((x, y), fill=rndColor())# 输出文字:for t in range(4): draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save('code.jpg', 'jpeg') 异步IO 协程(Coroutine): 123456789101112131415161718192021def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 1. 首先调用c.send(None)启动生成器； 2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； 3. consumer通过yield拿到消息，处理，又通过yield把结果传回； 4. produce拿到consumer处理的结果，继续生产下一条消息； 5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 asyncio 12345678910111213141516171819202122import asyncio@asyncio.coroutinedef wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host writer.write(header.encode('utf-8')) yield from writer.drain() while True: line = yield from reader.readline() if line == b'\\r\\n': break print('%s header &gt; %s' % (host, line.decode('utf-8').rstrip())) # Ignore the body, close the socket writer.close()loop = asyncio.get_event_loop()tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]loop.run_until_complete(asyncio.wait(tasks))loop.close() Python从3.5版开始为asyncio提供了async和await的新语法； aiohttp: 123456789101112131415161718192021222324import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;')async def hello(request): await asyncio.sleep(0.5) text = '&lt;h1&gt;hello, %s!&lt;/h1&gt;' % request.match_info['name'] return web.Response(body=text.encode('utf-8'))async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/&#123;name&#125;', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000...') return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))loop.run_forever() 廖雪峰python教程 https://www.liaoxuefeng.com/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java的字节流","slug":"java的字节流","date":"2018-02-27T03:18:58.000Z","updated":"2018-02-27T07:49:38.503Z","comments":true,"path":"2018/02/27/java的字节流/","link":"","permalink":"http://yoursite.com/2018/02/27/java的字节流/","excerpt":"","text":"字节流(常用)的继承关系: 1.InputStream和OutputStream (抽象类,所以以下都是对它的子类) Input和Output都是对于程序来说的,input是从其他地方的数据读取到程序中,output是把程序中的数据存储在其他地方. read和write方法都在执行时阻塞 read和write方法都可以读取一个或多个字节,但读取一个和读取多个字节不是调用了同一个native方法.(没有看源代码之前我以为读多个字节是用循环读入一个字节实现的) InputStream: int available()返回当前可读入的字节数量.可以避免阻塞的发生: 12345int bytesAvailable = in.avaliable();if(bytesAvailable &gt; 0)&#123; byte[] data = new byte[bytesAvailable]; in.read(data);&#125; OutputStream: close()和flush()方法都会冲刷输出流.有一些数据可能临时存储在缓冲区中等待以更大的包的形式传递,如果不冲刷输出流会出现数据丢失的现象!不关闭流是对系统资源的浪费!所以读取完数据一定要close. 2.ByteArrayInputStream和ByteArrayOutputStream 这两个类都是以内存中的一块buffer作为读取的对象,并且close方法无效,调用close后此类中的方法可以被调用,不会抛出异常. ByteArrayInputStream(不常用): 构造方法: 12ByteArrayInputStream(byte[] buf); //Creates a ByteArrayInputStream so that it uses buf as its buffer array.ByteArrayInputStream(byte[] buf, int offset, int length); 其他的方法和InputStream差不多. ByteArrayOutputStream(常用作为buffer使用): 构造方法: 12ByteArrayOutputStream(); //buffer默认大小为32字节,并且buffer大小可以自动增长ByteArrayOutputStream(int size); reset()可将内部buffer的”指针”指向第一个字节,这样可以再用一次. byte[] toByteArray和String toString()用于获取数据,其中toString还可以指定解码的字符集. writeTo(OutputStream out)将buffer中的字节数组输出在out中,相当于调用 out.write(buf, 0, count). 2.FileInputStream和FileOutputStream 用于文件的读写,读写方式与父类一样,经常用于传入其他IO类的构造方法. FileInputStream: 构造方法(常用): 12FileInputStream(File file);FileInputStream(String name); FileOutputStream: 构造方法(常用): 1234FileOutputStream(File file);FileOutputStream(File file, boolean append);FileOutputStream(String name);FileOutputStream(String name, boolean append); 2.FilterInputStream和FilterOutputStream 这两个类及其子类都需要一个InputStream或OutputStream为参数来构造,这是一种名为装饰(Decorator)的设计模式,它本身只是用传入的参数对象来处理数据,没有做装饰,只是为约束它的子类而写的.具体什么是装饰模式请参考: http://wenku.baidu.com/view/b883510dba1aa8114431d95d.html 装饰和代理模式的区别与联系请参考: http://blog.csdn.net/smalljune/article/details/28631369 2.ObjectInputStream和ObjectOutputStream 这两个类都是用来对于对象的存取的,用于操作的对象要实现java.io.Serializable接口,此接口只用来标记没有方法需要实现.对于一个复杂的对象来说可能会有很多对象实例作为它的域,这时如果仅仅保存对象的引用是没用的,java中是用序列号(serial number)来标识对象,并将它保存至流中,如果对象之前被保存过,只需记录一下,因为序列号对于相同的对象是相等的,而不同的对象是不相等的(有相关的算法).这就是这种机制之所以称为对象序列化的原因. ObjectInputStream: 构造方法: 12protected ObjectInputStream(); //提供给子类用的...ObjectInputStream(InputStream in); 可以读取的类型包括基本类型和类(实现了Serializable接口). String readUTF(),需要注意的是此处读取的是以修订版的UTF-8编码与标准的UTF-8不同,并且在前两个字节还会保存实际写出的字符长度.所以只在写用于JVM的字符串才用这个方法,对于其他场合应该使用writeChars方法. ObjectOutputStream: 构造方法: 12protected ObjectOutputStream(); //提供给子类用的...ObjectOutputStream(OutputStream out); 3.BufferedInputStream和BufferedOutputStream 有一个buffer缓冲(普通的IO类也有buffer缓冲,虽然我不知道默认的大小,但应该这个类的缓冲区会很大吧),可以降低硬盘或其他的东西频繁工作.因为方法过少,通常只是流的一个”包装”. BufferedInputStream: 构造方法: 123456789 BufferedInputStream(InputStream in); BufferedInputStream(InputStream in, int size); //size指定缓冲区大小 ``` * BufferedOutputStream: * 构造方法: ```java BufferedOutputStream(OutputStream out); BufferedOutputStream(OutputStream out, int size); //size指定缓冲区大小 3.DataInputStream和DataOutputStream 这两个类一般作为文件读写流的最后一个”包装”. DataInputStream: 构造方法: 1234567891011121314151617181920212223 DataOutputStream(OutputStream out); ``` * 可以读取基本类型,一行和String(UTF-8修订版).* DataOutputStream: * 构造方法: ```java DataOutputStream(OutputStream out); ``` * 可以写出基本类型,chars和String(UTF-8修订版).#### 3.PrintStream* PrintStream输出字符串时可以指定编码,默认编码为系统默认编码.(DataOutputStream则不可以 )* 不会抛出IO异常,用 checkError()检查是否发生错误.* 构造方法: ```java PrintStream(File file); PrintStream(File file, String csn) //csn==charsetname PrintStream(OutputStream out) PrintStream(OutputStream out, boolean autoFlush) PrintStream(OutputStream out, boolean autoFlush, String encoding) PrintStream(String fileName) PrintStream(String fileName, String csn) System.out正是PrintStream类型,它的方法无需赘言. 在实际应用时可能会经常用到嵌套的方式创建一个流对象,举个例子:123DataInputStream dis=new DataInputStream( new BufferedInputStream( new FileInputStream(\"1.dat\")));//这样就可以用DataInputStream的很多方法,而且还有缓冲区. 《java核心技术》卷二. Java Platform Standard Edition 8 Documentation.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-27T00:45:20.000Z","updated":"2018-02-27T05:42:06.639Z","comments":true,"path":"2018/02/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}